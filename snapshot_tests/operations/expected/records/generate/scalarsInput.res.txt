module MyQuery: {
  @@ocaml.warning("-32-30")
  module Raw: {
    type rec t = {scalarsInput: string}
    type rec t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t<string>,
      string: string,
      nullableInt: Js.Nullable.t<int>,
      int: int,
      nullableFloat: Js.Nullable.t<float>,
      float: float,
      nullableBoolean: Js.Nullable.t<bool>,
      boolean: bool,
      nullableID: Js.Nullable.t<string>,
      id: string,
    }
  }
  type rec t = {scalarsInput: string}
  type rec t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option<string>,
    string: string,
    nullableInt: option<int>,
    int: int,
    nullableFloat: option<float>,
    float: float,
    nullableBoolean: option<bool>,
    boolean: bool,
    nullableID: option<string>,
    id: string,
  }
  @ocaml.doc(" The GraphQL query ") let query: string
  @ocaml.doc(" Parse the JSON-compatible GraphQL data to ReasonML data types ")
  let parse: Raw.t => t
  @ocaml.doc(" Serialize the ReasonML GraphQL data that was parsed using the parse
function back to the original JSON compatible data ")
  let serialize: t => Raw.t
  let serializeVariables: t_variables => Raw.t_variables
  let serializeInputObjectVariousScalarsInput: t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput
  let makeVariables: (~arg: t_variables_VariousScalarsInput, unit) => t_variables
  let makeInputObjectVariousScalarsInput: (
    ~nullableString: string=?,
    ~string: string,
    ~nullableInt: int=?,
    ~int: int,
    ~nullableFloat: float=?,
    ~float: float,
    ~nullableBoolean: bool=?,
    ~boolean: bool,
    ~nullableID: string=?,
    ~id: string,
    unit,
  ) => t_variables_VariousScalarsInput
  external unsafe_fromJson: Js.Json.t => Raw.t = "%identity"
  external toJson: Raw.t => Js.Json.t = "%identity"
  external variablesToJson: Raw.t_variables => Js.Json.t = "%identity"
} = {
  @@ocaml.warning("-32-30")
  module Raw = {
    type rec t = {scalarsInput: string}
    type rec t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t<string>,
      string: string,
      nullableInt: Js.Nullable.t<int>,
      int: int,
      nullableFloat: Js.Nullable.t<float>,
      float: float,
      nullableBoolean: Js.Nullable.t<bool>,
      boolean: bool,
      nullableID: Js.Nullable.t<string>,
      id: string,
    }
  }
  type rec t = {scalarsInput: string}
  type rec t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option<string>,
    string: string,
    nullableInt: option<int>,
    int: int,
    nullableFloat: option<float>,
    float: float,
    nullableBoolean: option<bool>,
    boolean: bool,
    nullableID: option<string>,
    id: string,
  }
  let query = "query ($arg: VariousScalarsInput!)  {
scalarsInput(arg: $arg)  
}
"
  let parse = (
    (value): t => {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput
        value
      },
    }: Raw.t => t
  )
  let serialize = (
    (value): Raw.t => {
      let scalarsInput = {
        let value = (value: t).scalarsInput
        value
      }
      {scalarsInput: scalarsInput}
    }: t => Raw.t
  )
  let rec serializeVariables: t_variables => Raw.t_variables = inp => {
    arg: (a => serializeInputObjectVariousScalarsInput(a))((inp: t_variables).arg),
  }
  and serializeInputObjectVariousScalarsInput: t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput = inp => {
    nullableString: (
      a =>
        switch a {
        | None => Js.Nullable.undefined
        | Some(b) => Js.Nullable.return((a => a)(b))
        }
    )((inp: t_variables_VariousScalarsInput).nullableString),
    string: (a => a)((inp: t_variables_VariousScalarsInput).string),
    nullableInt: (
      a =>
        switch a {
        | None => Js.Nullable.undefined
        | Some(b) => Js.Nullable.return((a => a)(b))
        }
    )((inp: t_variables_VariousScalarsInput).nullableInt),
    int: (a => a)((inp: t_variables_VariousScalarsInput).int),
    nullableFloat: (
      a =>
        switch a {
        | None => Js.Nullable.undefined
        | Some(b) => Js.Nullable.return((a => a)(b))
        }
    )((inp: t_variables_VariousScalarsInput).nullableFloat),
    float: (a => a)((inp: t_variables_VariousScalarsInput).float),
    nullableBoolean: (
      a =>
        switch a {
        | None => Js.Nullable.undefined
        | Some(b) => Js.Nullable.return((a => a)(b))
        }
    )((inp: t_variables_VariousScalarsInput).nullableBoolean),
    boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),
    nullableID: (
      a =>
        switch a {
        | None => Js.Nullable.undefined
        | Some(b) => Js.Nullable.return((a => a)(b))
        }
    )((inp: t_variables_VariousScalarsInput).nullableID),
    id: (a => a)((inp: t_variables_VariousScalarsInput).id),
  }
  let makeVariables = (~arg, ()): t_variables => {arg: arg}
  and makeInputObjectVariousScalarsInput = (
    ~nullableString=?,
    ~string,
    ~nullableInt=?,
    ~int,
    ~nullableFloat=?,
    ~float,
    ~nullableBoolean=?,
    ~boolean,
    ~nullableID=?,
    ~id,
    (),
  ): t_variables_VariousScalarsInput => {
    nullableString,
    string,
    nullableInt,
    int,
    nullableFloat,
    float,
    nullableBoolean,
    boolean,
    nullableID,
    id,
  }
  external unsafe_fromJson: Js.Json.t => Raw.t = "%identity"
  external toJson: Raw.t => Js.Json.t = "%identity"
  external variablesToJson: Raw.t_variables => Js.Json.t = "%identity"
}

