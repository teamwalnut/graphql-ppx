// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Apollo argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {argNamedQuery: int};
    type t_variables = {query: int};
  };
  type t = {argNamedQuery: int};
  /**The GraphQL query string*/
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t_variables = {query: int};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      argNamedQuery: {
        let value = (value: Raw.t).argNamedQuery;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let argNamedQuery = {
        let value = (value: t).argNamedQuery;
        value;
      };
      {argNamedQuery: argNamedQuery};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {query: (a => a)((inp: t_variables).query)};
  let makeVariables = (~query, ()) =>
    serializeVariables({query: query}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_query_82;
    /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_82: _graphql_query_82 = Obj.magic(0);
    type nonrec _graphql_query_75;
    /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_75: _graphql_query_75 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MultipleQueryWithSameVarName = {
  module Query1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {argNamedQuery: int};
      type t_variables = {query: int};
    };
    type t = {argNamedQuery: int};
    /**The GraphQL query string*/
    let query = \\"query Query1($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {query: int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {query: (a => a)((inp: t_variables).query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({query: query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type nonrec _graphql_Query1_query_210;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query1_query_210: _graphql_Query1_query_210 = Obj.magic(0);
      type nonrec _graphql_Query2_query_210;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query2_query_210: _graphql_Query2_query_210 = Obj.magic(0);
      type nonrec _graphql_query_203;
      /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_query_203: _graphql_query_203 = Obj.magic(0);
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Query2 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {argNamedQuery: int};
      type t_variables = {query: int};
    };
    type t = {argNamedQuery: int};
    /**The GraphQL query string*/
    let query = \\"query Query2($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {query: int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {query: (a => a)((inp: t_variables).query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({query: query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type nonrec _graphql_Query1_query_278;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query1_query_278: _graphql_Query1_query_278 = Obj.magic(0);
      type nonrec _graphql_Query2_query_278;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query2_query_278: _graphql_Query2_query_278 = Obj.magic(0);
      type nonrec _graphql_query_271;
      /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_query_271: _graphql_query_271 = Obj.magic(0);
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Apollo comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {nonrecursiveInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nonrecursiveInput: {
        let value = (value: Raw.t).nonrecursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nonrecursiveInput = {
        let value = (value: t).nonrecursiveInput;
        value;
      };
      {nonrecursiveInput: nonrecursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              IntOfString.parse(value);
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              StringOfInt.parse(value);
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let int = {
              let value = (value: t_variousScalars).int;
              StringOfInt.serialize(value);
            }
            and string = {
              let value = (value: t_variousScalars).string;
              IntOfString.serialize(value);
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {__typename, string, int};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customScalarField = {
      __typename: string,
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
    type t = {customScalarField: t_customScalarField};
    type t_variables = {
      opt: Js.Nullable.t(Js.Json.t),
      req: Js.Json.t,
    };
  };
  type t_customScalarField = {
    __typename: string,
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t = {customScalarField: t_customScalarField};
  /**The GraphQL query string*/
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\n__typename  \\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      customScalarField: {
        let value = (value: Raw.t).customScalarField;
        (
          {
            __typename: {
              let value = (value: Raw.t_customScalarField).__typename;
              value;
            },
            nullable: {
              let value = (value: Raw.t_customScalarField).nullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            nonNullable: {
              let value = (value: Raw.t_customScalarField).nonNullable;
              value;
            },
          }: t_customScalarField
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let customScalarField = {
        let value = (value: t).customScalarField;
        (
          {
            let nonNullable = {
              let value = (value: t_customScalarField).nonNullable;
              value;
            }
            and nullable = {
              let value = (value: t_customScalarField).nullable;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_customScalarField).__typename;
              value;
            };
            {__typename, nullable, nonNullable};
          }: Raw.t_customScalarField
        );
      };
      {customScalarField: customScalarField};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      opt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).opt,
        ),
      req: (a => a)((inp: t_variables).req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({opt, req}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_opt_119;
    /**Variable **$opt** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_opt_119: _graphql_opt_119 = Obj.magic(0);
    type nonrec _graphql_argOptional_106;
    /**Argument **argOptional** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_argOptional_106: _graphql_argOptional_106 = Obj.magic(0);
    type nonrec _graphql_req_138;
    /**Variable **$req** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_req_138: _graphql_req_138 = Obj.magic(0);
    type nonrec _graphql_argRequired_125;
    /**Argument **argRequired** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_argRequired_125: _graphql_argRequired_125 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customFields = {
      __typename: string,
      currentTime: Js.Json.t,
      favoriteColor: Js.Json.t,
      futureTime: Js.Nullable.t(Js.Json.t),
      nullableColor: Js.Nullable.t(Js.Json.t),
    };
    type t = {customFields: t_customFields};
    type t_variables = unit;
  };
  type t_customFields = {
    __typename: string,
    currentTime: DateTime.t,
    favoriteColor: Color.t,
    futureTime: option(DateTime.t),
    nullableColor: option(Color.t),
  };
  type t = {customFields: t_customFields};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ncustomFields  {\\\\n__typename  \\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      customFields: {
        let value = (value: Raw.t).customFields;
        (
          {
            __typename: {
              let value = (value: Raw.t_customFields).__typename;
              value;
            },
            currentTime: {
              let value = (value: Raw.t_customFields).currentTime;
              DateTime.parse(value);
            },
            favoriteColor: {
              let value = (value: Raw.t_customFields).favoriteColor;
              Color.parse(value);
            },
            futureTime: {
              let value = (value: Raw.t_customFields).futureTime;
              switch (Js.toOption(value)) {
              | Some(value) => Some(DateTime.parse(value))
              | None => None
              };
            },
            nullableColor: {
              let value = (value: Raw.t_customFields).nullableColor;
              switch (Js.toOption(value)) {
              | Some(value) => Some(Color.parse(value))
              | None => None
              };
            },
          }: t_customFields
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let customFields = {
        let value = (value: t).customFields;
        (
          {
            let nullableColor = {
              let value = (value: t_customFields).nullableColor;
              switch (value) {
              | Some(value) => Js.Nullable.return(Color.serialize(value))
              | None => Js.Nullable.null
              };
            }
            and futureTime = {
              let value = (value: t_customFields).futureTime;
              switch (value) {
              | Some(value) => Js.Nullable.return(DateTime.serialize(value))
              | None => Js.Nullable.null
              };
            }
            and favoriteColor = {
              let value = (value: t_customFields).favoriteColor;
              Color.serialize(value);
            }
            and currentTime = {
              let value = (value: t_customFields).currentTime;
              DateTime.serialize(value);
            }
            and __typename = {
              let value = (value: t_customFields).__typename;
              value;
            };
            {
              __typename,
              currentTime,
              favoriteColor,
              futureTime,
              nullableColor,
            };
          }: Raw.t_customFields
        );
      };
      {customFields: customFields};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {defaultObjectValueOnScalar: string};
    type t_variables = unit;
  };
  type t = {defaultObjectValueOnScalar: string};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      defaultObjectValueOnScalar: {
        let value = (value: Raw.t).defaultObjectValueOnScalar;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let defaultObjectValueOnScalar = {
        let value = (value: t).defaultObjectValueOnScalar;
        value;
      };
      {defaultObjectValueOnScalar: defaultObjectValueOnScalar};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_filter_92;
    /**Argument **filter** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
JsonScalar!
\`\`\`*/
    let _graphql_filter_92: _graphql_filter_92 = Obj.magic(0);
    type nonrec _graphql_arg_140;
    /**Argument **arg** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
EmbeddedInput {
  field: String
}!
\`\`\`*/
    let _graphql_arg_140: _graphql_arg_140 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {enumInput: string};
    type t_variables = {arg: string};
  };
  type t = {enumInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      enumInput: {
        let value = (value: Raw.t).enumInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let enumInput = {
        let value = (value: t).enumInput;
        value;
      };
      {enumInput: enumInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          (inp: t_variables).arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **enumInput** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            __typename: {
              let value = (value: Raw.t_lists).__typename;
              value;
            },
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_lists).__typename;
              value;
            };
            {
              __typename,
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"__typename\\": string,
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"__typename\\": string,
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      }
      and __typename = {
        let value = value##__typename;
        value;
      };
      {
        \\"__typename\\": __typename,
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = value##__typename;
        value;
      };
      {
        \\"__typename\\": __typename,
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module Parent = {
  module ExtendQuery = (M: GraphQLQuery) => {
    let use = () => ();
  };
};
module Bla = {
  module Inner = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_lists = {
        __typename: string,
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
        nonNullableOfNullable: array(Js.Nullable.t(string)),
        nonNullableOfNonNullable: array(string),
      };
      type t = {lists: t_lists};
      type t_variables = unit;
    };
    type t_lists = {
      __typename: string,
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
      nonNullableOfNullable: array(option(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    /**The GraphQL query string*/
    let query = \\"query Bla  {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              __typename: {
                let value = (value: Raw.t_lists).__typename;
                value;
              },
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_lists).__typename;
                value;
              };
              {
                __typename,
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  include Inner;
  include Parent.ExtendQuery(Inner);
};
module Inner = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query Bla2  {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            __typename: {
              let value = (value: Raw.t_lists).__typename;
              value;
            },
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_lists).__typename;
              value;
            };
            {
              __typename,
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
include Inner;
include Parent.ExtendQuery(Inner);
"
`;

exports[`Apollo fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = (value: t).__typename;
        value;
      };
      {__typename, nullableOfNullable, nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      __typename: string,
      nullableOfNonNullable: Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    __typename: string,
    nullableOfNonNullable: option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment Another on Lists   {\\\\n__typename  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = (value: t).__typename;
        value;
      };
      {__typename, nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module FragmentWithArgs = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      __typename: string,
      listWithArg: Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    __typename: string,
    listWithArg: option(array(option(string))),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment FragmentWithArgs on Lists   {\\\\n__typename  \\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      listWithArg: {
        let value = (value: Raw.t).listWithArg;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (
        ~arg1 as _arg1: [ | \`String],
        ~fragmentName as _FragmentWithArgs: [ | \`FragmentWithArgs],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listWithArg = {
        let value = (value: t).listWithArg;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = (value: t).__typename;
        value;
      };
      {__typename, listWithArg};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`FragmentWithArgs => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module InlineListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment InlineListFragment on Lists   {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (
        ~fragmentName as _InlineListFragment: [ | \`InlineListFragment],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = (value: t).__typename;
        value;
      };
      {__typename, nullableOfNullable, nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`InlineListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      l1: ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
      l5: FragmentWithArgs.Raw.t,
    };
    type t_variables = {arg1: Js.Nullable.t(string)};
  };
  type t_l2 = {
    __typename: string,
    frag1: ListFragment.t_Lists,
    frag2: ListFragment.t_Lists,
  };
  type t_l3 = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    frag1: ListFragment.t_Lists,
    frag2: ListFragment.t_Lists,
  };
  type t_l4 = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    inlineListFragment: InlineListFragment.t_Lists,
  };
  type t = {
    l1: ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
    l5: FragmentWithArgs.t,
  };
  /**The GraphQL query string*/
  let query =
    (
      (
        \\"query MyQuery($arg1: String)  {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n__typename  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\n...InlineListFragment   \\\\n}\\\\n\\\\nl5: lists  {\\\\n...FragmentWithArgs   \\\\n}\\\\n\\\\n}\\\\n\\"
        ++ FragmentWithArgs.query
      )
      ++ InlineListFragment.query
    )
    ++ ListFragment.query;
  type t_variables = {arg1: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      l1: {
        let value = (value: Raw.t).l1;

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
      l2: {
        let value = (value: Raw.t).l2;
        (
          {
            __typename: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                );
              value;
            },
            frag1: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
            frag2: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
          }: t_l2
        );
      },
      l3: {
        let value = (value: Raw.t).l3;
        (
          {
            __typename: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                );
              value;
            },
            nullableOfNullable: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
                );
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            frag1: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
            frag2: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
          }: t_l3
        );
      },
      l4: {
        let value = (value: Raw.t).l4;
        (
          {
            __typename: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                );
              value;
            },
            nullableOfNullable: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
                );
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            inlineListFragment: {
              let value: InlineListFragment.Raw.t = Obj.magic(value);

              InlineListFragment.verifyArgsAndParse(
                ~fragmentName=\`InlineListFragment,
                value,
              );
            },
          }: t_l4
        );
      },
      l5: {
        let value = (value: Raw.t).l5;

        FragmentWithArgs.verifyArgsAndParse(
          ~arg1=\`String,
          ~fragmentName=\`FragmentWithArgs,
          value,
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let l5 = {
        let value = (value: t).l5;
        FragmentWithArgs.serialize(value);
      }
      and l4 = {
        let value = (value: t).l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l4).nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  }
                  and __typename = {
                    let value = (value: t_l4).__typename;
                    value;
                  };
                  {
                    \\"__typename\\": __typename,
                    \\"nullableOfNullable\\": nullableOfNullable,
                  };
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(
                    InlineListFragment.serialize(
                      (value: t_l4).inlineListFragment,
                    ),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      }
      and l3 = {
        let value = (value: t).l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l3).nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  }
                  and __typename = {
                    let value = (value: t_l3).__typename;
                    value;
                  };
                  {
                    \\"__typename\\": __typename,
                    \\"nullableOfNullable\\": nullableOfNullable,
                  };
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(ListFragment.serialize((value: t_l3).frag1)): Js.Json.t
                ),
                (
                  Obj.magic(ListFragment.serialize((value: t_l3).frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      }
      and l2 = {
        let value = (value: t).l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let __typename = {
                    let value = (value: t_l2).__typename;
                    value;
                  };
                  {\\"__typename\\": __typename};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(ListFragment.serialize((value: t_l2).frag1)): Js.Json.t
                ),
                (
                  Obj.magic(ListFragment.serialize((value: t_l2).frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      }
      and l1 = {
        let value = (value: t).l1;
        ListFragment.serialize(value);
      };
      {l1, l2, l3, l4, l5};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg1:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).arg1,
        ),
    };
  let makeVariables = (~arg1=?, ()) =>
    serializeVariables({arg1: arg1}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {lists: ListFragment.Raw.t};
    type t_variables = unit;
  };
  type t = {lists: ListFragment.t};
  /**The GraphQL query string*/
  let query =
    \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\n\\" ++ ListFragment.query;
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        ListFragment.serialize(value);
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo fragmentInFragment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\n__typename  \\\\nnullableOfNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      __typename: {
        let value = (value: Raw.t).__typename;
        value;
      },
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = (value: t).__typename;
        value;
      };
      {__typename, nullableOfNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t;
    type nonrec t_Lists = t;
  };
  type t = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    listFragment: ListFragment.t_Lists,
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query =
    \\"fragment Another on Lists   {\\\\n__typename  \\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\n\\"
    ++ ListFragment.query;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      __typename: {
        let value =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        value;
      },
      nullableOfNullable: {
        let value =
          Obj.magic(
            Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
          );
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      listFragment: {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    Obj.magic(
      Js.Array.reduce(
        GraphQL_PPX.deepMerge,
        Obj.magic(
          {
            let nullableOfNullable = {
              let value = (value: t).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t).__typename;
              value;
            };
            {
              \\"__typename\\": __typename,
              \\"nullableOfNullable\\": nullableOfNullable,
            };
          },
        ): Js.Json.t,
        [|
          (
            Obj.magic(ListFragment.serialize((value: t).listFragment)): Js.Json.t
          ),
        |],
      ),
    ): Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Apollo lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            __typename: {
              let value = (value: Raw.t_lists).__typename;
              value;
            },
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_lists).__typename;
              value;
            };
            {
              __typename,
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  type t = {listsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listsInput: {
        let value = (value: Raw.t).listsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listsInput = {
        let value = (value: t).listsInput;
        value;
      };
      {listsInput: listsInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables).nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        nullableOfNullable,
        nullableOfNonNullable,
        nonNullableOfNullable,
        nonNullableOfNonNullable,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_219;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_219: _graphql_arg_219 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {arg: t_variables_ListsInput}
    and t_variables_ListsInput = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  type t = {listsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listsInput: {
        let value = (value: Raw.t).listsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listsInput = {
        let value = (value: t).listsInput;
        value;
      };
      {listsInput: listsInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg: (a => serializeInputObjectListsInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables_ListsInput).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables_ListsInput).nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    nullableOfNullable,
    nullableOfNonNullable,
    nonNullableOfNullable,
    nonNullableOfNonNullable,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_value = {
      __typename: string,
      stringField: string,
    };
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      field: t_mutationWithError_errors_field,
      message: string,
    };
    type t_mutationWithError = {
      __typename: string,
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_value = {
    __typename: string,
    stringField: string,
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    __typename: string,
    field: t_mutationWithError_errors_field,
    message: string,
  };
  type t_mutationWithError = {
    __typename: string,
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nvalue  {\\\\n__typename  \\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\n__typename  \\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            __typename: {
              let value = (value: Raw.t_mutationWithError).__typename;
              value;
            },
            value: {
              let value = (value: Raw.t_mutationWithError).value;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    __typename: {
                      let value =
                        (value: Raw.t_mutationWithError_value).__typename;
                      value;
                    },
                    stringField: {
                      let value =
                        (value: Raw.t_mutationWithError_value).stringField;
                      value;
                    },
                  }: t_mutationWithError_value,
                )
              | None => None
              };
            },
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           __typename: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).
                                 __typename;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | other => \`FutureAddedValue(other)
                             };
                           },
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           }
                           and field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             | \`FutureAddedValue(other) => other
                             };
                           }
                           and __typename = {
                             let value =
                               (value: t_mutationWithError_errors).__typename;
                             value;
                           };
                           {__typename, field, message};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and value = {
              let value = (value: t_mutationWithError).value;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let stringField = {
                      let value =
                        (value: t_mutationWithError_value).stringField;
                      value;
                    }
                    and __typename = {
                      let value =
                        (value: t_mutationWithError_value).__typename;
                      value;
                    };
                    {__typename, stringField};
                  }: Raw.t_mutationWithError_value,
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_mutationWithError).__typename;
              value;
            };
            {__typename, value, errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {optionalInputArgs: string};
    type t_variables = {required: string};
  };
  type t = {optionalInputArgs: string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {required: string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      optionalInputArgs: {
        let value = (value: Raw.t).optionalInputArgs;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let optionalInputArgs = {
        let value = (value: t).optionalInputArgs;
        value;
      };
      {optionalInputArgs: optionalInputArgs};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {required: (a => a)((inp: t_variables).required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({required: required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  type t = {. \\"optionalInputArgs\\": string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {. \\"required\\": string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t_second_inner_inner = {
      __typename: string,
      f1: string,
      f2: string,
    };
    type t_second_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_second_inner_inner),
    };
    type t_second = {
      __typename: string,
      inner: Js.Nullable.t(t_second_inner),
    };
    type t_let_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_let_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_let_inner_inner),
    };
    type t_let = {
      __typename: string,
      inner: Js.Nullable.t(t_let_inner),
    };
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    };
    type t_variables = unit;
  };
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t_second_inner_inner = {
    __typename: string,
    f1: string,
    f2: string,
  };
  type t_second_inner = {
    __typename: string,
    inner: option(t_second_inner_inner),
  };
  type t_second = {
    __typename: string,
    inner: option(t_second_inner),
  };
  type t_let_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_let_inner = {
    __typename: string,
    inner: option(t_let_inner_inner),
  };
  type t_let = {
    __typename: string,
    inner: option(t_let_inner),
  };
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  };
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      first: {
        let value = (value: Raw.t).first;
        (
          {
            __typename: {
              let value = (value: Raw.t_first).__typename;
              value;
            },
            inner: {
              let value = (value: Raw.t_first).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    __typename: {
                      let value = (value: Raw.t_first_inner).__typename;
                      value;
                    },
                    inner: {
                      let value = (value: Raw.t_first_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            __typename: {
                              let value =
                                (value: Raw.t_first_inner_inner).__typename;
                              value;
                            },
                            field: {
                              let value =
                                (value: Raw.t_first_inner_inner).field;
                              value;
                            },
                          }: t_first_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_first_inner,
                )
              | None => None
              };
            },
          }: t_first
        );
      },
      second: {
        let value = (value: Raw.t).second;
        (
          {
            __typename: {
              let value = (value: Raw.t_second).__typename;
              value;
            },
            inner: {
              let value = (value: Raw.t_second).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    __typename: {
                      let value = (value: Raw.t_second_inner).__typename;
                      value;
                    },
                    inner: {
                      let value = (value: Raw.t_second_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            __typename: {
                              let value =
                                (value: Raw.t_second_inner_inner).__typename;
                              value;
                            },
                            f1: {
                              let value = (value: Raw.t_second_inner_inner).f1;
                              value;
                            },
                            f2: {
                              let value = (value: Raw.t_second_inner_inner).f2;
                              value;
                            },
                          }: t_second_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_second_inner,
                )
              | None => None
              };
            },
          }: t_second
        );
      },
      let_: {
        let value = (value: Raw.t).let_;
        (
          {
            __typename: {
              let value = (value: Raw.t_let).__typename;
              value;
            },
            inner: {
              let value = (value: Raw.t_let).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    __typename: {
                      let value = (value: Raw.t_let_inner).__typename;
                      value;
                    },
                    inner: {
                      let value = (value: Raw.t_let_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            __typename: {
                              let value =
                                (value: Raw.t_let_inner_inner).__typename;
                              value;
                            },
                            field: {
                              let value = (value: Raw.t_let_inner_inner).field;
                              value;
                            },
                          }: t_let_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_let_inner,
                )
              | None => None
              };
            },
          }: t_let
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let let_ = {
        let value = (value: t).let_;
        (
          {
            let inner = {
              let value = (value: t_let).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_let_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_let_inner_inner).field;
                              value;
                            }
                            and __typename = {
                              let value =
                                (value: t_let_inner_inner).__typename;
                              value;
                            };
                            {__typename, field};
                          }: Raw.t_let_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_let_inner).__typename;
                      value;
                    };
                    {__typename, inner};
                  }: Raw.t_let_inner,
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_let).__typename;
              value;
            };
            {__typename, inner};
          }: Raw.t_let
        );
      }
      and second = {
        let value = (value: t).second;
        (
          {
            let inner = {
              let value = (value: t_second).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_second_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let f2 = {
                              let value = (value: t_second_inner_inner).f2;
                              value;
                            }
                            and f1 = {
                              let value = (value: t_second_inner_inner).f1;
                              value;
                            }
                            and __typename = {
                              let value =
                                (value: t_second_inner_inner).__typename;
                              value;
                            };
                            {__typename, f1, f2};
                          }: Raw.t_second_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_second_inner).__typename;
                      value;
                    };
                    {__typename, inner};
                  }: Raw.t_second_inner,
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_second).__typename;
              value;
            };
            {__typename, inner};
          }: Raw.t_second
        );
      }
      and first = {
        let value = (value: t).first;
        (
          {
            let inner = {
              let value = (value: t_first).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_first_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_first_inner_inner).field;
                              value;
                            }
                            and __typename = {
                              let value =
                                (value: t_first_inner_inner).__typename;
                              value;
                            };
                            {__typename, field};
                          }: Raw.t_first_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_first_inner).__typename;
                      value;
                    };
                    {__typename, inner};
                  }: Raw.t_first_inner,
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_first).__typename;
              value;
            };
            {__typename, inner};
          }: Raw.t_first
        );
      };
      {first, second, let_};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {nonrecursiveInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nonrecursiveInput: {
        let value = (value: Raw.t).nonrecursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nonrecursiveInput = {
        let value = (value: t).nonrecursiveInput;
        value;
      };
      {nonrecursiveInput: nonrecursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      scalarsInput: string,
      more: string,
    };
    type t_variables = {
      arg: t_variables_NonrecursiveInput,
      arg2: t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {
    scalarsInput: string,
    more: string,
  };
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t_variables = {
    arg: t_variables_NonrecursiveInput,
    arg2: t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
      more: {
        let value = (value: Raw.t).more;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let more = {
        let value = (value: t).more;
        value;
      }
      and scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput, more};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
      arg2:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg2,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({arg, arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_240;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_240: _graphql_arg_240 = Obj.magic(0);
    type nonrec _graphql_arg_235;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_235: _graphql_arg_235 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      __typename: string,
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    __typename: string,
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    __typename: string,
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nerrors  {\\\\n__typename  \\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            __typename: {
              let value = (value: Raw.t_mutationWithError).__typename;
              value;
            },
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           __typename: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).
                                 __typename;
                             value;
                           },
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | other => \`FutureAddedValue(other)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             | \`FutureAddedValue(other) => other
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           }
                           and __typename = {
                             let value =
                               (value: t_mutationWithError_errors).__typename;
                             value;
                           };
                           {__typename, message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_mutationWithError).__typename;
              value;
            };
            {__typename, errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      __typename: string,
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    __typename: string,
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    __typename: string,
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nerrors  {\\\\n__typename  \\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            __typename: {
              let value = (value: Raw.t_mutationWithError).__typename;
              value;
            },
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           __typename: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).
                                 __typename;
                             value;
                           },
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | _ => raise(Not_found)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           }
                           and __typename = {
                             let value =
                               (value: t_mutationWithError_errors).__typename;
                             value;
                           };
                           {__typename, message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_mutationWithError).__typename;
              value;
            };
            {__typename, errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      __typename: string,
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    __typename: string,
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    __typename: string,
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nerrors  {\\\\n__typename  \\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            __typename: {
              let value = (value: Raw.t_mutationWithError).__typename;
              value;
            },
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           __typename: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).
                                 __typename;
                             value;
                           },
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | _ => raise(Not_found)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           }
                           and __typename = {
                             let value =
                               (value: t_mutationWithError_errors).__typename;
                             value;
                           };
                           {__typename, message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_mutationWithError).__typename;
              value;
            };
            {__typename, errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Human).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Human).__typename;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Human).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Human).__typename;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Human).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Human).__typename;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      __typename: string,
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = unit;
  };
  type t_pokemon = {
    __typename: string,
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\n__typename  \\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      pokemon: {
        let value = (value: Raw.t).pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              __typename: {
                let value = (value: Raw.t_pokemon).__typename;
                value;
              },
              id: {
                let value = (value: Raw.t_pokemon).id;
                value;
              },
              name: {
                let value = (value: Raw.t_pokemon).name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_pokemon,
          )
        | None => None
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let pokemon = {
        let value = (value: t).pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = (value: t_pokemon).name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = (value: t_pokemon).id;
                value;
              }
              and __typename = {
                let value = (value: t_pokemon).__typename;
                value;
              };
              {__typename, id, name};
            }: Raw.t_pokemon,
          )
        | None => Js.Nullable.null
        };
      };
      {pokemon: pokemon};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_name_52;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_52: _graphql_name_52 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      __typename: string,
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = {
      id: Js.Nullable.t(string),
      name: Js.Nullable.t(string),
    };
  };
  type t_pokemon = {
    __typename: string,
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\n__typename  \\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      pokemon: {
        let value = (value: Raw.t).pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              __typename: {
                let value = (value: Raw.t_pokemon).__typename;
                value;
              },
              id: {
                let value = (value: Raw.t_pokemon).id;
                value;
              },
              name: {
                let value = (value: Raw.t_pokemon).name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_pokemon,
          )
        | None => None
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let pokemon = {
        let value = (value: t).pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = (value: t_pokemon).name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = (value: t_pokemon).id;
                value;
              }
              and __typename = {
                let value = (value: t_pokemon).__typename;
                value;
              };
              {__typename, id, name};
            }: Raw.t_pokemon,
          )
        | None => Js.Nullable.null
        };
      };
      {pokemon: pokemon};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      id:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).id,
        ),
      name:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({id, name}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_pokemon_name_100;
    /**Variable **$name** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_pokemon_name_100: _graphql_pokemon_name_100 = Obj.magic(0);
    type nonrec _graphql_name_94;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_94: _graphql_name_94 = Obj.magic(0);
    type nonrec _graphql_pokemon_id_111;
    /**Variable **$id** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_pokemon_id_111: _graphql_pokemon_id_111 = Obj.magic(0);
    type nonrec _graphql_id_107;
    /**Argument **id** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_id_107: _graphql_id_107 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t = {variousScalars: scalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
          }: scalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let int = {
              let value = (value: scalars).int;
              value;
            }
            and string = {
              let value = (value: scalars).string;
              value;
            }
            and __typename = {
              let value = (value: scalars).__typename;
              value;
            };
            {__typename, string, int};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {__typename, nullableString};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        __typename: string,
        string,
        int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      __typename: string,
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    /**The GraphQL query string*/
    let query = \\"fragment Fragment on VariousScalars   {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        __typename: {
          let value = (value: Raw.t).__typename;
          value;
        },
        string: {
          let value = (value: Raw.t).string;
          value;
        },
        int: {
          let value = (value: Raw.t).int;
          value;
        },
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _Fragment: [ | \`Fragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let int = {
          let value = (value: t).int;
          value;
        }
        and string = {
          let value = (value: t).string;
          value;
        }
        and __typename = {
          let value = (value: t).__typename;
          value;
        };
        {__typename, string, int};
      }: Raw.t
    );
    let verifyName =
      fun
      | \`Fragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
      type t_variables = unit;
    };
    type t = {variousScalars: Fragment.t};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\n\\"
      ++ Fragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;

          Fragment.verifyArgsAndParse(~fragmentName=\`Fragment, value);
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          Fragment.serialize(value);
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        __typename: string,
        name: string,
        barkVolume: float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    /**The GraphQL query string*/
    let query = \\"fragment DogFragment on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        __typename: {
          let value = (value: Raw.t).__typename;
          value;
        },
        name: {
          let value = (value: Raw.t).name;
          value;
        },
        barkVolume: {
          let value = (value: Raw.t).barkVolume;
          value;
        },
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _DogFragment: [ | \`DogFragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let barkVolume = {
          let value = (value: t).barkVolume;
          value;
        }
        and name = {
          let value = (value: t).name;
          value;
        }
        and __typename = {
          let value = (value: t).__typename;
          value;
        };
        {__typename, name, barkVolume};
      }: Raw.t
    );
    let verifyName =
      fun
      | \`DogFragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_dogOrHuman;
      type t = {dogOrHuman: t_dogOrHuman};
      type t_variables = unit;
    };
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {dogOrHuman: t_dogOrHuman};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      ++ DogFragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: DogFragment.Raw.t = Obj.magic(value);

                  DogFragment.verifyArgsAndParse(
                    ~fragmentName=\`DogFragment,
                    value,
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Apollo recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {recursiveInput: string};
    type t_variables = {arg: t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      otherField: Js.Nullable.t(string),
      inner: Js.Nullable.t(t_variables_RecursiveInput),
      enum: Js.Nullable.t(string),
    };
  };
  type t = {recursiveInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      recursiveInput: {
        let value = (value: Raw.t).recursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let recursiveInput = {
        let value = (value: t).recursiveInput;
        value;
      };
      {recursiveInput: recursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectRecursiveInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      otherField:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_RecursiveInput).otherField,
        ),
      inner:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).inner,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    otherField,
    inner,
    enum,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_90;
    /**Variable **$arg** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_90: _graphql_arg_90 = Obj.magic(0);
    type nonrec _graphql_arg_85;
    /**Argument **arg** on field **recursiveInput** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_85: _graphql_arg_85 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {
              __typename,
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  type t = {scalarsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput: scalarsInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableString,
        ),
      string: (a => a)((inp: t_variables).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableInt,
        ),
      int: (a => a)((inp: t_variables).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableFloat,
        ),
      float: (a => a)((inp: t_variables).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableID,
        ),
      id: (a => a)((inp: t_variables).id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        nullableString,
        string,
        nullableInt,
        int,
        nullableFloat,
        float,
        nullableBoolean,
        boolean,
        nullableID,
        id,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_292;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_292: _graphql_arg_292 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  type t = {scalarsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput: scalarsInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectVariousScalarsInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableString,
        ),
      string: (a => a)((inp: t_variables_VariousScalarsInput).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableInt,
        ),
      int: (a => a)((inp: t_variables_VariousScalarsInput).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableFloat,
        ),
      float: (a => a)((inp: t_variables_VariousScalarsInput).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableID,
        ),
      id: (a => a)((inp: t_variables_VariousScalarsInput).id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    nullableString,
    string,
    nullableInt,
    int,
    nullableFloat,
    float,
    nullableBoolean,
    boolean,
    nullableID,
    id,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_93;
    /**Variable **$arg** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_93: _graphql_arg_93 = Obj.magic(0);
    type nonrec _graphql_arg_88;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_88: _graphql_arg_88 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_v1 = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t_v2 = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t = {
      v1: t_v1,
      v2: t_v2,
    };
    type t_variables = {var: bool};
  };
  type t_v1 = {
    __typename: string,
    nullableString: option(string),
    string: option(string),
  };
  type t_v2 = {
    __typename: string,
    nullableString: option(string),
    string: option(string),
  };
  type t = {
    v1: t_v1,
    v2: t_v2,
  };
  /**The GraphQL query string*/
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\n__typename  \\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\n__typename  \\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {var: bool};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      v1: {
        let value = (value: Raw.t).v1;
        (
          {
            __typename: {
              let value = (value: Raw.t_v1).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_v1).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_v1).string;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_v1
        );
      },
      v2: {
        let value = (value: Raw.t).v2;
        (
          {
            __typename: {
              let value = (value: Raw.t_v2).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_v2).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_v2).string;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_v2
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let v2 = {
        let value = (value: t).v2;
        (
          {
            let string = {
              let value = (value: t_v2).string;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and nullableString = {
              let value = (value: t_v2).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_v2).__typename;
              value;
            };
            {__typename, nullableString, string};
          }: Raw.t_v2
        );
      }
      and v1 = {
        let value = (value: t).v1;
        (
          {
            let string = {
              let value = (value: t_v1).string;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and nullableString = {
              let value = (value: t_v1).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_v1).__typename;
              value;
            };
            {__typename, nullableString, string};
          }: Raw.t_v1
        );
      };
      {v1, v2};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {var: (a => a)((inp: t_variables).var)};
  let makeVariables = (~var, ()) =>
    serializeVariables({var: var}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_simpleSubscription_Dog = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription_Human = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription;
    type t = {simpleSubscription: t_simpleSubscription};
    type t_variables = unit;
  };
  type t_simpleSubscription_Dog = {
    __typename: string,
    name: string,
  };
  type t_simpleSubscription_Human = {
    __typename: string,
    name: string,
  };
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {simpleSubscription: t_simpleSubscription};
  /**The GraphQL query string*/
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      simpleSubscription: {
        let value = (value: Raw.t).simpleSubscription;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value =
                        (value: Raw.t_simpleSubscription_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_simpleSubscription_Dog).name;
                      value;
                    },
                  }: t_simpleSubscription_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value =
                        (value: Raw.t_simpleSubscription_Human).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_simpleSubscription_Human).name;
                      value;
                    },
                  }: t_simpleSubscription_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let simpleSubscription = {
        let value = (value: t).simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_simpleSubscription_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_simpleSubscription_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name};
              }: Raw.t_simpleSubscription_Dog,
            ): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_simpleSubscription_Human).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_simpleSubscription_Human).__typename;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_simpleSubscription_Human,
            ): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      };
      {simpleSubscription: simpleSubscription};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {
              __typename,
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module MyTypes = {
  type query;
};
module MyQuery1a = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: MyTypes.query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {
              __typename,
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1a {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery1b = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {
              __typename,
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1b {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {
              __typename,
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {
              __typename,
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            __typename: {
              let value = (value: Raw.t_variousScalars).__typename;
              value;
            },
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_variousScalars).__typename;
              value;
            };
            {
              __typename,
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t = {first: t_first};
    type t_variables = unit;
  };
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t = {first: t_first};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      first: {
        let value = (value: Raw.t).first;
        (
          {
            __typename: {
              let value = (value: Raw.t_first).__typename;
              value;
            },
            inner: {
              let value = (value: Raw.t_first).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    __typename: {
                      let value = (value: Raw.t_first_inner).__typename;
                      value;
                    },
                    inner: {
                      let value = (value: Raw.t_first_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            __typename: {
                              let value =
                                (value: Raw.t_first_inner_inner).__typename;
                              value;
                            },
                            field: {
                              let value =
                                (value: Raw.t_first_inner_inner).field;
                              value;
                            },
                          }: t_first_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_first_inner,
                )
              | None => None
              };
            },
          }: t_first
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let first = {
        let value = (value: t).first;
        (
          {
            let inner = {
              let value = (value: t_first).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_first_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_first_inner_inner).field;
                              value;
                            }
                            and __typename = {
                              let value =
                                (value: t_first_inner_inner).__typename;
                              value;
                            };
                            {__typename, field};
                          }: Raw.t_first_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_first_inner).__typename;
                      value;
                    };
                    {__typename, inner};
                  }: Raw.t_first_inner,
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_first).__typename;
              value;
            };
            {__typename, inner};
          }: Raw.t_first
        );
      };
      {first: first};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Human).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Human).__typename;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Human).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Human).__typename;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

type named = {name: string};
module NamedQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(named)
    | \`Human(named)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                  }: named
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Human).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: named
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: named).name;
                  value;
                }
                and __typename = {
                  let value = (value: named).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: named).name;
                  value;
                }
                and __typename = {
                  let value = (value: named).__typename;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module NamedQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    __typename: {
                      let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                }
                and __typename = {
                  let value = (value: t_dogOrHuman_Dog).__typename;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Apollo variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationForVariant_dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {mutationForVariant: t_mutationForVariant};
    type t_variables = unit;
  };
  type t_mutationForVariant_dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_human = {
    __typename: string,
    name: string,
  };
  type t_mutationForVariant_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {mutationForVariant: t_mutationForVariant};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationForVariant: {
        let value = (value: Raw.t).mutationForVariant;
        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
        | None =>
          Js.Exn.raiseError(
            \\"graphql-ppx: \\"
            ++ \\"Expected type \\"
            ++ \\"VariantTestResult\\"
            ++ \\" to be an object\\",
          )
        | Some(value) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseType(value);
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseTypeList(value |> Js.Array.map(value => value));
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Dog(
                  {
                    __typename: {
                      let value =
                        (value: Raw.t_mutationForVariant_dog).__typename;
                      value;
                    },
                    name: {
                      let value = (value: Raw.t_mutationForVariant_dog).name;
                      value;
                    },
                    barkVolume: {
                      let value =
                        (value: Raw.t_mutationForVariant_dog).barkVolume;
                      value;
                    },
                  }: t_mutationForVariant_dog,
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Human(
                    {
                      __typename: {
                        let value =
                          (value: Raw.t_mutationForVariant_human).__typename;
                        value;
                      },
                      name: {
                        let value =
                          (value: Raw.t_mutationForVariant_human).name;
                        value;
                      },
                    }: t_mutationForVariant_human,
                  );
                | Some(_) =>
                  let temp =
                    Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`DogOrHuman(
                      {
                        let typename: string =
                          Obj.magic(
                            Js.Dict.unsafeGet(
                              Obj.magic(value),
                              \\"__typename\\",
                            ),
                          );
                        (
                          switch (typename) {
                          | \\"Dog\\" =>
                            \`Dog(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                  Obj.magic(value);
                                (
                                  {
                                    __typename: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                        ).
                                          __typename;
                                      value;
                                    },
                                    name: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                        ).
                                          name;
                                      value;
                                    },
                                    barkVolume: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                        ).
                                          barkVolume;
                                      value;
                                    },
                                  }: t_mutationForVariant_dogOrHuman_Dog
                                );
                              },
                            )
                          | \\"Human\\" =>
                            \`Human(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                  Obj.magic(value);
                                (
                                  {
                                    __typename: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Human
                                        ).
                                          __typename;
                                      value;
                                    },
                                    name: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Human
                                        ).
                                          name;
                                      value;
                                    },
                                  }: t_mutationForVariant_dogOrHuman_Human
                                );
                              },
                            )
                          | _ =>
                            \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                          }: t_mutationForVariant_dogOrHuman
                        );
                      },
                    );
                  | Some(_) =>
                    Js.Exn.raiseError(
                      \\"graphql-ppx: \\"
                      ++ \\"All fields on variant selection set on type \\"
                      ++ \\"VariantTestResult\\"
                      ++ \\" were null\\",
                    )
                  };
                };
              };
            };
          };
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationForVariant = {
        let value = (value: t).mutationForVariant;
        Obj.magic(Js.Json.null);
      };
      {mutationForVariant: mutationForVariant};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Compilation (Objects) argNamedQuery.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serializeVariables(inp) {
  return {
          query: inp.query
        };
}

function makeVariables(query, param) {
  return serializeVariables({
              query: query
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize$1(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serializeVariables$1(inp) {
  return {
          query: inp.query
        };
}

function makeVariables$1(query, param) {
  return serializeVariables$1({
              query: query
            });
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var Query1 = {
  Raw: Raw$1,
  query: \\"query Query1($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize$2(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serializeVariables$2(inp) {
  return {
          query: inp.query
        };
}

function makeVariables$2(query, param) {
  return serializeVariables$2({
              query: query
            });
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var Query2 = {
  Raw: Raw$2,
  query: \\"query Query2($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var MultipleQueryWithSameVarName = {
  Query1: Query1,
  Query2: Query2
};

exports.MyQuery = MyQuery;
exports.MultipleQueryWithSameVarName = MultipleQueryWithSameVarName;
/* No side effect */
"
`;

exports[`Compilation (Objects) comment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput(Caml_option.valFromOption(b));
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) customDecoder.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_format = require(\\"bs-platform/lib/js/caml_format.js\\");

function parse(prim) {
  return String(prim);
}

var serialize = Caml_format.caml_int_of_string;

var StringOfInt = {
  parse: parse,
  serialize: serialize
};

var parse$1 = Caml_format.caml_int_of_string;

function serialize$1(prim) {
  return String(prim);
}

var IntOfString = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var $$int = String(value$2);
  var value$3 = value$1.string;
  var string = Caml_format.caml_int_of_string(value$3);
  return {
          variousScalars: {
            string: string,
            int: $$int
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var $$int = Caml_format.caml_int_of_string(value$2);
  var value$3 = value$1.string;
  var string = String(value$3);
  return {
          variousScalars: {
            string: string,
            int: $$int
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.StringOfInt = StringOfInt;
exports.IntOfString = IntOfString;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) customScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nonNullable;
  var value$3 = value$1.nullable;
  var nullable = !(value$3 == null) ? Caml_option.some(value$3) : undefined;
  return {
          customScalarField: {
            nullable: nullable,
            nonNullable: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nonNullable;
  var value$3 = value$1.nullable;
  var nullable = value$3 !== undefined ? Caml_option.valFromOption(value$3) : null;
  return {
          customScalarField: {
            nullable: nullable,
            nonNullable: value$2
          }
        };
}

function serializeVariables(inp) {
  var a = inp.opt;
  return {
          opt: a !== undefined ? Caml_option.valFromOption(a) : undefined,
          req: inp.req
        };
}

function makeVariables(opt, req, param) {
  return serializeVariables({
              opt: opt,
              req: req
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) customTypes.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

function parse(json) {
  var match = Js_json.decodeString(json);
  if (match === undefined) {
    return /* Red */0;
  }
  switch (match) {
    case \\"blue\\" :
        return /* Blue */2;
    case \\"green\\" :
        return /* Green */1;
    case \\"red\\" :
        return /* Red */0;
    default:
      return /* Red */0;
  }
}

function serialize(color) {
  switch (color) {
    case /* Red */0 :
        return \\"red\\";
    case /* Green */1 :
        return \\"green\\";
    case /* Blue */2 :
        return \\"blue\\";
    
  }
}

var Color = {
  parse: parse,
  serialize: serialize
};

function parse$1(json) {
  var str = Js_json.decodeString(json);
  if (str !== undefined) {
    return new Date(str);
  } else {
    return new Date();
  }
}

function serialize$1(date) {
  return date.toISOString();
}

var DateTime = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.nullableColor;
  var nullableColor = !(value$2 == null) ? parse(value$2) : undefined;
  var value$3 = value$1.futureTime;
  var futureTime = !(value$3 == null) ? Caml_option.some(parse$1(value$3)) : undefined;
  var value$4 = value$1.favoriteColor;
  var favoriteColor = parse(value$4);
  var value$5 = value$1.currentTime;
  var currentTime = parse$1(value$5);
  return {
          customFields: {
            currentTime: currentTime,
            favoriteColor: favoriteColor,
            futureTime: futureTime,
            nullableColor: nullableColor
          }
        };
}

function serialize$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.nullableColor;
  var nullableColor = value$2 !== undefined ? serialize(value$2) : null;
  var value$3 = value$1.futureTime;
  var futureTime = value$3 !== undefined ? Caml_option.valFromOption(value$3).toISOString() : null;
  var value$4 = value$1.favoriteColor;
  var favoriteColor = serialize(value$4);
  var value$5 = value$1.currentTime;
  var currentTime = value$5.toISOString();
  return {
          customFields: {
            currentTime: currentTime,
            favoriteColor: favoriteColor,
            futureTime: futureTime,
            nullableColor: nullableColor
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.Color = Color;
exports.DateTime = DateTime;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) defaultObjectValueOnScalar.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          defaultObjectValueOnScalar: value.defaultObjectValueOnScalar
        };
}

function serialize(value) {
  return {
          defaultObjectValueOnScalar: value.defaultObjectValueOnScalar
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) enumInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          enumInput: value.enumInput
        };
}

function serialize(value) {
  return {
          enumInput: value.enumInput
        };
}

function serializeVariables(inp) {
  var a = inp.arg;
  return {
          arg: a !== 225952583 ? (
              a >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
            ) : \\"THIRD\\"
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

var Z__INTERNAL = {
  _graphql_SampleField_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) explicit_object_record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var RecordsQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (!(value == null)) {
            return value;
          }
          
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$4 == null) ? value$4.map((function (value) {
            return value;
          })) : undefined;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = !(value$5 == null) ? value$5.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ObjectsQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.RecordsQuery = RecordsQuery;
exports.ObjectsQuery = ObjectsQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) extensions.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function ExtendQuery(M) {
  var use = function (param) {
    
  };
  return {
          use: use
        };
}

var Parent = {
  ExtendQuery: ExtendQuery
};

var Raw = { };

var query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (!(value == null)) {
            return value;
          }
          
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$4 == null) ? value$4.map((function (value) {
            return value;
          })) : undefined;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = !(value$5 == null) ? value$5.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Inner = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

function use(param) {
  
}

var Bla = {
  Inner: Inner,
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL,
  use: use
};

var Raw$1 = { };

var query$1 = \\"query Bla2  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (!(value == null)) {
            return value;
          }
          
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$4 == null) ? value$4.map((function (value) {
            return value;
          })) : undefined;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = !(value$5 == null) ? value$5.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var Inner$1 = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

function use$1(param) {
  
}

exports.Parent = Parent;
exports.Bla = Bla;
exports.Inner = Inner$1;
exports.Raw = Raw$1;
exports.query = query$1;
exports.parse = parse$1;
exports.serialize = serialize$1;
exports.serializeVariables = serializeVariables$1;
exports.makeVariables = makeVariables$1;
exports.makeDefaultVariables = makeDefaultVariables$1;
exports.Z__INTERNAL = Z__INTERNAL$1;
exports.use = use$1;
/* No side effect */
"
`;

exports[`Compilation (Objects) fragmentDefinition.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function deepMerge(json1, param) {
  return json1;
}

var GraphQL_PPX = {
  deepMerge: deepMerge
};

var Raw = { };

var query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$1 == null) ? value$1.map((function (value) {
            return value;
          })) : undefined;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = !(value$2 == null) ? value$2.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyArgsAndParse(_ListFragment, value) {
  return parse(value);
}

function serialize(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  Raw: Raw,
  query: query,
  parse: parse,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.nullableOfNonNullable;
  return {
          nullableOfNonNullable: !(value$1 == null) ? value$1.map((function (value) {
                    return value;
                  })) : undefined
        };
}

function verifyArgsAndParse$1(_Another, value) {
  return parse$1(value);
}

function serialize$1(value) {
  var value$1 = value.nullableOfNonNullable;
  return {
          nullableOfNonNullable: value$1 !== undefined ? value$1.map((function (value) {
                    return value;
                  })) : null
        };
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  Raw: Raw$1,
  query: \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\",
  parse: parse$1,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$1,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$1 = \\"fragment FragmentWithArgs on Lists   {\\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\n\\";

function parse$2(value) {
  var value$1 = value.listWithArg;
  return {
          listWithArg: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined
        };
}

function verifyArgsAndParse$2(_arg1, _FragmentWithArgs, value) {
  return parse$2(value);
}

function serialize$2(value) {
  var value$1 = value.listWithArg;
  return {
          listWithArg: value$1 !== undefined ? value$1.map((function (value) {
                    if (value !== undefined) {
                      return value;
                    } else {
                      return null;
                    }
                  })) : null
        };
}

function verifyName$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var FragmentWithArgs = {
  Raw: Raw$2,
  query: query$1,
  parse: parse$2,
  verifyArgsAndParse: verifyArgsAndParse$2,
  serialize: serialize$2,
  verifyName: verifyName$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$2 = \\"fragment InlineListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$3(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$1 == null) ? value$1.map((function (value) {
            return value;
          })) : undefined;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = !(value$2 == null) ? value$2.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyArgsAndParse$3(_InlineListFragment, value) {
  return parse$3(value);
}

function serialize$3(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName$3(param) {
  
}

var Z__INTERNAL$3 = {
  graphql: 0,
  graphql_module: 0
};

var InlineListFragment = {
  Raw: Raw$3,
  query: query$2,
  parse: parse$3,
  verifyArgsAndParse: verifyArgsAndParse$3,
  serialize: serialize$3,
  verifyName: verifyName$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var Raw$4 = { };

var query$3 = \\"query MyQuery($arg1: String)  {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...InlineListFragment   \\\\n}\\\\n\\\\nl5: lists  {\\\\n...FragmentWithArgs   \\\\n}\\\\n\\\\n}\\\\nfragment FragmentWithArgs on Lists   {\\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\nfragment InlineListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$4(value) {
  var value$1 = value.l5;
  var l5 = parse$2(value$1);
  var value$2 = value.l4;
  var inlineListFragment = parse$3(value$2);
  var value$3 = value$2[\\"nullableOfNullable\\"];
  var nullableOfNullable = !(value$3 == null) ? value$3.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  var l4 = {
    nullableOfNullable: nullableOfNullable,
    inlineListFragment: inlineListFragment
  };
  var value$4 = value.l3;
  var frag2 = parse(value$4);
  var frag1 = parse(value$4);
  var value$5 = value$4[\\"nullableOfNullable\\"];
  var nullableOfNullable$1 = !(value$5 == null) ? value$5.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  var l3 = {
    nullableOfNullable: nullableOfNullable$1,
    frag1: frag1,
    frag2: frag2
  };
  var value$6 = value.l2;
  var frag2$1 = parse(value$6);
  var frag1$1 = parse(value$6);
  var l2 = {
    frag1: frag1$1,
    frag2: frag2$1
  };
  var value$7 = value.l1;
  var l1 = parse(value$7);
  return {
          l1: l1,
          l2: l2,
          l3: l3,
          l4: l4,
          l5: l5
        };
}

function serialize$4(value) {
  var value$1 = value.l5;
  var l5 = serialize$2(value$1);
  var value$2 = value.l4;
  var value$3 = value$2.nullableOfNullable;
  var l4 = [serialize$3(value$2.inlineListFragment)].reduce(deepMerge, {
        nullableOfNullable: value$3 !== undefined ? value$3.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$4 = value.l3;
  var value$5 = value$4.nullableOfNullable;
  var l3 = [
      serialize(value$4.frag1),
      serialize(value$4.frag2)
    ].reduce(deepMerge, {
        nullableOfNullable: value$5 !== undefined ? value$5.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$6 = value.l2;
  var l2 = [
      serialize(value$6.frag1),
      serialize(value$6.frag2)
    ].reduce(deepMerge, (function (prim) {
          return { };
        }));
  var value$7 = value.l1;
  var l1 = serialize(value$7);
  return {
          l1: l1,
          l2: l2,
          l3: l3,
          l4: l4,
          l5: l5
        };
}

function serializeVariables(inp) {
  var a = inp.arg1;
  return {
          arg1: a !== undefined ? a : undefined
        };
}

function makeVariables(arg1, param) {
  return serializeVariables({
              arg1: arg1
            });
}

function makeDefaultVariables(param) {
  return makeVariables(undefined, undefined);
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw$4,
  query: query$3,
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$4 = \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$5(value) {
  var value$1 = value.lists;
  return {
          lists: parse(value$1)
        };
}

function serialize$5(value) {
  var value$1 = value.lists;
  return {
          lists: serialize(value$1)
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$5 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$5,
  query: query$4,
  parse: parse$5,
  serialize: serialize$5,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$5
};

exports.GraphQL_PPX = GraphQL_PPX;
exports.ListFragment = ListFragment;
exports.Another = Another;
exports.FragmentWithArgs = FragmentWithArgs;
exports.InlineListFragment = InlineListFragment;
exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Objects) fragmentInFragment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function deepMerge(json1, param) {
  return json1;
}

var GraphQL_PPX = {
  deepMerge: deepMerge
};

var Raw = { };

var query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.nullableOfNullable;
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined
        };
}

function verifyArgsAndParse(_ListFragment, value) {
  return parse(value);
}

function serialize(value) {
  var value$1 = value.nullableOfNullable;
  return {
          nullableOfNullable: value$1 !== undefined ? value$1.map((function (value) {
                    if (value !== undefined) {
                      return value;
                    } else {
                      return null;
                    }
                  })) : null
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  Raw: Raw,
  query: query,
  parse: parse,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = \\"fragment Another on Lists   {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\n}\\\\n\\";

function parse$1(value) {
  var listFragment = parse(value);
  var value$1 = value[\\"nullableOfNullable\\"];
  var nullableOfNullable = !(value$1 == null) ? value$1.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          nullableOfNullable: nullableOfNullable,
          listFragment: listFragment
        };
}

function verifyArgsAndParse$1(_Another, value) {
  return parse$1(value);
}

function serialize$1(value) {
  var value$1 = value.nullableOfNullable;
  return [serialize(value.listFragment)].reduce(deepMerge, {
              nullableOfNullable: value$1 !== undefined ? value$1.map((function (value) {
                        if (value !== undefined) {
                          return value;
                        } else {
                          return null;
                        }
                      })) : null
            });
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$1,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.GraphQL_PPX = GraphQL_PPX;
exports.ListFragment = ListFragment;
exports.Another = Another;
/* No side effect */
"
`;

exports[`Compilation (Objects) interface.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
"
`;

exports[`Compilation (Objects) lists.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (!(value == null)) {
            return value;
          }
          
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$4 == null) ? value$4.map((function (value) {
            return value;
          })) : undefined;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = !(value$5 == null) ? value$5.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) listsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  return {
          listsInput: value.listsInput
        };
}

function serializeVariables(inp) {
  var a = inp.nullableOfNullable;
  var a$1 = inp.nullableOfNonNullable;
  var a$2 = inp.nonNullableOfNullable;
  var a$3 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          nullableOfNonNullable: a$1 !== undefined ? $$Array.map((function (b) {
                    return b;
                  }), a$1) : undefined,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$2),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$3)
        };
}

function makeVariables(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return serializeVariables({
              nullableOfNullable: nullableOfNullable,
              nullableOfNonNullable: nullableOfNonNullable,
              nonNullableOfNullable: nonNullableOfNullable,
              nonNullableOfNonNullable: nonNullableOfNonNullable
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) listsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  return {
          listsInput: value.listsInput
        };
}

function serializeInputObjectListsInput(inp) {
  var a = inp.nullableOfNullable;
  var a$1 = inp.nullableOfNonNullable;
  var a$2 = inp.nonNullableOfNullable;
  var a$3 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          nullableOfNonNullable: a$1 !== undefined ? $$Array.map((function (b) {
                    return b;
                  }), a$1) : undefined,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$2),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$3)
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectListsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectListsInput(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable,
          nonNullableOfNullable: nonNullableOfNullable,
          nonNullableOfNonNullable: nonNullableOfNonNullable
        };
}

var Z__INTERNAL = {
  _graphql_ListsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectListsInput: serializeInputObjectListsInput,
  makeVariables: makeVariables,
  makeInputObjectListsInput: makeInputObjectListsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) mutation.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = !(value$2 == null) ? value$2.map((function (value) {
            var value$1 = value.message;
            var value$2 = value.field;
            var field;
            switch (value$2) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                field = /* \`FutureAddedValue */[
                  -31101740,
                  value$2
                ];
            }
            return {
                    field: field,
                    message: value$1
                  };
          })) : undefined;
  var value$3 = value$1.value;
  var value$4 = !(value$3 == null) ? ({
        stringField: value$3.stringField
      }) : undefined;
  return {
          mutationWithError: {
            value: value$4,
            errors: errors
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.message;
            var value$2 = value.field;
            var field = typeof value$2 === \\"number\\" ? (
                value$2 !== 225952583 ? (
                    value$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$2[1];
            return {
                    field: field,
                    message: value$1
                  };
          })) : null;
  var value$3 = value$1.value;
  var value$4 = value$3 !== undefined ? ({
        stringField: Caml_option.valFromOption(value$3).stringField
      }) : null;
  return {
          mutationWithError: {
            value: value$4,
            errors: errors
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) mutationWithArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return serializeVariables({
              required: required
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) mutationWithArgsAndNoRecords.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return serializeVariables({
              required: required
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) nested.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.let_;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 == null) {
    inner = undefined;
  } else {
    var value$3 = value$2.inner;
    inner = {
      inner: !(value$3 == null) ? ({
            field: value$3.field
          }) : undefined
    };
  }
  var let_ = {
    inner: inner
  };
  var value$4 = value.second;
  var value$5 = value$4.inner;
  var inner$1;
  if (value$5 == null) {
    inner$1 = undefined;
  } else {
    var value$6 = value$5.inner;
    var tmp;
    if (value$6 == null) {
      tmp = undefined;
    } else {
      var value$7 = value$6.f2;
      var value$8 = value$6.f1;
      tmp = {
        f1: value$8,
        f2: value$7
      };
    }
    inner$1 = {
      inner: tmp
    };
  }
  var second = {
    inner: inner$1
  };
  var value$9 = value.first;
  var value$10 = value$9.inner;
  var inner$2;
  if (value$10 == null) {
    inner$2 = undefined;
  } else {
    var value$11 = value$10.inner;
    inner$2 = {
      inner: !(value$11 == null) ? ({
            field: value$11.field
          }) : undefined
    };
  }
  var first = {
    inner: inner$2
  };
  return {
          first: first,
          second: second,
          let_: let_
        };
}

function serialize(value) {
  var value$1 = value.let_;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = Caml_option.valFromOption(value$2).inner;
    inner = {
      inner: value$3 !== undefined ? ({
            field: Caml_option.valFromOption(value$3).field
          }) : null
    };
  } else {
    inner = null;
  }
  var let_ = {
    inner: inner
  };
  var value$4 = value.second;
  var value$5 = value$4.inner;
  var inner$1;
  if (value$5 !== undefined) {
    var value$6 = Caml_option.valFromOption(value$5).inner;
    var tmp;
    if (value$6 !== undefined) {
      var value$7 = value$6.f2;
      var value$8 = value$6.f1;
      tmp = {
        f1: value$8,
        f2: value$7
      };
    } else {
      tmp = null;
    }
    inner$1 = {
      inner: tmp
    };
  } else {
    inner$1 = null;
  }
  var second = {
    inner: inner$1
  };
  var value$9 = value.first;
  var value$10 = value$9.inner;
  var inner$2;
  if (value$10 !== undefined) {
    var value$11 = Caml_option.valFromOption(value$10).inner;
    inner$2 = {
      inner: value$11 !== undefined ? ({
            field: Caml_option.valFromOption(value$11).field
          }) : null
    };
  } else {
    inner$2 = null;
  }
  var first = {
    inner: inner$2
  };
  return {
          first: first,
          second: second,
          let_: let_
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) nonrecursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput(Caml_option.valFromOption(b));
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.more;
  var value$2 = value.scalarsInput;
  return {
          scalarsInput: value$2,
          more: value$1
        };
}

function serialize$1(value) {
  var value$1 = value.more;
  var value$2 = value.scalarsInput;
  return {
          scalarsInput: value$2,
          more: value$1
        };
}

function serializeInputObjectEmbeddedInput$1(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput$1(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput$1(Caml_option.valFromOption(b));
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables$1(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput$1(inp.arg),
          arg2: serializeInputObjectNonrecursiveInput$1(inp.arg2)
        };
}

function makeVariables$1(arg, arg2, param) {
  return serializeVariables$1({
              arg: arg,
              arg2: arg2
            });
}

function makeInputObjectNonrecursiveInput$1(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput$1(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL$1 = {
  _graphql_NonrecursiveInput_169: 0,
  _graphql_NonrecursiveInput_196: 0,
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$1,
  query: \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput$1,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput$1,
  makeVariables: makeVariables$1,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput$1,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Objects) omitFutureValueEnum.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = !(value$2 == null) ? value$2.map((function (value) {
            var value$1 = value.field;
            var field;
            switch (value$1) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                field = /* \`FutureAddedValue */[
                  -31101740,
                  value$1
                ];
            }
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : undefined;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = typeof value$1 === \\"number\\" ? (
                value$1 !== 225952583 ? (
                    value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$1[1];
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = !(value$2 == null) ? value$2.map((function (value) {
            var value$1 = value.field;
            var field;
            switch (value$1) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                throw Caml_builtin_exceptions.not_found;
            }
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : undefined;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serialize$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = !(value$2 == null) ? value$2.map((function (value) {
            var value$1 = value.field;
            var field;
            switch (value$1) {
              case \\"FIRST\\" :
                  field = /* FIRST */-24399856;
                  break;
              case \\"SECOND\\" :
                  field = /* SECOND */382368628;
                  break;
              case \\"THIRD\\" :
                  field = /* THIRD */225952583;
                  break;
              default:
                throw Caml_builtin_exceptions.not_found;
            }
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : undefined;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serialize$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  return {
          mutationWithError: {
            errors: errors
          }
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Objects) omitFutureValueUnion.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    tmp = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    tmp = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Objects) pokedexApolloMode.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    var name = !(value$2 == null) ? value$2 : undefined;
    var value$3 = value$1.id;
    tmp = {
      id: value$3,
      name: name
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 !== undefined) {
    var value$2 = Caml_option.valFromOption(value$1);
    var value$3 = value$2.name;
    var name = value$3 !== undefined ? value$3 : null;
    var value$4 = value$2.id;
    tmp = {
      id: value$4,
      name: name
    };
  } else {
    tmp = null;
  }
  return {
          pokemon: tmp
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) pokedexScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    var name = !(value$2 == null) ? value$2 : undefined;
    var value$3 = value$1.id;
    tmp = {
      id: value$3,
      name: name
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 !== undefined) {
    var value$2 = Caml_option.valFromOption(value$1);
    var value$3 = value$2.name;
    var name = value$3 !== undefined ? value$3 : null;
    var value$4 = value$2.id;
    tmp = {
      id: value$4,
      name: name
    };
  } else {
    tmp = null;
  }
  return {
          pokemon: tmp
        };
}

function serializeVariables(inp) {
  var a = inp.id;
  var a$1 = inp.name;
  return {
          id: a !== undefined ? a : undefined,
          name: a$1 !== undefined ? a$1 : undefined
        };
}

function makeVariables(id, name, param) {
  return serializeVariables({
              id: id,
              name: name
            });
}

function makeDefaultVariables(param) {
  return makeVariables(undefined, undefined, undefined);
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var value$3 = value$1.string;
  return {
          variousScalars: {
            string: value$3,
            int: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var value$3 = value$1.string;
  return {
          variousScalars: {
            string: value$3,
            int: value$2
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var nullableString = !(value$2 == null) ? value$2 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var nullableString = value$2 !== undefined ? value$2 : null;
  return {
          variousScalars: {
            nullableString: nullableString
          }
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var OneFieldQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

function parse$2(value) {
  var value$1 = value.int;
  var value$2 = value.string;
  return {
          string: value$2,
          int: value$1
        };
}

function verifyArgsAndParse(_Fragment, value) {
  return parse$2(value);
}

function serialize$2(value) {
  var value$1 = value.int;
  var value$2 = value.string;
  return {
          string: value$2,
          int: value$1
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var Fragment = {
  Raw: Raw$2,
  query: query,
  parse: parse$2,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize$2,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$1 = \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\nfragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

function parse$3(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: parse$2(value$1)
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: serialize$2(value$1)
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var Untitled1 = {
  Raw: Raw$3,
  query: query$1,
  parse: parse$3,
  serialize: serialize$3,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$3
};

var ExternalFragmentQuery = {
  Fragment: Fragment,
  Untitled1: Untitled1
};

var Raw$4 = { };

function parse$4(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  if (typename === \\"Dog\\") {
    var value$2 = value$1.barkVolume;
    var value$3 = value$1.name;
    tmp = /* \`Dog */[
      3406428,
      {
        name: value$3,
        barkVolume: value$2
      }
    ];
  } else {
    tmp = /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$4(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables$3(param) {
  
}

function makeVariables$3(param) {
  
}

function makeDefaultVariables$3(param) {
  
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var InlineFragmentQuery = {
  Raw: Raw$4,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables$3,
  makeVariables: makeVariables$3,
  makeDefaultVariables: makeDefaultVariables$3,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$2 = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

function parse$5(value) {
  var value$1 = value.barkVolume;
  var value$2 = value.name;
  return {
          name: value$2,
          barkVolume: value$1
        };
}

function verifyArgsAndParse$1(_DogFragment, value) {
  return parse$5(value);
}

function serialize$5(value) {
  var value$1 = value.barkVolume;
  var value$2 = value.name;
  return {
          name: value$2,
          barkVolume: value$1
        };
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$5 = {
  graphql: 0,
  graphql_module: 0
};

var DogFragment = {
  Raw: Raw$5,
  query: query$2,
  parse: parse$5,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$5,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$5
};

var Raw$6 = { };

var query$3 = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\nfragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

function parse$6(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      parse$5(value$1)
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$6(value) {
  var value$1 = value.dogOrHuman;
  return {
          dogOrHuman: value$1[0] >= 3406428 ? serialize$5(value$1[1]) : value$1[1]
        };
}

function serializeVariables$4(param) {
  
}

function makeVariables$4(param) {
  
}

function makeDefaultVariables$4(param) {
  
}

var Z__INTERNAL$6 = {
  graphql_module: 0
};

var Untitled1$1 = {
  Raw: Raw$6,
  query: query$3,
  parse: parse$6,
  serialize: serialize$6,
  serializeVariables: serializeVariables$4,
  makeVariables: makeVariables$4,
  makeDefaultVariables: makeDefaultVariables$4,
  Z__INTERNAL: Z__INTERNAL$6
};

var UnionExternalFragmentQuery = {
  DogFragment: DogFragment,
  Untitled1: Untitled1$1
};

exports.MyQuery = MyQuery;
exports.OneFieldQuery = OneFieldQuery;
exports.ExternalFragmentQuery = ExternalFragmentQuery;
exports.InlineFragmentQuery = InlineFragmentQuery;
exports.UnionExternalFragmentQuery = UnionExternalFragmentQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) recursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          recursiveInput: value.recursiveInput
        };
}

function serialize(value) {
  return {
          recursiveInput: value.recursiveInput
        };
}

function serializeInputObjectRecursiveInput(inp) {
  var a = inp.otherField;
  var a$1 = inp.inner;
  var a$2 = inp.enum;
  return {
          otherField: a !== undefined ? a : undefined,
          inner: a$1 !== undefined ? serializeInputObjectRecursiveInput(Caml_option.valFromOption(a$1)) : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectRecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectRecursiveInput(otherField, inner, $$enum, param) {
  return {
          otherField: otherField,
          inner: inner,
          enum: $$enum
        };
}

var Z__INTERNAL = {
  _graphql_RecursiveInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectRecursiveInput: serializeInputObjectRecursiveInput,
  makeVariables: makeVariables,
  makeInputObjectRecursiveInput: makeInputObjectRecursiveInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) scalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = !(value$3 == null) ? value$3 : undefined;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = !(value$7 == null) ? value$7 : undefined;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = !(value$9 == null) ? value$9 : undefined;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = !(value$11 == null) ? value$11 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) scalarsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serializeVariables(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function makeVariables(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return serializeVariables({
              nullableString: nullableString,
              string: string,
              nullableInt: nullableInt,
              int: $$int,
              nullableFloat: nullableFloat,
              float: $$float,
              nullableBoolean: nullableBoolean,
              boolean: $$boolean,
              nullableID: nullableID,
              id: id
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) scalarsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serializeInputObjectVariousScalarsInput(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectVariousScalarsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

function makeInputObjectVariousScalarsInput(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return {
          nullableString: nullableString,
          string: string,
          nullableInt: nullableInt,
          int: $$int,
          nullableFloat: nullableFloat,
          float: $$float,
          nullableBoolean: nullableBoolean,
          boolean: $$boolean,
          nullableID: nullableID,
          id: id
        };
}

var Z__INTERNAL = {
  _graphql_VariousScalarsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectVariousScalarsInput: serializeInputObjectVariousScalarsInput,
  makeVariables: makeVariables,
  makeInputObjectVariousScalarsInput: makeInputObjectVariousScalarsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) skipDirectives.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.v2;
  var value$2 = value$1.string;
  var string = !(value$2 == null) ? value$2 : undefined;
  var value$3 = value$1.nullableString;
  var nullableString = !(value$3 == null) ? value$3 : undefined;
  var v2 = {
    nullableString: nullableString,
    string: string
  };
  var value$4 = value.v1;
  var value$5 = value$4.string;
  var string$1 = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$4.nullableString;
  var nullableString$1 = !(value$6 == null) ? value$6 : undefined;
  var v1 = {
    nullableString: nullableString$1,
    string: string$1
  };
  return {
          v1: v1,
          v2: v2
        };
}

function serialize(value) {
  var value$1 = value.v2;
  var value$2 = value$1.string;
  var string = value$2 !== undefined ? value$2 : null;
  var value$3 = value$1.nullableString;
  var nullableString = value$3 !== undefined ? value$3 : null;
  var v2 = {
    nullableString: nullableString,
    string: string
  };
  var value$4 = value.v1;
  var value$5 = value$4.string;
  var string$1 = value$5 !== undefined ? value$5 : null;
  var value$6 = value$4.nullableString;
  var nullableString$1 = value$6 !== undefined ? value$6 : null;
  var v1 = {
    nullableString: nullableString$1,
    string: string$1
  };
  return {
          v1: v1,
          v2: v2
        };
}

function serializeVariables(inp) {
  return {
          var: inp.var
        };
}

function makeVariables($$var, param) {
  return serializeVariables({
              var: $$var
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) subscription.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.simpleSubscription;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          simpleSubscription: tmp
        };
}

function serialize(value) {
  var value$1 = value.simpleSubscription;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          simpleSubscription: tmp
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) tagged_template.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = !(value$3 == null) ? value$3 : undefined;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = !(value$7 == null) ? value$7 : undefined;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = !(value$9 == null) ? value$9 : undefined;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = !(value$11 == null) ? value$11 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var MyTypes = { };

var Raw$1 = { };

var query$1 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = !(value$3 == null) ? value$3 : undefined;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = !(value$7 == null) ? value$7 : undefined;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = !(value$9 == null) ? value$9 : undefined;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = !(value$11 == null) ? value$11 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQuery1a = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = !(value$3 == null) ? value$3 : undefined;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = !(value$7 == null) ? value$7 : undefined;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = !(value$9 == null) ? value$9 : undefined;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = !(value$11 == null) ? value$11 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var MyQuery1b = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$3 = (require(\\"gatsby\\").graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = !(value$3 == null) ? value$3 : undefined;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = !(value$7 == null) ? value$7 : undefined;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = !(value$9 == null) ? value$9 : undefined;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = !(value$11 == null) ? value$11 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serializeVariables$3(param) {
  
}

function makeVariables$3(param) {
  
}

function makeDefaultVariables$3(param) {
  
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$3,
  query: query$3,
  parse: parse$3,
  serialize: serialize$3,
  serializeVariables: serializeVariables$3,
  makeVariables: makeVariables$3,
  makeDefaultVariables: makeDefaultVariables$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var Raw$4 = { };

var query$4 = (require(\\"gatsby\\").graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$4(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = !(value$3 == null) ? value$3 : undefined;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = !(value$7 == null) ? value$7 : undefined;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = !(value$9 == null) ? value$9 : undefined;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = !(value$11 == null) ? value$11 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$4(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serializeVariables$4(param) {
  
}

function makeVariables$4(param) {
  
}

function makeDefaultVariables$4(param) {
  
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var MyQuery3 = {
  Raw: Raw$4,
  query: query$4,
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables$4,
  makeVariables: makeVariables$4,
  makeDefaultVariables: makeDefaultVariables$4,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$5 = (require(\\"gatsby\\")\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$5(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = !(value$3 == null) ? value$3 : undefined;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = !(value$5 == null) ? value$5 : undefined;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = !(value$7 == null) ? value$7 : undefined;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = !(value$9 == null) ? value$9 : undefined;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = !(value$11 == null) ? value$11 : undefined;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serialize$5(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  return {
          variousScalars: {
            nullableString: nullableString,
            string: value$10,
            nullableInt: nullableInt,
            int: value$8,
            nullableFloat: nullableFloat,
            float: value$6,
            nullableBoolean: nullableBoolean,
            boolean: value$4,
            nullableID: nullableID,
            id: value$2
          }
        };
}

function serializeVariables$5(param) {
  
}

function makeVariables$5(param) {
  
}

function makeDefaultVariables$5(param) {
  
}

var Z__INTERNAL$5 = {
  graphql_module: 0
};

var MyQuery4 = {
  Raw: Raw$5,
  query: query$5,
  parse: parse$5,
  serialize: serialize$5,
  serializeVariables: serializeVariables$5,
  makeVariables: makeVariables$5,
  makeDefaultVariables: makeDefaultVariables$5,
  Z__INTERNAL: Z__INTERNAL$5
};

exports.MyQuery = MyQuery;
exports.MyTypes = MyTypes;
exports.MyQuery1a = MyQuery1a;
exports.MyQuery1b = MyQuery1b;
exports.MyQuery2 = MyQuery2;
exports.MyQuery3 = MyQuery3;
exports.MyQuery4 = MyQuery4;
/* query Not a pure module */
"
`;

exports[`Compilation (Objects) typename.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 == null) {
    inner = undefined;
  } else {
    var value$3 = value$2.inner;
    var inner$1;
    if (value$3 == null) {
      inner$1 = undefined;
    } else {
      var value$4 = value$3.field;
      var value$5 = value$3.__typename;
      inner$1 = {
        __typename: value$5,
        field: value$4
      };
    }
    var value$6 = value$2.__typename;
    inner = {
      __typename: value$6,
      inner: inner$1
    };
  }
  var value$7 = value$1.__typename;
  return {
          first: {
            __typename: value$7,
            inner: inner
          }
        };
}

function serialize(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = Caml_option.valFromOption(value$2);
    var value$4 = value$3.inner;
    var inner$1;
    if (value$4 !== undefined) {
      var value$5 = Caml_option.valFromOption(value$4);
      var value$6 = value$5.field;
      var value$7 = value$5.__typename;
      inner$1 = {
        __typename: value$7,
        field: value$6
      };
    } else {
      inner$1 = null;
    }
    var value$8 = value$3.__typename;
    inner = {
      __typename: value$8,
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var value$9 = value$1.__typename;
  return {
          first: {
            __typename: value$9,
            inner: inner
          }
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) union.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.barkVolume;
        var value$3 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$3,
            barkVolume: value$2
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQueryNoError = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        var value$2 = value$1.name;
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$2
          }
        ];
        break;
    case \\"Human\\" :
        var value$3 = value$1.name;
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$3
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var tmp;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      tmp = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      tmp = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var NamedQuery = {
  Raw: Raw$2,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.MyQuery = MyQuery;
exports.MyQueryNoError = MyQueryNoError;
exports.NamedQuery = NamedQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) unionPartial.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  if (typename === \\"Dog\\") {
    var value$2 = value$1.barkVolume;
    var value$3 = value$1.name;
    tmp = /* \`Dog */[
      3406428,
      {
        name: value$3,
        barkVolume: value$2
      }
    ];
  } else {
    tmp = /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var tmp;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    tmp = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    tmp = value$1[1];
  }
  return {
          dogOrHuman: tmp
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Objects) variant.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require(\\"bs-platform/lib/js/js_exn.js\\");
var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationForVariant;
  var value$2 = Js_json.decodeObject(value$1);
  var tmp;
  if (value$2 !== undefined) {
    var value$3 = Caml_option.valFromOption(value$2);
    var temp = value$3[\\"baseType\\"];
    var match = Js_json.decodeNull(temp);
    if (match !== undefined) {
      var temp$1 = value$3[\\"baseTypeList\\"];
      var match$1 = Js_json.decodeNull(temp$1);
      if (match$1 !== undefined) {
        var temp$2 = value$3[\\"dog\\"];
        var match$2 = Js_json.decodeNull(temp$2);
        if (match$2 !== undefined) {
          var temp$3 = value$3[\\"human\\"];
          var match$3 = Js_json.decodeNull(temp$3);
          if (match$3 !== undefined) {
            var temp$4 = value$3[\\"dogOrHuman\\"];
            var match$4 = Js_json.decodeNull(temp$4);
            if (match$4 !== undefined) {
              tmp = Js_exn.raiseError(\\"graphql-ppx: All fields on variant selection set on type VariantTestResult were null\\");
            } else {
              var typename = temp$4[\\"__typename\\"];
              var tmp$1;
              switch (typename) {
                case \\"Dog\\" :
                    var value$4 = temp$4.barkVolume;
                    var value$5 = temp$4.name;
                    tmp$1 = /* \`Dog */[
                      3406428,
                      {
                        name: value$5,
                        barkVolume: value$4
                      }
                    ];
                    break;
                case \\"Human\\" :
                    tmp$1 = /* \`Human */[
                      -1031617139,
                      {
                        name: temp$4.name
                      }
                    ];
                    break;
                default:
                  tmp$1 = /* \`FutureAddedValue */[
                    -31101740,
                    temp$4
                  ];
              }
              tmp = /* \`DogOrHuman */[
                974247566,
                tmp$1
              ];
            }
          } else {
            tmp = /* \`Human */[
              -1031617139,
              {
                name: temp$3.name
              }
            ];
          }
        } else {
          var value$6 = temp$2.barkVolume;
          var value$7 = temp$2.name;
          tmp = /* \`Dog */[
            3406428,
            {
              name: value$7,
              barkVolume: value$6
            }
          ];
        }
      } else {
        tmp = /* \`BaseTypeList */[
          -259847799,
          temp$1.map((function (value) {
                  return value;
                }))
        ];
      }
    } else {
      tmp = /* \`BaseType */[
        -620191861,
        temp
      ];
    }
  } else {
    tmp = Js_exn.raiseError(\\"graphql-ppx: Expected type VariantTestResult to be an object\\");
  }
  return {
          mutationForVariant: tmp
        };
}

function serialize(value) {
  value.mutationForVariant;
  return {
          mutationForVariant: null
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) argNamedQuery.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize(value) {
  var value$1 = value.argNamedQuery;
  return {
          argNamedQuery: value$1
        };
}

function serializeVariables(inp) {
  return {
          query: inp.query
        };
}

function makeVariables(query, param) {
  return {
          query: query
        };
}

var Z__INTERNAL = {
  _graphql_query_82: 0,
  _graphql_query_75: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize$1(value) {
  var value$1 = value.argNamedQuery;
  return {
          argNamedQuery: value$1
        };
}

function serializeVariables$1(inp) {
  return {
          query: inp.query
        };
}

function makeVariables$1(query, param) {
  return {
          query: query
        };
}

var Z__INTERNAL$1 = {
  _graphql_Query1_query_210: 0,
  _graphql_Query2_query_210: 0,
  _graphql_query_203: 0,
  graphql_module: 0
};

var Query1 = {
  Raw: Raw$1,
  query: \\"query Query1($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize$2(value) {
  var value$1 = value.argNamedQuery;
  return {
          argNamedQuery: value$1
        };
}

function serializeVariables$2(inp) {
  return {
          query: inp.query
        };
}

function makeVariables$2(query, param) {
  return {
          query: query
        };
}

var Z__INTERNAL$2 = {
  _graphql_Query1_query_278: 0,
  _graphql_Query2_query_278: 0,
  _graphql_query_271: 0,
  graphql_module: 0
};

var Query2 = {
  Raw: Raw$2,
  query: \\"query Query2($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var MultipleQueryWithSameVarName = {
  Query1: Query1,
  Query2: Query2
};

exports.MyQuery = MyQuery;
exports.MultipleQueryWithSameVarName = MultipleQueryWithSameVarName;
/* No side effect */
"
`;

exports[`Compilation (Records) comment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  var value$1 = value.nonrecursiveInput;
  return {
          nonrecursiveInput: value$1
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput(b);
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectNonrecursiveInput(arg)
        };
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_arg_100: 0,
  _graphql_arg_95: 0,
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) customDecoder.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_format = require(\\"bs-platform/lib/js/caml_format.js\\");

function parse(prim) {
  return String(prim);
}

var serialize = Caml_format.caml_int_of_string;

var StringOfInt = {
  parse: parse,
  serialize: serialize
};

var parse$1 = Caml_format.caml_int_of_string;

function serialize$1(prim) {
  return String(prim);
}

var IntOfString = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: {
            string: Caml_format.caml_int_of_string(value$1.string),
            int: String(value$1.int)
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var $$int = Caml_format.caml_int_of_string(value$2);
  var value$3 = value$1.string;
  var string = String(value$3);
  var variousScalars = {
    string: string,
    int: $$int
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.StringOfInt = StringOfInt;
exports.IntOfString = IntOfString;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) customScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nullable;
  return {
          customScalarField: {
            nullable: !(value$2 == null) ? Caml_option.some(value$2) : undefined,
            nonNullable: value$1.nonNullable
          }
        };
}

function serialize(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nonNullable;
  var value$3 = value$1.nullable;
  var nullable = value$3 !== undefined ? Caml_option.valFromOption(value$3) : null;
  var customScalarField = {
    nullable: nullable,
    nonNullable: value$2
  };
  return {
          customScalarField: customScalarField
        };
}

function serializeVariables(inp) {
  var a = inp.opt;
  return {
          opt: a !== undefined ? Caml_option.valFromOption(a) : undefined,
          req: inp.req
        };
}

function makeVariables(opt, req, param) {
  return serializeVariables({
              opt: opt,
              req: req
            });
}

var Z__INTERNAL = {
  _graphql_opt_119: 0,
  _graphql_argOptional_106: 0,
  _graphql_req_138: 0,
  _graphql_argRequired_125: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) customTypes.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

function parse(json) {
  var match = Js_json.decodeString(json);
  if (match === undefined) {
    return /* Red */0;
  }
  switch (match) {
    case \\"blue\\" :
        return /* Blue */2;
    case \\"green\\" :
        return /* Green */1;
    case \\"red\\" :
        return /* Red */0;
    default:
      return /* Red */0;
  }
}

function serialize(color) {
  switch (color) {
    case /* Red */0 :
        return \\"red\\";
    case /* Green */1 :
        return \\"green\\";
    case /* Blue */2 :
        return \\"blue\\";
    
  }
}

var Color = {
  parse: parse,
  serialize: serialize
};

function parse$1(json) {
  var str = Js_json.decodeString(json);
  if (str !== undefined) {
    return new Date(str);
  } else {
    return new Date();
  }
}

function serialize$1(date) {
  return date.toISOString();
}

var DateTime = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

function parse$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.futureTime;
  var value$3 = value$1.nullableColor;
  return {
          customFields: {
            currentTime: parse$1(value$1.currentTime),
            favoriteColor: parse(value$1.favoriteColor),
            futureTime: !(value$2 == null) ? Caml_option.some(parse$1(value$2)) : undefined,
            nullableColor: !(value$3 == null) ? parse(value$3) : undefined
          }
        };
}

function serialize$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.nullableColor;
  var nullableColor = value$2 !== undefined ? serialize(value$2) : null;
  var value$3 = value$1.futureTime;
  var futureTime = value$3 !== undefined ? Caml_option.valFromOption(value$3).toISOString() : null;
  var value$4 = value$1.favoriteColor;
  var favoriteColor = serialize(value$4);
  var value$5 = value$1.currentTime;
  var currentTime = value$5.toISOString();
  var customFields = {
    currentTime: currentTime,
    favoriteColor: favoriteColor,
    futureTime: futureTime,
    nullableColor: nullableColor
  };
  return {
          customFields: customFields
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.Color = Color;
exports.DateTime = DateTime;
exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) defaultObjectValueOnScalar.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          defaultObjectValueOnScalar: value.defaultObjectValueOnScalar
        };
}

function serialize(value) {
  var value$1 = value.defaultObjectValueOnScalar;
  return {
          defaultObjectValueOnScalar: value$1
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  _graphql_filter_92: 0,
  _graphql_arg_140: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) enumInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          enumInput: value.enumInput
        };
}

function serialize(value) {
  var value$1 = value.enumInput;
  return {
          enumInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.arg;
  return {
          arg: a !== 225952583 ? (
              a >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
            ) : \\"THIRD\\"
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

var Z__INTERNAL = {
  _graphql_arg_82: 0,
  _graphql_arg_77: 0,
  _graphql_SampleField_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) explicit_object_record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var RecordsQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (!(value == null)) {
            return value;
          }
          
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$4 == null) ? value$4.map((function (value) {
            return value;
          })) : undefined;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = !(value$5 == null) ? value$5.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ObjectsQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.RecordsQuery = RecordsQuery;
exports.ObjectsQuery = ObjectsQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) extensions.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function ExtendQuery(M) {
  var use = function (param) {
    
  };
  return {
          use: use
        };
}

var Parent = {
  ExtendQuery: ExtendQuery
};

var Raw = { };

var query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Inner = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

function use(param) {
  
}

var Bla = {
  Inner: Inner,
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL,
  use: use
};

var Raw$1 = { };

var query$1 = \\"query Bla2  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var Inner$1 = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

function use$1(param) {
  
}

exports.Parent = Parent;
exports.Bla = Bla;
exports.Inner = Inner$1;
exports.Raw = Raw$1;
exports.query = query$1;
exports.parse = parse$1;
exports.serialize = serialize$1;
exports.serializeVariables = serializeVariables$1;
exports.makeVariables = makeVariables$1;
exports.makeDefaultVariables = makeDefaultVariables$1;
exports.Z__INTERNAL = Z__INTERNAL$1;
exports.use = use$1;
/* No side effect */
"
`;

exports[`Compilation (Records) fragmentDefinition.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function deepMerge(json1, param) {
  return json1;
}

var GraphQL_PPX = {
  deepMerge: deepMerge
};

var Raw = { };

var query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.nullableOfNullable;
  var value$2 = value.nullableOfNonNullable;
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined,
          nullableOfNonNullable: !(value$2 == null) ? value$2.map((function (value) {
                    return value;
                  })) : undefined
        };
}

function verifyArgsAndParse(_ListFragment, value) {
  return parse(value);
}

function serialize(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  Raw: Raw,
  query: query,
  parse: parse,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.nullableOfNonNullable;
  return {
          nullableOfNonNullable: !(value$1 == null) ? value$1.map((function (value) {
                    return value;
                  })) : undefined
        };
}

function verifyArgsAndParse$1(_Another, value) {
  return parse$1(value);
}

function serialize$1(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  return {
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  Raw: Raw$1,
  query: \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\",
  parse: parse$1,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$1,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$1 = \\"fragment FragmentWithArgs on Lists   {\\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\n\\";

function parse$2(value) {
  var value$1 = value.listWithArg;
  return {
          listWithArg: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined
        };
}

function verifyArgsAndParse$2(_arg1, _FragmentWithArgs, value) {
  return parse$2(value);
}

function serialize$2(value) {
  var value$1 = value.listWithArg;
  var listWithArg = value$1 !== undefined ? value$1.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          listWithArg: listWithArg
        };
}

function verifyName$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var FragmentWithArgs = {
  Raw: Raw$2,
  query: query$1,
  parse: parse$2,
  verifyArgsAndParse: verifyArgsAndParse$2,
  serialize: serialize$2,
  verifyName: verifyName$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$2 = \\"fragment InlineListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$3(value) {
  var value$1 = value.nullableOfNullable;
  var value$2 = value.nullableOfNonNullable;
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined,
          nullableOfNonNullable: !(value$2 == null) ? value$2.map((function (value) {
                    return value;
                  })) : undefined
        };
}

function verifyArgsAndParse$3(_InlineListFragment, value) {
  return parse$3(value);
}

function serialize$3(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName$3(param) {
  
}

var Z__INTERNAL$3 = {
  graphql: 0,
  graphql_module: 0
};

var InlineListFragment = {
  Raw: Raw$3,
  query: query$2,
  parse: parse$3,
  verifyArgsAndParse: verifyArgsAndParse$3,
  serialize: serialize$3,
  verifyName: verifyName$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var Raw$4 = { };

var query$3 = \\"query MyQuery($arg1: String)  {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...InlineListFragment   \\\\n}\\\\n\\\\nl5: lists  {\\\\n...FragmentWithArgs   \\\\n}\\\\n\\\\n}\\\\nfragment FragmentWithArgs on Lists   {\\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\nfragment InlineListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$4(value) {
  var value$1 = value.l2;
  var value$2 = value.l3;
  var value$3 = value$2[\\"nullableOfNullable\\"];
  var value$4 = value.l4;
  var value$5 = value$4[\\"nullableOfNullable\\"];
  return {
          l1: parse(value.l1),
          l2: {
            frag1: parse(value$1),
            frag2: parse(value$1)
          },
          l3: {
            nullableOfNullable: !(value$3 == null) ? value$3.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            frag1: parse(value$2),
            frag2: parse(value$2)
          },
          l4: {
            nullableOfNullable: !(value$5 == null) ? value$5.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            inlineListFragment: parse$3(value$4)
          },
          l5: parse$2(value.l5)
        };
}

function serialize$4(value) {
  var value$1 = value.l5;
  var l5 = serialize$2(value$1);
  var value$2 = value.l4;
  var value$3 = value$2.nullableOfNullable;
  var l4 = [serialize$3(value$2.inlineListFragment)].reduce(deepMerge, {
        nullableOfNullable: value$3 !== undefined ? value$3.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$4 = value.l3;
  var value$5 = value$4.nullableOfNullable;
  var l3 = [
      serialize(value$4.frag1),
      serialize(value$4.frag2)
    ].reduce(deepMerge, {
        nullableOfNullable: value$5 !== undefined ? value$5.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$6 = value.l2;
  var l2 = [
      serialize(value$6.frag1),
      serialize(value$6.frag2)
    ].reduce(deepMerge, (function (prim) {
          return { };
        }));
  var value$7 = value.l1;
  var l1 = serialize(value$7);
  return {
          l1: l1,
          l2: l2,
          l3: l3,
          l4: l4,
          l5: l5
        };
}

function serializeVariables(inp) {
  var a = inp.arg1;
  return {
          arg1: a !== undefined ? a : undefined
        };
}

function makeVariables(arg1, param) {
  return serializeVariables({
              arg1: arg1
            });
}

function makeDefaultVariables(param) {
  return serializeVariables({
              arg1: undefined
            });
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw$4,
  query: query$3,
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$4 = \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";

function parse$5(value) {
  return {
          lists: parse(value.lists)
        };
}

function serialize$5(value) {
  var value$1 = value.lists;
  var lists = serialize(value$1);
  return {
          lists: lists
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$5 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$5,
  query: query$4,
  parse: parse$5,
  serialize: serialize$5,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$5
};

exports.GraphQL_PPX = GraphQL_PPX;
exports.ListFragment = ListFragment;
exports.Another = Another;
exports.FragmentWithArgs = FragmentWithArgs;
exports.InlineListFragment = InlineListFragment;
exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Records) fragmentInFragment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function deepMerge(json1, param) {
  return json1;
}

var GraphQL_PPX = {
  deepMerge: deepMerge
};

var Raw = { };

var query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\n}\\\\n\\";

function parse(value) {
  var value$1 = value.nullableOfNullable;
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined
        };
}

function verifyArgsAndParse(_ListFragment, value) {
  return parse(value);
}

function serialize(value) {
  var value$1 = value.nullableOfNullable;
  var nullableOfNullable = value$1 !== undefined ? value$1.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  Raw: Raw,
  query: query,
  parse: parse,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = \\"fragment Another on Lists   {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\nfragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\n}\\\\n\\";

function parse$1(value) {
  var value$1 = value[\\"nullableOfNullable\\"];
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined,
          listFragment: parse(value)
        };
}

function verifyArgsAndParse$1(_Another, value) {
  return parse$1(value);
}

function serialize$1(value) {
  var value$1 = value.nullableOfNullable;
  return [serialize(value.listFragment)].reduce(deepMerge, {
              nullableOfNullable: value$1 !== undefined ? value$1.map((function (value) {
                        if (value !== undefined) {
                          return value;
                        } else {
                          return null;
                        }
                      })) : null
            });
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$1,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.GraphQL_PPX = GraphQL_PPX;
exports.ListFragment = ListFragment;
exports.Another = Another;
/* No side effect */
"
`;

exports[`Compilation (Records) interface.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
"
`;

exports[`Compilation (Records) lists.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) listsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  var value$1 = value.listsInput;
  return {
          listsInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.nullableOfNullable;
  var a$1 = inp.nullableOfNonNullable;
  var a$2 = inp.nonNullableOfNullable;
  var a$3 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          nullableOfNonNullable: a$1 !== undefined ? $$Array.map((function (b) {
                    return b;
                  }), a$1) : undefined,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$2),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$3)
        };
}

function makeVariables(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return serializeVariables({
              nullableOfNullable: nullableOfNullable,
              nullableOfNonNullable: nullableOfNonNullable,
              nonNullableOfNullable: nonNullableOfNullable,
              nonNullableOfNonNullable: nonNullableOfNonNullable
            });
}

var Z__INTERNAL = {
  _graphql_arg_219: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) listsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  var value$1 = value.listsInput;
  return {
          listsInput: value$1
        };
}

function serializeInputObjectListsInput(inp) {
  var a = inp.nullableOfNullable;
  var a$1 = inp.nullableOfNonNullable;
  var a$2 = inp.nonNullableOfNullable;
  var a$3 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          nullableOfNonNullable: a$1 !== undefined ? $$Array.map((function (b) {
                    return b;
                  }), a$1) : undefined,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$2),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$3)
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectListsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectListsInput(arg)
        };
}

function makeInputObjectListsInput(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable,
          nonNullableOfNullable: nonNullableOfNullable,
          nonNullableOfNonNullable: nonNullableOfNonNullable
        };
}

var Z__INTERNAL = {
  _graphql_arg_82: 0,
  _graphql_arg_77: 0,
  _graphql_ListsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectListsInput: serializeInputObjectListsInput,
  makeVariables: makeVariables,
  makeInputObjectListsInput: makeInputObjectListsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) mutation.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.value;
  var value$3 = value$1.errors;
  return {
          mutationWithError: {
            value: !(value$2 == null) ? ({
                  stringField: value$2.stringField
                }) : undefined,
            errors: !(value$3 == null) ? value$3.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          tmp = /* \`FutureAddedValue */[
                            -31101740,
                            value$1
                          ];
                      }
                      return {
                              field: tmp,
                              message: value.message
                            };
                    })) : undefined
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.message;
            var value$2 = value.field;
            var field = typeof value$2 === \\"number\\" ? (
                value$2 !== 225952583 ? (
                    value$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$2[1];
            return {
                    field: field,
                    message: value$1
                  };
          })) : null;
  var value$3 = value$1.value;
  var value$4;
  if (value$3 !== undefined) {
    var value$5 = value$3.stringField;
    value$4 = {
      stringField: value$5
    };
  } else {
    value$4 = null;
  }
  var mutationWithError = {
    value: value$4,
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) mutationWithArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  var value$1 = value.optionalInputArgs;
  return {
          optionalInputArgs: value$1
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return {
          required: required
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) mutationWithArgsAndNoRecords.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return serializeVariables({
              required: required
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) nested.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var tmp;
  if (value$2 == null) {
    tmp = undefined;
  } else {
    var value$3 = value$2.inner;
    tmp = {
      inner: !(value$3 == null) ? ({
            field: value$3.field
          }) : undefined
    };
  }
  var value$4 = value.second;
  var value$5 = value$4.inner;
  var tmp$1;
  if (value$5 == null) {
    tmp$1 = undefined;
  } else {
    var value$6 = value$5.inner;
    tmp$1 = {
      inner: !(value$6 == null) ? ({
            f1: value$6.f1,
            f2: value$6.f2
          }) : undefined
    };
  }
  var value$7 = value.let_;
  var value$8 = value$7.inner;
  var tmp$2;
  if (value$8 == null) {
    tmp$2 = undefined;
  } else {
    var value$9 = value$8.inner;
    tmp$2 = {
      inner: !(value$9 == null) ? ({
            field: value$9.field
          }) : undefined
    };
  }
  return {
          first: {
            inner: tmp
          },
          second: {
            inner: tmp$1
          },
          let_: {
            inner: tmp$2
          }
        };
}

function serialize(value) {
  var value$1 = value.let_;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = value$2.inner;
    var inner$1;
    if (value$3 !== undefined) {
      var value$4 = value$3.field;
      inner$1 = {
        field: value$4
      };
    } else {
      inner$1 = null;
    }
    inner = {
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var let_ = {
    inner: inner
  };
  var value$5 = value.second;
  var value$6 = value$5.inner;
  var inner$2;
  if (value$6 !== undefined) {
    var value$7 = value$6.inner;
    var inner$3;
    if (value$7 !== undefined) {
      var value$8 = value$7.f2;
      var value$9 = value$7.f1;
      inner$3 = {
        f1: value$9,
        f2: value$8
      };
    } else {
      inner$3 = null;
    }
    inner$2 = {
      inner: inner$3
    };
  } else {
    inner$2 = null;
  }
  var second = {
    inner: inner$2
  };
  var value$10 = value.first;
  var value$11 = value$10.inner;
  var inner$4;
  if (value$11 !== undefined) {
    var value$12 = value$11.inner;
    var inner$5;
    if (value$12 !== undefined) {
      var value$13 = value$12.field;
      inner$5 = {
        field: value$13
      };
    } else {
      inner$5 = null;
    }
    inner$4 = {
      inner: inner$5
    };
  } else {
    inner$4 = null;
  }
  var first = {
    inner: inner$4
  };
  return {
          first: first,
          second: second,
          let_: let_
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) nonrecursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  var value$1 = value.nonrecursiveInput;
  return {
          nonrecursiveInput: value$1
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput(b);
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectNonrecursiveInput(arg)
        };
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_arg_100: 0,
  _graphql_arg_95: 0,
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  return {
          scalarsInput: value.scalarsInput,
          more: value.more
        };
}

function serialize$1(value) {
  var value$1 = value.more;
  var value$2 = value.scalarsInput;
  return {
          scalarsInput: value$2,
          more: value$1
        };
}

function serializeInputObjectEmbeddedInput$1(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput$1(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput$1(b);
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables$1(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput$1(inp.arg),
          arg2: serializeInputObjectNonrecursiveInput$1(inp.arg2)
        };
}

function makeVariables$1(arg, arg2, param) {
  return serializeVariables$1({
              arg: arg,
              arg2: arg2
            });
}

function makeInputObjectNonrecursiveInput$1(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput$1(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL$1 = {
  _graphql_arg_240: 0,
  _graphql_arg_235: 0,
  _graphql_NonrecursiveInput_169: 0,
  _graphql_NonrecursiveInput_196: 0,
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$1,
  query: \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput$1,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput$1,
  makeVariables: makeVariables$1,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput$1,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* No side effect */
"
`;

exports[`Compilation (Records) omitFutureValueEnum.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: !(value$2 == null) ? value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          tmp = /* \`FutureAddedValue */[
                            -31101740,
                            value$1
                          ];
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    })) : undefined
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = typeof value$1 === \\"number\\" ? (
                value$1 !== 225952583 ? (
                    value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$1[1];
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: !(value$2 == null) ? value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          throw Caml_builtin_exceptions.not_found;
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    })) : undefined
          }
        };
}

function serialize$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: !(value$2 == null) ? value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          throw Caml_builtin_exceptions.not_found;
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    })) : undefined
          }
        };
}

function serialize$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Records) omitFutureValueUnion.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    dogOrHuman = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    dogOrHuman = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* No side effect */
"
`;

exports[`Compilation (Records) pokedexApolloMode.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    tmp = {
      id: value$1.id,
      name: !(value$2 == null) ? value$2 : undefined
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var pokemon;
  if (value$1 !== undefined) {
    var value$2 = value$1.name;
    var name = value$2 !== undefined ? value$2 : null;
    var value$3 = value$1.id;
    pokemon = {
      id: value$3,
      name: name
    };
  } else {
    pokemon = null;
  }
  return {
          pokemon: pokemon
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  _graphql_name_52: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) pokedexScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    tmp = {
      id: value$1.id,
      name: !(value$2 == null) ? value$2 : undefined
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var pokemon;
  if (value$1 !== undefined) {
    var value$2 = value$1.name;
    var name = value$2 !== undefined ? value$2 : null;
    var value$3 = value$1.id;
    pokemon = {
      id: value$3,
      name: name
    };
  } else {
    pokemon = null;
  }
  return {
          pokemon: pokemon
        };
}

function serializeVariables(inp) {
  var a = inp.id;
  var a$1 = inp.name;
  return {
          id: a !== undefined ? a : undefined,
          name: a$1 !== undefined ? a$1 : undefined
        };
}

function makeVariables(id, name, param) {
  return serializeVariables({
              id: id,
              name: name
            });
}

function makeDefaultVariables(param) {
  return serializeVariables({
              id: undefined,
              name: undefined
            });
}

var Z__INTERNAL = {
  _graphql_pokemon_name_100: 0,
  _graphql_name_94: 0,
  _graphql_pokemon_id_111: 0,
  _graphql_id_107: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: {
            string: value$1.string,
            int: value$1.int
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var value$3 = value$1.string;
  var variousScalars = {
    string: value$3,
    int: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var nullableString = value$2 !== undefined ? value$2 : null;
  var variousScalars = {
    nullableString: nullableString
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var OneFieldQuery = {
  Raw: Raw$1,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

function parse$2(value) {
  return {
          string: value.string,
          int: value.int
        };
}

function verifyArgsAndParse(_Fragment, value) {
  return parse$2(value);
}

function serialize$2(value) {
  var value$1 = value.int;
  var value$2 = value.string;
  return {
          string: value$2,
          int: value$1
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var Fragment = {
  Raw: Raw$2,
  query: query,
  parse: parse$2,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize$2,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$1 = \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\nfragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";

function parse$3(value) {
  return {
          variousScalars: parse$2(value.variousScalars)
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var variousScalars = serialize$2(value$1);
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var Untitled1 = {
  Raw: Raw$3,
  query: query$1,
  parse: parse$3,
  serialize: serialize$3,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$3
};

var ExternalFragmentQuery = {
  Fragment: Fragment,
  Untitled1: Untitled1
};

var Raw$4 = { };

function parse$4(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      {
        name: value$1.name,
        barkVolume: value$1.barkVolume
      }
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$4(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$3(param) {
  
}

function makeVariables$3(param) {
  
}

function makeDefaultVariables$3(param) {
  
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var InlineFragmentQuery = {
  Raw: Raw$4,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables$3,
  makeVariables: makeVariables$3,
  makeDefaultVariables: makeDefaultVariables$3,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$2 = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

function parse$5(value) {
  return {
          name: value.name,
          barkVolume: value.barkVolume
        };
}

function verifyArgsAndParse$1(_DogFragment, value) {
  return parse$5(value);
}

function serialize$5(value) {
  var value$1 = value.barkVolume;
  var value$2 = value.name;
  return {
          name: value$2,
          barkVolume: value$1
        };
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$5 = {
  graphql: 0,
  graphql_module: 0
};

var DogFragment = {
  Raw: Raw$5,
  query: query$2,
  parse: parse$5,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$5,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$5
};

var Raw$6 = { };

var query$3 = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\nfragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";

function parse$6(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      parse$5(value$1)
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$6(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman = value$1[0] >= 3406428 ? serialize$5(value$1[1]) : value$1[1];
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$4(param) {
  
}

function makeVariables$4(param) {
  
}

function makeDefaultVariables$4(param) {
  
}

var Z__INTERNAL$6 = {
  graphql_module: 0
};

var Untitled1$1 = {
  Raw: Raw$6,
  query: query$3,
  parse: parse$6,
  serialize: serialize$6,
  serializeVariables: serializeVariables$4,
  makeVariables: makeVariables$4,
  makeDefaultVariables: makeDefaultVariables$4,
  Z__INTERNAL: Z__INTERNAL$6
};

var UnionExternalFragmentQuery = {
  DogFragment: DogFragment,
  Untitled1: Untitled1$1
};

exports.MyQuery = MyQuery;
exports.OneFieldQuery = OneFieldQuery;
exports.ExternalFragmentQuery = ExternalFragmentQuery;
exports.InlineFragmentQuery = InlineFragmentQuery;
exports.UnionExternalFragmentQuery = UnionExternalFragmentQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) recursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          recursiveInput: value.recursiveInput
        };
}

function serialize(value) {
  var value$1 = value.recursiveInput;
  return {
          recursiveInput: value$1
        };
}

function serializeInputObjectRecursiveInput(inp) {
  var a = inp.otherField;
  var a$1 = inp.inner;
  var a$2 = inp.enum;
  return {
          otherField: a !== undefined ? a : undefined,
          inner: a$1 !== undefined ? serializeInputObjectRecursiveInput(a$1) : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectRecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectRecursiveInput(arg)
        };
}

function makeInputObjectRecursiveInput(otherField, inner, $$enum, param) {
  return {
          otherField: otherField,
          inner: inner,
          enum: $$enum
        };
}

var Z__INTERNAL = {
  _graphql_arg_90: 0,
  _graphql_arg_85: 0,
  _graphql_RecursiveInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectRecursiveInput: serializeInputObjectRecursiveInput,
  makeVariables: makeVariables,
  makeInputObjectRecursiveInput: makeInputObjectRecursiveInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) scalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) scalarsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  var value$1 = value.scalarsInput;
  return {
          scalarsInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function makeVariables(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return serializeVariables({
              nullableString: nullableString,
              string: string,
              nullableInt: nullableInt,
              int: $$int,
              nullableFloat: nullableFloat,
              float: $$float,
              nullableBoolean: nullableBoolean,
              boolean: $$boolean,
              nullableID: nullableID,
              id: id
            });
}

var Z__INTERNAL = {
  _graphql_arg_292: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) scalarsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  var value$1 = value.scalarsInput;
  return {
          scalarsInput: value$1
        };
}

function serializeInputObjectVariousScalarsInput(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectVariousScalarsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectVariousScalarsInput(arg)
        };
}

function makeInputObjectVariousScalarsInput(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return {
          nullableString: nullableString,
          string: string,
          nullableInt: nullableInt,
          int: $$int,
          nullableFloat: nullableFloat,
          float: $$float,
          nullableBoolean: nullableBoolean,
          boolean: $$boolean,
          nullableID: nullableID,
          id: id
        };
}

var Z__INTERNAL = {
  _graphql_arg_93: 0,
  _graphql_arg_88: 0,
  _graphql_VariousScalarsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectVariousScalarsInput: serializeInputObjectVariousScalarsInput,
  makeVariables: makeVariables,
  makeInputObjectVariousScalarsInput: makeInputObjectVariousScalarsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) skipDirectives.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.v1;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.string;
  var value$4 = value.v2;
  var value$5 = value$4.nullableString;
  var value$6 = value$4.string;
  return {
          v1: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: !(value$3 == null) ? value$3 : undefined
          },
          v2: {
            nullableString: !(value$5 == null) ? value$5 : undefined,
            string: !(value$6 == null) ? value$6 : undefined
          }
        };
}

function serialize(value) {
  var value$1 = value.v2;
  var value$2 = value$1.string;
  var string = value$2 !== undefined ? value$2 : null;
  var value$3 = value$1.nullableString;
  var nullableString = value$3 !== undefined ? value$3 : null;
  var v2 = {
    nullableString: nullableString,
    string: string
  };
  var value$4 = value.v1;
  var value$5 = value$4.string;
  var string$1 = value$5 !== undefined ? value$5 : null;
  var value$6 = value$4.nullableString;
  var nullableString$1 = value$6 !== undefined ? value$6 : null;
  var v1 = {
    nullableString: nullableString$1,
    string: string$1
  };
  return {
          v1: v1,
          v2: v2
        };
}

function serializeVariables(inp) {
  return {
          var: inp.var
        };
}

function makeVariables($$var, param) {
  return {
          var: $$var
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) subscription.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.simpleSubscription;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          simpleSubscription: tmp
        };
}

function serialize(value) {
  var value$1 = value.simpleSubscription;
  var variant = value$1[0];
  var simpleSubscription;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      simpleSubscription = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      simpleSubscription = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    simpleSubscription = value$1[1];
  }
  return {
          simpleSubscription: simpleSubscription
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) tagged_template.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var MyTypes = { };

var Raw$1 = { };

var query$1 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQuery1a = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var MyQuery1b = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$3 = (require(\\"gatsby\\").graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$3(param) {
  
}

function makeVariables$3(param) {
  
}

function makeDefaultVariables$3(param) {
  
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$3,
  query: query$3,
  parse: parse$3,
  serialize: serialize$3,
  serializeVariables: serializeVariables$3,
  makeVariables: makeVariables$3,
  makeDefaultVariables: makeDefaultVariables$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var Raw$4 = { };

var query$4 = (require(\\"gatsby\\").graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$4(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$4(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$4(param) {
  
}

function makeVariables$4(param) {
  
}

function makeDefaultVariables$4(param) {
  
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var MyQuery3 = {
  Raw: Raw$4,
  query: query$4,
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables$4,
  makeVariables: makeVariables$4,
  makeDefaultVariables: makeDefaultVariables$4,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$5 = (require(\\"gatsby\\")\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$5(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$5(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$5(param) {
  
}

function makeVariables$5(param) {
  
}

function makeDefaultVariables$5(param) {
  
}

var Z__INTERNAL$5 = {
  graphql_module: 0
};

var MyQuery4 = {
  Raw: Raw$5,
  query: query$5,
  parse: parse$5,
  serialize: serialize$5,
  serializeVariables: serializeVariables$5,
  makeVariables: makeVariables$5,
  makeDefaultVariables: makeDefaultVariables$5,
  Z__INTERNAL: Z__INTERNAL$5
};

exports.MyQuery = MyQuery;
exports.MyTypes = MyTypes;
exports.MyQuery1a = MyQuery1a;
exports.MyQuery1b = MyQuery1b;
exports.MyQuery2 = MyQuery2;
exports.MyQuery3 = MyQuery3;
exports.MyQuery4 = MyQuery4;
/* query Not a pure module */
"
`;

exports[`Compilation (Records) typename.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var tmp;
  if (value$2 == null) {
    tmp = undefined;
  } else {
    var value$3 = value$2.inner;
    tmp = {
      __typename: value$2.__typename,
      inner: !(value$3 == null) ? ({
            __typename: value$3.__typename,
            field: value$3.field
          }) : undefined
    };
  }
  return {
          first: {
            __typename: value$1.__typename,
            inner: tmp
          }
        };
}

function serialize(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = value$2.inner;
    var inner$1;
    if (value$3 !== undefined) {
      var value$4 = value$3.field;
      var value$5 = value$3.__typename;
      inner$1 = {
        __typename: value$5,
        field: value$4
      };
    } else {
      inner$1 = null;
    }
    var value$6 = value$2.__typename;
    inner = {
      __typename: value$6,
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var value$7 = value$1.__typename;
  var first = {
    __typename: value$7,
    inner: inner
  };
  return {
          first: first
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) union.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQueryNoError = {
  Raw: Raw$1,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var NamedQuery = {
  Raw: Raw$2,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.MyQuery = MyQuery;
exports.MyQueryNoError = MyQueryNoError;
exports.NamedQuery = NamedQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) unionPartial.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      {
        name: value$1.name,
        barkVolume: value$1.barkVolume
      }
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Records) variant.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require(\\"bs-platform/lib/js/js_exn.js\\");
var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

function parse(value) {
  var value$1 = value.mutationForVariant;
  var value$2 = Js_json.decodeObject(value$1);
  var tmp;
  if (value$2 !== undefined) {
    var value$3 = Caml_option.valFromOption(value$2);
    var temp = value$3[\\"baseType\\"];
    var match = Js_json.decodeNull(temp);
    if (match !== undefined) {
      var temp$1 = value$3[\\"baseTypeList\\"];
      var match$1 = Js_json.decodeNull(temp$1);
      if (match$1 !== undefined) {
        var temp$2 = value$3[\\"dog\\"];
        var match$2 = Js_json.decodeNull(temp$2);
        if (match$2 !== undefined) {
          var temp$3 = value$3[\\"human\\"];
          var match$3 = Js_json.decodeNull(temp$3);
          if (match$3 !== undefined) {
            var temp$4 = value$3[\\"dogOrHuman\\"];
            var match$4 = Js_json.decodeNull(temp$4);
            if (match$4 !== undefined) {
              tmp = Js_exn.raiseError(\\"graphql-ppx: All fields on variant selection set on type VariantTestResult were null\\");
            } else {
              var typename = temp$4[\\"__typename\\"];
              var tmp$1;
              switch (typename) {
                case \\"Dog\\" :
                    tmp$1 = /* \`Dog */[
                      3406428,
                      {
                        name: temp$4.name,
                        barkVolume: temp$4.barkVolume
                      }
                    ];
                    break;
                case \\"Human\\" :
                    tmp$1 = /* \`Human */[
                      -1031617139,
                      {
                        name: temp$4.name
                      }
                    ];
                    break;
                default:
                  tmp$1 = /* \`FutureAddedValue */[
                    -31101740,
                    temp$4
                  ];
              }
              tmp = /* \`DogOrHuman */[
                974247566,
                tmp$1
              ];
            }
          } else {
            tmp = /* \`Human */[
              -1031617139,
              {
                name: temp$3.name
              }
            ];
          }
        } else {
          tmp = /* \`Dog */[
            3406428,
            {
              name: temp$2.name,
              barkVolume: temp$2.barkVolume
            }
          ];
        }
      } else {
        tmp = /* \`BaseTypeList */[
          -259847799,
          temp$1.map((function (value) {
                  return value;
                }))
        ];
      }
    } else {
      tmp = /* \`BaseType */[
        -620191861,
        temp
      ];
    }
  } else {
    tmp = Js_exn.raiseError(\\"graphql-ppx: Expected type VariantTestResult to be an object\\");
  }
  return {
          mutationForVariant: tmp
        };
}

function serialize(value) {
  var mutationForVariant = null;
  return {
          mutationForVariant: mutationForVariant
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\",
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* No side effect */
"
`;

exports[`Compilation (Template) argNamedQuery.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query ($query: Int!)  {
    argNamedQuery(query: $query)
  }
\`);

function parse(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize(value) {
  var value$1 = value.argNamedQuery;
  return {
          argNamedQuery: value$1
        };
}

function serializeVariables(inp) {
  return {
          query: inp.query
        };
}

function makeVariables(query, param) {
  return {
          query: query
        };
}

var Z__INTERNAL = {
  _graphql_query_82: 0,
  _graphql_query_75: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query Query1($query: Int!)  {
    argNamedQuery(query: $query)
  }
\`);

function parse$1(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize$1(value) {
  var value$1 = value.argNamedQuery;
  return {
          argNamedQuery: value$1
        };
}

function serializeVariables$1(inp) {
  return {
          query: inp.query
        };
}

function makeVariables$1(query, param) {
  return {
          query: query
        };
}

var Z__INTERNAL$1 = {
  _graphql_Query1_query_210: 0,
  _graphql_Query2_query_210: 0,
  _graphql_query_203: 0,
  graphql_module: 0
};

var Query1 = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (require(\\"gql\\")\`
  query Query2($query: Int!)  {
    argNamedQuery(query: $query)
  }
\`);

function parse$2(value) {
  return {
          argNamedQuery: value.argNamedQuery
        };
}

function serialize$2(value) {
  var value$1 = value.argNamedQuery;
  return {
          argNamedQuery: value$1
        };
}

function serializeVariables$2(inp) {
  return {
          query: inp.query
        };
}

function makeVariables$2(query, param) {
  return {
          query: query
        };
}

var Z__INTERNAL$2 = {
  _graphql_Query1_query_278: 0,
  _graphql_Query2_query_278: 0,
  _graphql_query_271: 0,
  graphql_module: 0
};

var Query2 = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var MultipleQueryWithSameVarName = {
  Query1: Query1,
  Query2: Query2
};

exports.MyQuery = MyQuery;
exports.MultipleQueryWithSameVarName = MultipleQueryWithSameVarName;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) comment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  query ($arg: NonrecursiveInput!)  {
    nonrecursiveInput(arg: $arg)
  }
\`);

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  var value$1 = value.nonrecursiveInput;
  return {
          nonrecursiveInput: value$1
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput(b);
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectNonrecursiveInput(arg)
        };
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_arg_100: 0,
  _graphql_arg_95: 0,
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) customDecoder.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_format = require(\\"bs-platform/lib/js/caml_format.js\\");

function parse(prim) {
  return String(prim);
}

var serialize = Caml_format.caml_int_of_string;

var StringOfInt = {
  parse: parse,
  serialize: serialize
};

var parse$1 = Caml_format.caml_int_of_string;

function serialize$1(prim) {
  return String(prim);
}

var IntOfString = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    variousScalars  {
      string
      int
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: {
            string: Caml_format.caml_int_of_string(value$1.string),
            int: String(value$1.int)
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var $$int = Caml_format.caml_int_of_string(value$2);
  var value$3 = value$1.string;
  var string = String(value$3);
  var variousScalars = {
    string: string,
    int: $$int
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.StringOfInt = StringOfInt;
exports.IntOfString = IntOfString;
exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) customScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  query ($opt: CustomScalar, $req: CustomScalar!)  {
    customScalarField(argOptional: $opt, argRequired: $req)  {
      nullable
      nonNullable
    }
  }
\`);

function parse(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nullable;
  return {
          customScalarField: {
            nullable: !(value$2 == null) ? Caml_option.some(value$2) : undefined,
            nonNullable: value$1.nonNullable
          }
        };
}

function serialize(value) {
  var value$1 = value.customScalarField;
  var value$2 = value$1.nonNullable;
  var value$3 = value$1.nullable;
  var nullable = value$3 !== undefined ? Caml_option.valFromOption(value$3) : null;
  var customScalarField = {
    nullable: nullable,
    nonNullable: value$2
  };
  return {
          customScalarField: customScalarField
        };
}

function serializeVariables(inp) {
  var a = inp.opt;
  return {
          opt: a !== undefined ? Caml_option.valFromOption(a) : undefined,
          req: inp.req
        };
}

function makeVariables(opt, req, param) {
  return serializeVariables({
              opt: opt,
              req: req
            });
}

var Z__INTERNAL = {
  _graphql_opt_119: 0,
  _graphql_argOptional_106: 0,
  _graphql_req_138: 0,
  _graphql_argRequired_125: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) customTypes.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

function parse(json) {
  var match = Js_json.decodeString(json);
  if (match === undefined) {
    return /* Red */0;
  }
  switch (match) {
    case \\"blue\\" :
        return /* Blue */2;
    case \\"green\\" :
        return /* Green */1;
    case \\"red\\" :
        return /* Red */0;
    default:
      return /* Red */0;
  }
}

function serialize(color) {
  switch (color) {
    case /* Red */0 :
        return \\"red\\";
    case /* Green */1 :
        return \\"green\\";
    case /* Blue */2 :
        return \\"blue\\";
    
  }
}

var Color = {
  parse: parse,
  serialize: serialize
};

function parse$1(json) {
  var str = Js_json.decodeString(json);
  if (str !== undefined) {
    return new Date(str);
  } else {
    return new Date();
  }
}

function serialize$1(date) {
  return date.toISOString();
}

var DateTime = {
  parse: parse$1,
  serialize: serialize$1
};

var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    customFields  {
      currentTime
      favoriteColor
      futureTime
      nullableColor
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.futureTime;
  var value$3 = value$1.nullableColor;
  return {
          customFields: {
            currentTime: parse$1(value$1.currentTime),
            favoriteColor: parse(value$1.favoriteColor),
            futureTime: !(value$2 == null) ? Caml_option.some(parse$1(value$2)) : undefined,
            nullableColor: !(value$3 == null) ? parse(value$3) : undefined
          }
        };
}

function serialize$2(value) {
  var value$1 = value.customFields;
  var value$2 = value$1.nullableColor;
  var nullableColor = value$2 !== undefined ? serialize(value$2) : null;
  var value$3 = value$1.futureTime;
  var futureTime = value$3 !== undefined ? Caml_option.valFromOption(value$3).toISOString() : null;
  var value$4 = value$1.favoriteColor;
  var favoriteColor = serialize(value$4);
  var value$5 = value$1.currentTime;
  var currentTime = value$5.toISOString();
  var customFields = {
    currentTime: currentTime,
    favoriteColor: favoriteColor,
    futureTime: futureTime,
    nullableColor: nullableColor
  };
  return {
          customFields: customFields
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.Color = Color;
exports.DateTime = DateTime;
exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) defaultObjectValueOnScalar.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
  defaultObjectValueOnScalar(filter: {some: {json: \\"value\\"}}, arg: {field: \\"otherValue\\"})
  }
\`);

function parse(value) {
  return {
          defaultObjectValueOnScalar: value.defaultObjectValueOnScalar
        };
}

function serialize(value) {
  var value$1 = value.defaultObjectValueOnScalar;
  return {
          defaultObjectValueOnScalar: value$1
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  _graphql_filter_92: 0,
  _graphql_arg_140: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) enumInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query ($arg: SampleField!)  {
    enumInput(arg: $arg)
  }
\`);

function parse(value) {
  return {
          enumInput: value.enumInput
        };
}

function serialize(value) {
  var value$1 = value.enumInput;
  return {
          enumInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.arg;
  return {
          arg: a !== 225952583 ? (
              a >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
            ) : \\"THIRD\\"
        };
}

function makeVariables(arg, param) {
  return serializeVariables({
              arg: arg
            });
}

var Z__INTERNAL = {
  _graphql_arg_82: 0,
  _graphql_arg_77: 0,
  _graphql_SampleField_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) explicit_object_record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    lists  {
      nullableOfNullable
      nullableOfNonNullable
      nonNullableOfNullable
      nonNullableOfNonNullable
    }
  }
\`);

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var RecordsQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query   {
    lists  {
      nullableOfNullable
      nullableOfNonNullable
      nonNullableOfNullable
      nonNullableOfNonNullable
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (!(value == null)) {
            return value;
          }
          
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = !(value$4 == null) ? value$4.map((function (value) {
            return value;
          })) : undefined;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = !(value$5 == null) ? value$5.map((function (value) {
            if (!(value == null)) {
              return value;
            }
            
          })) : undefined;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          lists: {
            nullableOfNullable: nullableOfNullable,
            nullableOfNonNullable: nullableOfNonNullable,
            nonNullableOfNullable: nonNullableOfNullable,
            nonNullableOfNonNullable: nonNullableOfNonNullable
          }
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ObjectsQuery = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.RecordsQuery = RecordsQuery;
exports.ObjectsQuery = ObjectsQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) extensions.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function ExtendQuery(M) {
  var use = function (param) {
    
  };
  return {
          use: use
        };
}

var Parent = {
  ExtendQuery: ExtendQuery
};

var Raw = { };

var query = (require(\\"gql\\")\`
  query Bla  {
    lists  {
      nullableOfNullable
      nullableOfNonNullable
      nonNullableOfNullable
      nonNullableOfNonNullable
    }
  }
\`);

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Inner = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

function use(param) {
  
}

var Bla = {
  Inner: Inner,
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL,
  use: use
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query Bla2  {
    lists  {
      nullableOfNullable
      nullableOfNonNullable
      nonNullableOfNullable
      nonNullableOfNonNullable
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize$1(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var Inner$1 = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

function use$1(param) {
  
}

exports.Parent = Parent;
exports.Bla = Bla;
exports.Inner = Inner$1;
exports.Raw = Raw$1;
exports.query = query$1;
exports.parse = parse$1;
exports.serialize = serialize$1;
exports.serializeVariables = serializeVariables$1;
exports.makeVariables = makeVariables$1;
exports.makeDefaultVariables = makeDefaultVariables$1;
exports.Z__INTERNAL = Z__INTERNAL$1;
exports.use = use$1;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) fragmentDefinition.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function deepMerge(json1, param) {
  return json1;
}

var GraphQL_PPX = {
  deepMerge: deepMerge
};

var Raw = { };

var query = (require(\\"gql\\")\`
  fragment ListFragment on Lists   {
    nullableOfNullable
    nullableOfNonNullable
  }
\`);

function parse(value) {
  var value$1 = value.nullableOfNullable;
  var value$2 = value.nullableOfNonNullable;
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined,
          nullableOfNonNullable: !(value$2 == null) ? value$2.map((function (value) {
                    return value;
                  })) : undefined
        };
}

function verifyArgsAndParse(_ListFragment, value) {
  return parse(value);
}

function serialize(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  Raw: Raw,
  query: query,
  parse: parse,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  fragment Another on Lists   {
    nullableOfNonNullable
  }
\`);

function parse$1(value) {
  var value$1 = value.nullableOfNonNullable;
  return {
          nullableOfNonNullable: !(value$1 == null) ? value$1.map((function (value) {
                    return value;
                  })) : undefined
        };
}

function verifyArgsAndParse$1(_Another, value) {
  return parse$1(value);
}

function serialize$1(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  return {
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$1,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (require(\\"gql\\")\`
  fragment FragmentWithArgs on Lists   {
    listWithArg(arg1: $arg1)
  }
\`);

function parse$2(value) {
  var value$1 = value.listWithArg;
  return {
          listWithArg: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined
        };
}

function verifyArgsAndParse$2(_arg1, _FragmentWithArgs, value) {
  return parse$2(value);
}

function serialize$2(value) {
  var value$1 = value.listWithArg;
  var listWithArg = value$1 !== undefined ? value$1.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          listWithArg: listWithArg
        };
}

function verifyName$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var FragmentWithArgs = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  verifyArgsAndParse: verifyArgsAndParse$2,
  serialize: serialize$2,
  verifyName: verifyName$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$3 = (require(\\"gql\\")\`
  fragment InlineListFragment on Lists   {
    nullableOfNullable
    nullableOfNonNullable
  }
\`);

function parse$3(value) {
  var value$1 = value.nullableOfNullable;
  var value$2 = value.nullableOfNonNullable;
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined,
          nullableOfNonNullable: !(value$2 == null) ? value$2.map((function (value) {
                    return value;
                  })) : undefined
        };
}

function verifyArgsAndParse$3(_InlineListFragment, value) {
  return parse$3(value);
}

function serialize$3(value) {
  var value$1 = value.nullableOfNonNullable;
  var nullableOfNonNullable = value$1 !== undefined ? value$1.map((function (value) {
            return value;
          })) : null;
  var value$2 = value.nullableOfNullable;
  var nullableOfNullable = value$2 !== undefined ? value$2.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable
        };
}

function verifyName$3(param) {
  
}

var Z__INTERNAL$3 = {
  graphql: 0,
  graphql_module: 0
};

var InlineListFragment = {
  Raw: Raw$3,
  query: query$3,
  parse: parse$3,
  verifyArgsAndParse: verifyArgsAndParse$3,
  serialize: serialize$3,
  verifyName: verifyName$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var Raw$4 = { };

var query$4 = ((frag_0, frag_1, frag_2) => require(\\"gql\\")\`
  query MyQuery($arg1: String)  {
    l1: lists  {
      ...ListFragment
    }
    l2: lists  {
      ...ListFragment
      ...ListFragment
    }
    l3: lists  {
      nullableOfNullable
      ...ListFragment
      ...ListFragment
    }
    l4: lists  {
      nullableOfNullable
      ...InlineListFragment
    }
    l5: lists  {
      ...FragmentWithArgs
    }
  }
\${frag_0}
\${frag_1}
\${frag_2}
\`)(query$2, query$3, query);

function parse$4(value) {
  var value$1 = value.l2;
  var value$2 = value.l3;
  var value$3 = value$2[\\"nullableOfNullable\\"];
  var value$4 = value.l4;
  var value$5 = value$4[\\"nullableOfNullable\\"];
  return {
          l1: parse(value.l1),
          l2: {
            frag1: parse(value$1),
            frag2: parse(value$1)
          },
          l3: {
            nullableOfNullable: !(value$3 == null) ? value$3.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            frag1: parse(value$2),
            frag2: parse(value$2)
          },
          l4: {
            nullableOfNullable: !(value$5 == null) ? value$5.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            inlineListFragment: parse$3(value$4)
          },
          l5: parse$2(value.l5)
        };
}

function serialize$4(value) {
  var value$1 = value.l5;
  var l5 = serialize$2(value$1);
  var value$2 = value.l4;
  var value$3 = value$2.nullableOfNullable;
  var l4 = [serialize$3(value$2.inlineListFragment)].reduce(deepMerge, {
        nullableOfNullable: value$3 !== undefined ? value$3.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$4 = value.l3;
  var value$5 = value$4.nullableOfNullable;
  var l3 = [
      serialize(value$4.frag1),
      serialize(value$4.frag2)
    ].reduce(deepMerge, {
        nullableOfNullable: value$5 !== undefined ? value$5.map((function (value) {
                  if (value !== undefined) {
                    return value;
                  } else {
                    return null;
                  }
                })) : null
      });
  var value$6 = value.l2;
  var l2 = [
      serialize(value$6.frag1),
      serialize(value$6.frag2)
    ].reduce(deepMerge, (function (prim) {
          return { };
        }));
  var value$7 = value.l1;
  var l1 = serialize(value$7);
  return {
          l1: l1,
          l2: l2,
          l3: l3,
          l4: l4,
          l5: l5
        };
}

function serializeVariables(inp) {
  var a = inp.arg1;
  return {
          arg1: a !== undefined ? a : undefined
        };
}

function makeVariables(arg1, param) {
  return serializeVariables({
              arg1: arg1
            });
}

function makeDefaultVariables(param) {
  return serializeVariables({
              arg1: undefined
            });
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw$4,
  query: query$4,
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$5 = ((frag_0) => require(\\"gql\\")\`
  query   {
    lists  {
      ...ListFragment
    }
  }
\${frag_0}
\`)(query);

function parse$5(value) {
  return {
          lists: parse(value.lists)
        };
}

function serialize$5(value) {
  var value$1 = value.lists;
  var lists = serialize(value$1);
  return {
          lists: lists
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$5 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$5,
  query: query$5,
  parse: parse$5,
  serialize: serialize$5,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$5
};

exports.GraphQL_PPX = GraphQL_PPX;
exports.ListFragment = ListFragment;
exports.Another = Another;
exports.FragmentWithArgs = FragmentWithArgs;
exports.InlineListFragment = InlineListFragment;
exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) fragmentInFragment.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


function deepMerge(json1, param) {
  return json1;
}

var GraphQL_PPX = {
  deepMerge: deepMerge
};

var Raw = { };

var query = (require(\\"gql\\")\`
  fragment ListFragment on Lists   {
    nullableOfNullable
  }
\`);

function parse(value) {
  var value$1 = value.nullableOfNullable;
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined
        };
}

function verifyArgsAndParse(_ListFragment, value) {
  return parse(value);
}

function serialize(value) {
  var value$1 = value.nullableOfNullable;
  var nullableOfNullable = value$1 !== undefined ? value$1.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  return {
          nullableOfNullable: nullableOfNullable
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL = {
  graphql: 0,
  graphql_module: 0
};

var ListFragment = {
  Raw: Raw,
  query: query,
  parse: parse,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = ((frag_0) => require(\\"gql\\")\`
  fragment Another on Lists   {
    nullableOfNullable
    ...ListFragment
  }
\${frag_0}
\`)(query);

function parse$1(value) {
  var value$1 = value[\\"nullableOfNullable\\"];
  return {
          nullableOfNullable: !(value$1 == null) ? value$1.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })) : undefined,
          listFragment: parse(value)
        };
}

function verifyArgsAndParse$1(_Another, value) {
  return parse$1(value);
}

function serialize$1(value) {
  var value$1 = value.nullableOfNullable;
  return [serialize(value.listFragment)].reduce(deepMerge, {
              nullableOfNullable: value$1 !== undefined ? value$1.map((function (value) {
                        if (value !== undefined) {
                          return value;
                        } else {
                          return null;
                        }
                      })) : null
            });
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql: 0,
  graphql_module: 0
};

var Another = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$1,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.GraphQL_PPX = GraphQL_PPX;
exports.ListFragment = ListFragment;
exports.Another = Another;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) interface.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
"
`;

exports[`Compilation (Template) lists.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    lists  {
      nullableOfNullable
      nullableOfNonNullable
      nonNullableOfNullable
      nonNullableOfNonNullable
    }
  }
\`);

function parse(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nullableOfNullable;
  var value$3 = value$1.nullableOfNonNullable;
  var value$4 = value$1.nonNullableOfNullable;
  var value$5 = value$1.nonNullableOfNonNullable;
  return {
          lists: {
            nullableOfNullable: !(value$2 == null) ? value$2.map((function (value) {
                      if (!(value == null)) {
                        return value;
                      }
                      
                    })) : undefined,
            nullableOfNonNullable: !(value$3 == null) ? value$3.map((function (value) {
                      return value;
                    })) : undefined,
            nonNullableOfNullable: value$4.map((function (value) {
                    if (!(value == null)) {
                      return value;
                    }
                    
                  })),
            nonNullableOfNonNullable: value$5.map((function (value) {
                    return value;
                  }))
          }
        };
}

function serialize(value) {
  var value$1 = value.lists;
  var value$2 = value$1.nonNullableOfNonNullable;
  var nonNullableOfNonNullable = value$2.map((function (value) {
          return value;
        }));
  var value$3 = value$1.nonNullableOfNullable;
  var nonNullableOfNullable = value$3.map((function (value) {
          if (value !== undefined) {
            return value;
          } else {
            return null;
          }
        }));
  var value$4 = value$1.nullableOfNonNullable;
  var nullableOfNonNullable = value$4 !== undefined ? value$4.map((function (value) {
            return value;
          })) : null;
  var value$5 = value$1.nullableOfNullable;
  var nullableOfNullable = value$5 !== undefined ? value$5.map((function (value) {
            if (value !== undefined) {
              return value;
            } else {
              return null;
            }
          })) : null;
  var lists = {
    nullableOfNullable: nullableOfNullable,
    nullableOfNonNullable: nullableOfNonNullable,
    nonNullableOfNullable: nonNullableOfNullable,
    nonNullableOfNonNullable: nonNullableOfNonNullable
  };
  return {
          lists: lists
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) listsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {
  listsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})
  }
\`);

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  var value$1 = value.listsInput;
  return {
          listsInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.nullableOfNullable;
  var a$1 = inp.nullableOfNonNullable;
  var a$2 = inp.nonNullableOfNullable;
  var a$3 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          nullableOfNonNullable: a$1 !== undefined ? $$Array.map((function (b) {
                    return b;
                  }), a$1) : undefined,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$2),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$3)
        };
}

function makeVariables(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return serializeVariables({
              nullableOfNullable: nullableOfNullable,
              nullableOfNonNullable: nullableOfNonNullable,
              nonNullableOfNullable: nonNullableOfNullable,
              nonNullableOfNonNullable: nonNullableOfNonNullable
            });
}

var Z__INTERNAL = {
  _graphql_arg_219: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) listsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  query ($arg: ListsInput!)  {
    listsInput(arg: $arg)
  }
\`);

function parse(value) {
  return {
          listsInput: value.listsInput
        };
}

function serialize(value) {
  var value$1 = value.listsInput;
  return {
          listsInput: value$1
        };
}

function serializeInputObjectListsInput(inp) {
  var a = inp.nullableOfNullable;
  var a$1 = inp.nullableOfNonNullable;
  var a$2 = inp.nonNullableOfNullable;
  var a$3 = inp.nonNullableOfNonNullable;
  return {
          nullableOfNullable: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          nullableOfNonNullable: a$1 !== undefined ? $$Array.map((function (b) {
                    return b;
                  }), a$1) : undefined,
          nonNullableOfNullable: $$Array.map((function (b) {
                  if (b !== undefined) {
                    return b;
                  }
                  
                }), a$2),
          nonNullableOfNonNullable: $$Array.map((function (b) {
                  return b;
                }), a$3)
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectListsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectListsInput(arg)
        };
}

function makeInputObjectListsInput(nullableOfNullable, nullableOfNonNullable, nonNullableOfNullable, nonNullableOfNonNullable, param) {
  return {
          nullableOfNullable: nullableOfNullable,
          nullableOfNonNullable: nullableOfNonNullable,
          nonNullableOfNullable: nonNullableOfNullable,
          nonNullableOfNonNullable: nonNullableOfNonNullable
        };
}

var Z__INTERNAL = {
  _graphql_arg_82: 0,
  _graphql_arg_77: 0,
  _graphql_ListsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectListsInput: serializeInputObjectListsInput,
  makeVariables: makeVariables,
  makeInputObjectListsInput: makeInputObjectListsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) mutation.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  mutation   {
    mutationWithError  {
      value  {
        stringField
      }
      errors  {
        field
        message
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.value;
  var value$3 = value$1.errors;
  return {
          mutationWithError: {
            value: !(value$2 == null) ? ({
                  stringField: value$2.stringField
                }) : undefined,
            errors: !(value$3 == null) ? value$3.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          tmp = /* \`FutureAddedValue */[
                            -31101740,
                            value$1
                          ];
                      }
                      return {
                              field: tmp,
                              message: value.message
                            };
                    })) : undefined
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.message;
            var value$2 = value.field;
            var field = typeof value$2 === \\"number\\" ? (
                value$2 !== 225952583 ? (
                    value$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$2[1];
            return {
                    field: field,
                    message: value$1
                  };
          })) : null;
  var value$3 = value$1.value;
  var value$4;
  if (value$3 !== undefined) {
    var value$5 = value$3.stringField;
    value$4 = {
      stringField: value$5
    };
  } else {
    value$4 = null;
  }
  var mutationWithError = {
    value: value$4,
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) mutationWithArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  mutation MyMutation($required: String!)  {
    optionalInputArgs(required: $required, anotherRequired: \\"val\\")
  }
\`);

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  var value$1 = value.optionalInputArgs;
  return {
          optionalInputArgs: value$1
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return {
          required: required
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) mutationWithArgsAndNoRecords.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  mutation MyMutation($required: String!)  {
    optionalInputArgs(required: $required, anotherRequired: \\"val\\")
  }
\`);

function parse(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serialize(value) {
  return {
          optionalInputArgs: value.optionalInputArgs
        };
}

function serializeVariables(inp) {
  return {
          required: inp.required
        };
}

function makeVariables(required, param) {
  return serializeVariables({
              required: required
            });
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) nested.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    first: nestedObject  {
      inner  {
        inner  {
          field
        }
      }
    }
    second: nestedObject  {
      inner  {
        inner  {
          f1: field
          f2: field
        }
      }
    }
    let: nestedObject  {
      inner  {
        inner  {
          field
        }
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var tmp;
  if (value$2 == null) {
    tmp = undefined;
  } else {
    var value$3 = value$2.inner;
    tmp = {
      inner: !(value$3 == null) ? ({
            field: value$3.field
          }) : undefined
    };
  }
  var value$4 = value.second;
  var value$5 = value$4.inner;
  var tmp$1;
  if (value$5 == null) {
    tmp$1 = undefined;
  } else {
    var value$6 = value$5.inner;
    tmp$1 = {
      inner: !(value$6 == null) ? ({
            f1: value$6.f1,
            f2: value$6.f2
          }) : undefined
    };
  }
  var value$7 = value.let_;
  var value$8 = value$7.inner;
  var tmp$2;
  if (value$8 == null) {
    tmp$2 = undefined;
  } else {
    var value$9 = value$8.inner;
    tmp$2 = {
      inner: !(value$9 == null) ? ({
            field: value$9.field
          }) : undefined
    };
  }
  return {
          first: {
            inner: tmp
          },
          second: {
            inner: tmp$1
          },
          let_: {
            inner: tmp$2
          }
        };
}

function serialize(value) {
  var value$1 = value.let_;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = value$2.inner;
    var inner$1;
    if (value$3 !== undefined) {
      var value$4 = value$3.field;
      inner$1 = {
        field: value$4
      };
    } else {
      inner$1 = null;
    }
    inner = {
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var let_ = {
    inner: inner
  };
  var value$5 = value.second;
  var value$6 = value$5.inner;
  var inner$2;
  if (value$6 !== undefined) {
    var value$7 = value$6.inner;
    var inner$3;
    if (value$7 !== undefined) {
      var value$8 = value$7.f2;
      var value$9 = value$7.f1;
      inner$3 = {
        f1: value$9,
        f2: value$8
      };
    } else {
      inner$3 = null;
    }
    inner$2 = {
      inner: inner$3
    };
  } else {
    inner$2 = null;
  }
  var second = {
    inner: inner$2
  };
  var value$10 = value.first;
  var value$11 = value$10.inner;
  var inner$4;
  if (value$11 !== undefined) {
    var value$12 = value$11.inner;
    var inner$5;
    if (value$12 !== undefined) {
      var value$13 = value$12.field;
      inner$5 = {
        field: value$13
      };
    } else {
      inner$5 = null;
    }
    inner$4 = {
      inner: inner$5
    };
  } else {
    inner$4 = null;
  }
  var first = {
    inner: inner$4
  };
  return {
          first: first,
          second: second,
          let_: let_
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) nonrecursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require(\\"bs-platform/lib/js/array.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  query ($arg: NonrecursiveInput!)  {
    nonrecursiveInput(arg: $arg)
  }
\`);

function parse(value) {
  return {
          nonrecursiveInput: value.nonrecursiveInput
        };
}

function serialize(value) {
  var value$1 = value.nonrecursiveInput;
  return {
          nonrecursiveInput: value$1
        };
}

function serializeInputObjectEmbeddedInput(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput(b);
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectNonrecursiveInput(arg)
        };
}

function makeInputObjectNonrecursiveInput(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL = {
  _graphql_arg_100: 0,
  _graphql_arg_95: 0,
  _graphql_NonrecursiveInput_49: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput,
  makeVariables: makeVariables,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {
    scalarsInput(arg: $arg)
    more: scalarsInput(arg: $arg2)
  }
\`);

function parse$1(value) {
  return {
          scalarsInput: value.scalarsInput,
          more: value.more
        };
}

function serialize$1(value) {
  var value$1 = value.more;
  var value$2 = value.scalarsInput;
  return {
          scalarsInput: value$2,
          more: value$1
        };
}

function serializeInputObjectEmbeddedInput$1(inp) {
  var a = inp.field;
  return {
          field: a !== undefined ? a : undefined
        };
}

function serializeInputObjectNonrecursiveInput$1(inp) {
  var a = inp.nullableArray;
  var a$1 = inp.field;
  var a$2 = inp.enum;
  var a$3 = inp.embeddedInput;
  var a$4 = inp.custom;
  return {
          nonNullableField: inp.nonNullableField,
          nullableArray: a !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return b;
                    }
                    
                  }), a) : undefined,
          field: a$1 !== undefined ? a$1 : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined,
          embeddedInput: a$3 !== undefined ? $$Array.map((function (b) {
                    if (b !== undefined) {
                      return serializeInputObjectEmbeddedInput$1(b);
                    }
                    
                  }), a$3) : undefined,
          custom: a$4 !== undefined ? Caml_option.valFromOption(a$4) : undefined
        };
}

function serializeVariables$1(inp) {
  return {
          arg: serializeInputObjectNonrecursiveInput$1(inp.arg),
          arg2: serializeInputObjectNonrecursiveInput$1(inp.arg2)
        };
}

function makeVariables$1(arg, arg2, param) {
  return serializeVariables$1({
              arg: arg,
              arg2: arg2
            });
}

function makeInputObjectNonrecursiveInput$1(nonNullableField, nullableArray, field, $$enum, embeddedInput, custom, param) {
  return {
          nonNullableField: nonNullableField,
          nullableArray: nullableArray,
          field: field,
          enum: $$enum,
          embeddedInput: embeddedInput,
          custom: custom
        };
}

function makeInputObjectEmbeddedInput$1(field, param) {
  return {
          field: field
        };
}

var Z__INTERNAL$1 = {
  _graphql_arg_240: 0,
  _graphql_arg_235: 0,
  _graphql_NonrecursiveInput_169: 0,
  _graphql_NonrecursiveInput_196: 0,
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  serializeInputObjectNonrecursiveInput: serializeInputObjectNonrecursiveInput$1,
  serializeInputObjectEmbeddedInput: serializeInputObjectEmbeddedInput$1,
  makeVariables: makeVariables$1,
  makeInputObjectNonrecursiveInput: makeInputObjectNonrecursiveInput$1,
  makeInputObjectEmbeddedInput: makeInputObjectEmbeddedInput$1,
  Z__INTERNAL: Z__INTERNAL$1
};

exports.MyQuery = MyQuery;
exports.MyQuery2 = MyQuery2;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) omitFutureValueEnum.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  mutation   {
    mutationWithError  {
      errors  {
        message
        field
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: !(value$2 == null) ? value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          tmp = /* \`FutureAddedValue */[
                            -31101740,
                            value$1
                          ];
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    })) : undefined
          }
        };
}

function serialize(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = typeof value$1 === \\"number\\" ? (
                value$1 !== 225952583 ? (
                    value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                  ) : \\"THIRD\\"
              ) : value$1[1];
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  mutation   {
    mutationWithError  {
      errors  {
        message
        field
      }
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: !(value$2 == null) ? value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          throw Caml_builtin_exceptions.not_found;
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    })) : undefined
          }
        };
}

function serialize$1(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (require(\\"gql\\")\`
  mutation   {
    mutationWithError  {
      errors  {
        message
        field
      }
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  return {
          mutationWithError: {
            errors: !(value$2 == null) ? value$2.map((function (value) {
                      var value$1 = value.field;
                      var tmp;
                      switch (value$1) {
                        case \\"FIRST\\" :
                            tmp = /* FIRST */-24399856;
                            break;
                        case \\"SECOND\\" :
                            tmp = /* SECOND */382368628;
                            break;
                        case \\"THIRD\\" :
                            tmp = /* THIRD */225952583;
                            break;
                        default:
                          throw Caml_builtin_exceptions.not_found;
                      }
                      return {
                              message: value.message,
                              field: tmp
                            };
                    })) : undefined
          }
        };
}

function serialize$2(value) {
  var value$1 = value.mutationWithError;
  var value$2 = value$1.errors;
  var errors = value$2 !== undefined ? value$2.map((function (value) {
            var value$1 = value.field;
            var field = value$1 !== 225952583 ? (
                value$1 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
              ) : \\"THIRD\\";
            var value$2 = value.message;
            return {
                    message: value$2,
                    field: field
                  };
          })) : null;
  var mutationWithError = {
    errors: errors
  };
  return {
          mutationWithError: mutationWithError
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) omitFutureValueUnion.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_builtin_exceptions = require(\\"bs-platform/lib/js/caml_builtin_exceptions.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
        barkVolume
      }
      ...on Human   {
        name
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var Normal = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
        barkVolume
      }
      ...on Human   {
        name
      }
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    dogOrHuman = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var ByConfig = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
        barkVolume
      }
      ...on Human   {
        name
      }
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    var value$5 = value$1[1].name;
    dogOrHuman = {
      __typename: \\"Human\\",
      name: value$5
    };
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var ByDirective = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.Normal = Normal;
exports.ByConfig = ByConfig;
exports.ByDirective = ByDirective;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) pokedexApolloMode.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    pokemon(name: \\"Pikachu\\")  {
      id
      name
    }
  }
\`);

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    tmp = {
      id: value$1.id,
      name: !(value$2 == null) ? value$2 : undefined
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var pokemon;
  if (value$1 !== undefined) {
    var value$2 = value$1.name;
    var name = value$2 !== undefined ? value$2 : null;
    var value$3 = value$1.id;
    pokemon = {
      id: value$3,
      name: name
    };
  } else {
    pokemon = null;
  }
  return {
          pokemon: pokemon
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  _graphql_name_52: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) pokedexScalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query pokemon($id: String, $name: String)  {
    pokemon(name: $name, id: $id)  {
      id
      name
    }
  }
\`);

function parse(value) {
  var value$1 = value.pokemon;
  var tmp;
  if (value$1 == null) {
    tmp = undefined;
  } else {
    var value$2 = value$1.name;
    tmp = {
      id: value$1.id,
      name: !(value$2 == null) ? value$2 : undefined
    };
  }
  return {
          pokemon: tmp
        };
}

function serialize(value) {
  var value$1 = value.pokemon;
  var pokemon;
  if (value$1 !== undefined) {
    var value$2 = value$1.name;
    var name = value$2 !== undefined ? value$2 : null;
    var value$3 = value$1.id;
    pokemon = {
      id: value$3,
      name: name
    };
  } else {
    pokemon = null;
  }
  return {
          pokemon: pokemon
        };
}

function serializeVariables(inp) {
  var a = inp.id;
  var a$1 = inp.name;
  return {
          id: a !== undefined ? a : undefined,
          name: a$1 !== undefined ? a$1 : undefined
        };
}

function makeVariables(id, name, param) {
  return serializeVariables({
              id: id,
              name: name
            });
}

function makeDefaultVariables(param) {
  return serializeVariables({
              id: undefined,
              name: undefined
            });
}

var Z__INTERNAL = {
  _graphql_pokemon_name_100: 0,
  _graphql_name_94: 0,
  _graphql_pokemon_id_111: 0,
  _graphql_id_107: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) record.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    variousScalars  {
      string
      int
    }
  }
\`);

function parse(value) {
  var value$1 = value.variousScalars;
  return {
          variousScalars: {
            string: value$1.string,
            int: value$1.int
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.int;
  var value$3 = value$1.string;
  var variousScalars = {
    string: value$3,
    int: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query   {
    variousScalars  {
      nullableString
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var nullableString = value$2 !== undefined ? value$2 : null;
  var variousScalars = {
    nullableString: nullableString
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var OneFieldQuery = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (require(\\"gql\\")\`
  fragment Fragment on VariousScalars   {
    string
    int
  }
\`);

function parse$2(value) {
  return {
          string: value.string,
          int: value.int
        };
}

function verifyArgsAndParse(_Fragment, value) {
  return parse$2(value);
}

function serialize$2(value) {
  var value$1 = value.int;
  var value$2 = value.string;
  return {
          string: value$2,
          int: value$1
        };
}

function verifyName(param) {
  
}

var Z__INTERNAL$2 = {
  graphql: 0,
  graphql_module: 0
};

var Fragment = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  verifyArgsAndParse: verifyArgsAndParse,
  serialize: serialize$2,
  verifyName: verifyName,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$3 = ((frag_0) => require(\\"gql\\")\`
  query   {
    variousScalars  {
      ...Fragment
    }
  }
\${frag_0}
\`)(query$2);

function parse$3(value) {
  return {
          variousScalars: parse$2(value.variousScalars)
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var variousScalars = serialize$2(value$1);
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var Untitled1 = {
  Raw: Raw$3,
  query: query$3,
  parse: parse$3,
  serialize: serialize$3,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$3
};

var ExternalFragmentQuery = {
  Fragment: Fragment,
  Untitled1: Untitled1
};

var Raw$4 = { };

var query$4 = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
        barkVolume
      }
    }
  }
\`);

function parse$4(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      {
        name: value$1.name,
        barkVolume: value$1.barkVolume
      }
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$4(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$3(param) {
  
}

function makeVariables$3(param) {
  
}

function makeDefaultVariables$3(param) {
  
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var InlineFragmentQuery = {
  Raw: Raw$4,
  query: query$4,
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables$3,
  makeVariables: makeVariables$3,
  makeDefaultVariables: makeDefaultVariables$3,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$5 = (require(\\"gql\\")\`
  fragment DogFragment on Dog   {
    name
    barkVolume
  }
\`);

function parse$5(value) {
  return {
          name: value.name,
          barkVolume: value.barkVolume
        };
}

function verifyArgsAndParse$1(_DogFragment, value) {
  return parse$5(value);
}

function serialize$5(value) {
  var value$1 = value.barkVolume;
  var value$2 = value.name;
  return {
          name: value$2,
          barkVolume: value$1
        };
}

function verifyName$1(param) {
  
}

var Z__INTERNAL$5 = {
  graphql: 0,
  graphql_module: 0
};

var DogFragment = {
  Raw: Raw$5,
  query: query$5,
  parse: parse$5,
  verifyArgsAndParse: verifyArgsAndParse$1,
  serialize: serialize$5,
  verifyName: verifyName$1,
  Z__INTERNAL: Z__INTERNAL$5
};

var Raw$6 = { };

var query$6 = ((frag_0) => require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        ...DogFragment
      }
    }
  }
\${frag_0}
\`)(query$5);

function parse$6(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      parse$5(value$1)
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize$6(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman = value$1[0] >= 3406428 ? serialize$5(value$1[1]) : value$1[1];
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$4(param) {
  
}

function makeVariables$4(param) {
  
}

function makeDefaultVariables$4(param) {
  
}

var Z__INTERNAL$6 = {
  graphql_module: 0
};

var Untitled1$1 = {
  Raw: Raw$6,
  query: query$6,
  parse: parse$6,
  serialize: serialize$6,
  serializeVariables: serializeVariables$4,
  makeVariables: makeVariables$4,
  makeDefaultVariables: makeDefaultVariables$4,
  Z__INTERNAL: Z__INTERNAL$6
};

var UnionExternalFragmentQuery = {
  DogFragment: DogFragment,
  Untitled1: Untitled1$1
};

exports.MyQuery = MyQuery;
exports.OneFieldQuery = OneFieldQuery;
exports.ExternalFragmentQuery = ExternalFragmentQuery;
exports.InlineFragmentQuery = InlineFragmentQuery;
exports.UnionExternalFragmentQuery = UnionExternalFragmentQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) recursiveInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query ($arg: RecursiveInput!)  {
    recursiveInput(arg: $arg)
  }
\`);

function parse(value) {
  return {
          recursiveInput: value.recursiveInput
        };
}

function serialize(value) {
  var value$1 = value.recursiveInput;
  return {
          recursiveInput: value$1
        };
}

function serializeInputObjectRecursiveInput(inp) {
  var a = inp.otherField;
  var a$1 = inp.inner;
  var a$2 = inp.enum;
  return {
          otherField: a !== undefined ? a : undefined,
          inner: a$1 !== undefined ? serializeInputObjectRecursiveInput(a$1) : undefined,
          enum: a$2 !== undefined ? (
              a$2 !== 225952583 ? (
                  a$2 >= 382368628 ? \\"SECOND\\" : \\"FIRST\\"
                ) : \\"THIRD\\"
            ) : undefined
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectRecursiveInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectRecursiveInput(arg)
        };
}

function makeInputObjectRecursiveInput(otherField, inner, $$enum, param) {
  return {
          otherField: otherField,
          inner: inner,
          enum: $$enum
        };
}

var Z__INTERNAL = {
  _graphql_arg_90: 0,
  _graphql_arg_85: 0,
  _graphql_RecursiveInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectRecursiveInput: serializeInputObjectRecursiveInput,
  makeVariables: makeVariables,
  makeInputObjectRecursiveInput: makeInputObjectRecursiveInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) scalars.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) scalarsArgs.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {
  scalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})
  }
\`);

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  var value$1 = value.scalarsInput;
  return {
          scalarsInput: value$1
        };
}

function serializeVariables(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function makeVariables(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return serializeVariables({
              nullableString: nullableString,
              string: string,
              nullableInt: nullableInt,
              int: $$int,
              nullableFloat: nullableFloat,
              float: $$float,
              nullableBoolean: nullableBoolean,
              boolean: $$boolean,
              nullableID: nullableID,
              id: id
            });
}

var Z__INTERNAL = {
  _graphql_arg_292: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) scalarsInput.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query ($arg: VariousScalarsInput!)  {
    scalarsInput(arg: $arg)
  }
\`);

function parse(value) {
  return {
          scalarsInput: value.scalarsInput
        };
}

function serialize(value) {
  var value$1 = value.scalarsInput;
  return {
          scalarsInput: value$1
        };
}

function serializeInputObjectVariousScalarsInput(inp) {
  var a = inp.nullableString;
  var a$1 = inp.nullableInt;
  var a$2 = inp.nullableFloat;
  var a$3 = inp.nullableBoolean;
  var a$4 = inp.nullableID;
  return {
          nullableString: a !== undefined ? a : undefined,
          string: inp.string,
          nullableInt: a$1 !== undefined ? a$1 : undefined,
          int: inp.int,
          nullableFloat: a$2 !== undefined ? a$2 : undefined,
          float: inp.float,
          nullableBoolean: a$3 !== undefined ? a$3 : undefined,
          boolean: inp.boolean,
          nullableID: a$4 !== undefined ? a$4 : undefined,
          id: inp.id
        };
}

function serializeVariables(inp) {
  return {
          arg: serializeInputObjectVariousScalarsInput(inp.arg)
        };
}

function makeVariables(arg, param) {
  return {
          arg: serializeInputObjectVariousScalarsInput(arg)
        };
}

function makeInputObjectVariousScalarsInput(nullableString, string, nullableInt, $$int, nullableFloat, $$float, nullableBoolean, $$boolean, nullableID, id, param) {
  return {
          nullableString: nullableString,
          string: string,
          nullableInt: nullableInt,
          int: $$int,
          nullableFloat: nullableFloat,
          float: $$float,
          nullableBoolean: nullableBoolean,
          boolean: $$boolean,
          nullableID: nullableID,
          id: id
        };
}

var Z__INTERNAL = {
  _graphql_arg_93: 0,
  _graphql_arg_88: 0,
  _graphql_VariousScalarsInput_47: 0,
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  serializeInputObjectVariousScalarsInput: serializeInputObjectVariousScalarsInput,
  makeVariables: makeVariables,
  makeInputObjectVariousScalarsInput: makeInputObjectVariousScalarsInput,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) skipDirectives.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query ($var: Boolean!)  {
    v1: variousScalars  {
      nullableString @skip(if: $var)
      string @skip(if: $var)
    }
    v2: variousScalars  {
      nullableString @include(if: $var)
      string @include(if: $var)
    }
  }
\`);

function parse(value) {
  var value$1 = value.v1;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.string;
  var value$4 = value.v2;
  var value$5 = value$4.nullableString;
  var value$6 = value$4.string;
  return {
          v1: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: !(value$3 == null) ? value$3 : undefined
          },
          v2: {
            nullableString: !(value$5 == null) ? value$5 : undefined,
            string: !(value$6 == null) ? value$6 : undefined
          }
        };
}

function serialize(value) {
  var value$1 = value.v2;
  var value$2 = value$1.string;
  var string = value$2 !== undefined ? value$2 : null;
  var value$3 = value$1.nullableString;
  var nullableString = value$3 !== undefined ? value$3 : null;
  var v2 = {
    nullableString: nullableString,
    string: string
  };
  var value$4 = value.v1;
  var value$5 = value$4.string;
  var string$1 = value$5 !== undefined ? value$5 : null;
  var value$6 = value$4.nullableString;
  var nullableString$1 = value$6 !== undefined ? value$6 : null;
  var v1 = {
    nullableString: nullableString$1,
    string: string$1
  };
  return {
          v1: v1,
          v2: v2
        };
}

function serializeVariables(inp) {
  return {
          var: inp.var
        };
}

function makeVariables($$var, param) {
  return {
          var: $$var
        };
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) subscription.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  subscription   {
    simpleSubscription  {
      __typename
      ...on Dog   {
        name
      }
      ...on Human   {
        name
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.simpleSubscription;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          simpleSubscription: tmp
        };
}

function serialize(value) {
  var value$1 = value.simpleSubscription;
  var variant = value$1[0];
  var simpleSubscription;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      simpleSubscription = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      simpleSubscription = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    simpleSubscription = value$1[1];
  }
  return {
          simpleSubscription: simpleSubscription
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) tagged_template.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var MyTypes = { };

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$1(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQuery1a = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (require(\\"gql\\")\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$2(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var MyQuery1b = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

var Raw$3 = { };

var query$3 = (require(\\"gatsby\\").graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$3(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$3(param) {
  
}

function makeVariables$3(param) {
  
}

function makeDefaultVariables$3(param) {
  
}

var Z__INTERNAL$3 = {
  graphql_module: 0
};

var MyQuery2 = {
  Raw: Raw$3,
  query: query$3,
  parse: parse$3,
  serialize: serialize$3,
  serializeVariables: serializeVariables$3,
  makeVariables: makeVariables$3,
  makeDefaultVariables: makeDefaultVariables$3,
  Z__INTERNAL: Z__INTERNAL$3
};

var Raw$4 = { };

var query$4 = (require(\\"gatsby\\").graphql\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$4(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$4(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$4(param) {
  
}

function makeVariables$4(param) {
  
}

function makeDefaultVariables$4(param) {
  
}

var Z__INTERNAL$4 = {
  graphql_module: 0
};

var MyQuery3 = {
  Raw: Raw$4,
  query: query$4,
  parse: parse$4,
  serialize: serialize$4,
  serializeVariables: serializeVariables$4,
  makeVariables: makeVariables$4,
  makeDefaultVariables: makeDefaultVariables$4,
  Z__INTERNAL: Z__INTERNAL$4
};

var Raw$5 = { };

var query$5 = (require(\\"gatsby\\")\`
  query   {
    variousScalars  {
      nullableString
      string
      nullableInt
      int
      nullableFloat
      float
      nullableBoolean
      boolean
      nullableID
      id
    }
  }
\`);

function parse$5(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.nullableString;
  var value$3 = value$1.nullableInt;
  var value$4 = value$1.nullableFloat;
  var value$5 = value$1.nullableBoolean;
  var value$6 = value$1.nullableID;
  return {
          variousScalars: {
            nullableString: !(value$2 == null) ? value$2 : undefined,
            string: value$1.string,
            nullableInt: !(value$3 == null) ? value$3 : undefined,
            int: value$1.int,
            nullableFloat: !(value$4 == null) ? value$4 : undefined,
            float: value$1.float,
            nullableBoolean: !(value$5 == null) ? value$5 : undefined,
            boolean: value$1.boolean,
            nullableID: !(value$6 == null) ? value$6 : undefined,
            id: value$1.id
          }
        };
}

function serialize$5(value) {
  var value$1 = value.variousScalars;
  var value$2 = value$1.id;
  var value$3 = value$1.nullableID;
  var nullableID = value$3 !== undefined ? value$3 : null;
  var value$4 = value$1.boolean;
  var value$5 = value$1.nullableBoolean;
  var nullableBoolean = value$5 !== undefined ? value$5 : null;
  var value$6 = value$1.float;
  var value$7 = value$1.nullableFloat;
  var nullableFloat = value$7 !== undefined ? value$7 : null;
  var value$8 = value$1.int;
  var value$9 = value$1.nullableInt;
  var nullableInt = value$9 !== undefined ? value$9 : null;
  var value$10 = value$1.string;
  var value$11 = value$1.nullableString;
  var nullableString = value$11 !== undefined ? value$11 : null;
  var variousScalars = {
    nullableString: nullableString,
    string: value$10,
    nullableInt: nullableInt,
    int: value$8,
    nullableFloat: nullableFloat,
    float: value$6,
    nullableBoolean: nullableBoolean,
    boolean: value$4,
    nullableID: nullableID,
    id: value$2
  };
  return {
          variousScalars: variousScalars
        };
}

function serializeVariables$5(param) {
  
}

function makeVariables$5(param) {
  
}

function makeDefaultVariables$5(param) {
  
}

var Z__INTERNAL$5 = {
  graphql_module: 0
};

var MyQuery4 = {
  Raw: Raw$5,
  query: query$5,
  parse: parse$5,
  serialize: serialize$5,
  serializeVariables: serializeVariables$5,
  makeVariables: makeVariables$5,
  makeDefaultVariables: makeDefaultVariables$5,
  Z__INTERNAL: Z__INTERNAL$5
};

exports.MyQuery = MyQuery;
exports.MyTypes = MyTypes;
exports.MyQuery1a = MyQuery1a;
exports.MyQuery1b = MyQuery1b;
exports.MyQuery2 = MyQuery2;
exports.MyQuery3 = MyQuery3;
exports.MyQuery4 = MyQuery4;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) typename.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    first: nestedObject  {
      __typename
      inner  {
        __typename
        inner  {
          __typename
          field
        }
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var tmp;
  if (value$2 == null) {
    tmp = undefined;
  } else {
    var value$3 = value$2.inner;
    tmp = {
      __typename: value$2.__typename,
      inner: !(value$3 == null) ? ({
            __typename: value$3.__typename,
            field: value$3.field
          }) : undefined
    };
  }
  return {
          first: {
            __typename: value$1.__typename,
            inner: tmp
          }
        };
}

function serialize(value) {
  var value$1 = value.first;
  var value$2 = value$1.inner;
  var inner;
  if (value$2 !== undefined) {
    var value$3 = value$2.inner;
    var inner$1;
    if (value$3 !== undefined) {
      var value$4 = value$3.field;
      var value$5 = value$3.__typename;
      inner$1 = {
        __typename: value$5,
        field: value$4
      };
    } else {
      inner$1 = null;
    }
    var value$6 = value$2.__typename;
    inner = {
      __typename: value$6,
      inner: inner$1
    };
  } else {
    inner = null;
  }
  var value$7 = value$1.__typename;
  var first = {
    __typename: value$7,
    inner: inner
  };
  return {
          first: first
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) union.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
        barkVolume
      }
      ...on Human   {
        name
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

var Raw$1 = { };

var query$1 = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
        barkVolume
      }
      ...on Human   {
        name
      }
    }
  }
\`);

function parse$1(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name,
            barkVolume: value$1.barkVolume
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$1(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1];
      var value$3 = value$2.barkVolume;
      var value$4 = value$2.name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$4,
        barkVolume: value$3
      };
    } else {
      var value$5 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$5
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$1(param) {
  
}

function makeVariables$1(param) {
  
}

function makeDefaultVariables$1(param) {
  
}

var Z__INTERNAL$1 = {
  graphql_module: 0
};

var MyQueryNoError = {
  Raw: Raw$1,
  query: query$1,
  parse: parse$1,
  serialize: serialize$1,
  serializeVariables: serializeVariables$1,
  makeVariables: makeVariables$1,
  makeDefaultVariables: makeDefaultVariables$1,
  Z__INTERNAL: Z__INTERNAL$1
};

var Raw$2 = { };

var query$2 = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
      }
      ...on Human   {
        name
      }
    }
  }
\`);

function parse$2(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp;
  switch (typename) {
    case \\"Dog\\" :
        tmp = /* \`Dog */[
          3406428,
          {
            name: value$1.name
          }
        ];
        break;
    case \\"Human\\" :
        tmp = /* \`Human */[
          -1031617139,
          {
            name: value$1.name
          }
        ];
        break;
    default:
      tmp = /* \`FutureAddedValue */[
        -31101740,
        value$1
      ];
  }
  return {
          dogOrHuman: tmp
        };
}

function serialize$2(value) {
  var value$1 = value.dogOrHuman;
  var variant = value$1[0];
  var dogOrHuman;
  if (variant !== -31101740) {
    if (variant >= 3406428) {
      var value$2 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Dog\\",
        name: value$2
      };
    } else {
      var value$3 = value$1[1].name;
      dogOrHuman = {
        __typename: \\"Human\\",
        name: value$3
      };
    }
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables$2(param) {
  
}

function makeVariables$2(param) {
  
}

function makeDefaultVariables$2(param) {
  
}

var Z__INTERNAL$2 = {
  graphql_module: 0
};

var NamedQuery = {
  Raw: Raw$2,
  query: query$2,
  parse: parse$2,
  serialize: serialize$2,
  serializeVariables: serializeVariables$2,
  makeVariables: makeVariables$2,
  makeDefaultVariables: makeDefaultVariables$2,
  Z__INTERNAL: Z__INTERNAL$2
};

exports.MyQuery = MyQuery;
exports.MyQueryNoError = MyQueryNoError;
exports.NamedQuery = NamedQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) unionPartial.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';


var Raw = { };

var query = (require(\\"gql\\")\`
  query   {
    dogOrHuman  {
      __typename
      ...on Dog   {
        name
        barkVolume
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.dogOrHuman;
  var typename = value$1[\\"__typename\\"];
  var tmp = typename === \\"Dog\\" ? /* \`Dog */[
      3406428,
      {
        name: value$1.name,
        barkVolume: value$1.barkVolume
      }
    ] : /* \`FutureAddedValue */[
      -31101740,
      value$1
    ];
  return {
          dogOrHuman: tmp
        };
}

function serialize(value) {
  var value$1 = value.dogOrHuman;
  var dogOrHuman;
  if (value$1[0] >= 3406428) {
    var value$2 = value$1[1];
    var value$3 = value$2.barkVolume;
    var value$4 = value$2.name;
    dogOrHuman = {
      __typename: \\"Dog\\",
      name: value$4,
      barkVolume: value$3
    };
  } else {
    dogOrHuman = value$1[1];
  }
  return {
          dogOrHuman: dogOrHuman
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Compilation (Template) variant.re 1`] = `
"// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require(\\"bs-platform/lib/js/js_exn.js\\");
var Js_json = require(\\"bs-platform/lib/js/js_json.js\\");
var Caml_option = require(\\"bs-platform/lib/js/caml_option.js\\");

var Raw = { };

var query = (require(\\"gql\\")\`
  mutation   {
    mutationForVariant  {
      baseType
      baseTypeList
      dog  {
        name
        barkVolume
      }
      human  {
        name
      }
      dogOrHuman  {
        __typename
        ...on Dog   {
          name
          barkVolume
        }
        ...on Human   {
          name
        }
      }
    }
  }
\`);

function parse(value) {
  var value$1 = value.mutationForVariant;
  var value$2 = Js_json.decodeObject(value$1);
  var tmp;
  if (value$2 !== undefined) {
    var value$3 = Caml_option.valFromOption(value$2);
    var temp = value$3[\\"baseType\\"];
    var match = Js_json.decodeNull(temp);
    if (match !== undefined) {
      var temp$1 = value$3[\\"baseTypeList\\"];
      var match$1 = Js_json.decodeNull(temp$1);
      if (match$1 !== undefined) {
        var temp$2 = value$3[\\"dog\\"];
        var match$2 = Js_json.decodeNull(temp$2);
        if (match$2 !== undefined) {
          var temp$3 = value$3[\\"human\\"];
          var match$3 = Js_json.decodeNull(temp$3);
          if (match$3 !== undefined) {
            var temp$4 = value$3[\\"dogOrHuman\\"];
            var match$4 = Js_json.decodeNull(temp$4);
            if (match$4 !== undefined) {
              tmp = Js_exn.raiseError(\\"graphql-ppx: All fields on variant selection set on type VariantTestResult were null\\");
            } else {
              var typename = temp$4[\\"__typename\\"];
              var tmp$1;
              switch (typename) {
                case \\"Dog\\" :
                    tmp$1 = /* \`Dog */[
                      3406428,
                      {
                        name: temp$4.name,
                        barkVolume: temp$4.barkVolume
                      }
                    ];
                    break;
                case \\"Human\\" :
                    tmp$1 = /* \`Human */[
                      -1031617139,
                      {
                        name: temp$4.name
                      }
                    ];
                    break;
                default:
                  tmp$1 = /* \`FutureAddedValue */[
                    -31101740,
                    temp$4
                  ];
              }
              tmp = /* \`DogOrHuman */[
                974247566,
                tmp$1
              ];
            }
          } else {
            tmp = /* \`Human */[
              -1031617139,
              {
                name: temp$3.name
              }
            ];
          }
        } else {
          tmp = /* \`Dog */[
            3406428,
            {
              name: temp$2.name,
              barkVolume: temp$2.barkVolume
            }
          ];
        }
      } else {
        tmp = /* \`BaseTypeList */[
          -259847799,
          temp$1.map((function (value) {
                  return value;
                }))
        ];
      }
    } else {
      tmp = /* \`BaseType */[
        -620191861,
        temp
      ];
    }
  } else {
    tmp = Js_exn.raiseError(\\"graphql-ppx: Expected type VariantTestResult to be an object\\");
  }
  return {
          mutationForVariant: tmp
        };
}

function serialize(value) {
  var mutationForVariant = null;
  return {
          mutationForVariant: mutationForVariant
        };
}

function serializeVariables(param) {
  
}

function makeVariables(param) {
  
}

function makeDefaultVariables(param) {
  
}

var Z__INTERNAL = {
  graphql_module: 0
};

var MyQuery = {
  Raw: Raw,
  query: query,
  parse: parse,
  serialize: serialize,
  serializeVariables: serializeVariables,
  makeVariables: makeVariables,
  makeDefaultVariables: makeDefaultVariables,
  Z__INTERNAL: Z__INTERNAL
};

exports.MyQuery = MyQuery;
/* query Not a pure module */
"
`;

exports[`Errors (Objects) InvalidObjectValues2.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues2.re 8:13-18
  
   6  query {
   7      invalidObjectValues(
   8          nonRec: {
   9              nullableArray: [\\"\\"]
  10              field: \\"\\"
  
  Invalid argument. The field \\"nonNullableField\\" on argument \\"nonRec\\" is missing."
`;

exports[`Errors (Objects) InvalidObjectValues3.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues3.re 9:35
  
   7  invalidObjectValues(
   8      nonRec: {
   9          nonNullableField: 5
  10          nullableArray: [\\"\\"]
  11          field: \\"\\"
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) InvalidObjectValues4.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues4.re 10:32-34
  
   8  nonRec: {
   9      nonNullableField: \\"!\\"
  10      nullableArray: [2]
  11      field: \\"\\"
  12      enum: FIRST
  
  Invalid argument. Expected \\"[String]\\" but received \\"[Int!]!\\"."
`;

exports[`Errors (Objects) InvalidObjectValues5.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues5.re 20:23-24
  
  18              otherField: \\"\\"
  19          }
  20          enum: []
  21      }
  22  )
  
  Invalid argument. Expected \\"Enum\\" but received \\"EmptyList!\\"."
`;

exports[`Errors (Objects) deprecatedFields.re 1`] = `
"File \\"operations/errors/deprecatedFields.re\\", line 7, characters 6-21:
7 |       deprecatedField
          ^^^^^^^^^^^^^^^
Warning 22: Field \\"deprecatedField\\" has been deprecated. Reason: Use something else instead"
`;

exports[`Errors (Objects) fragmentSpreadMissing.re 1`] = `
"We've found a bug for you!
  operations/errors/fragmentSpreadMissing.re 4:5-6:5
  
  2  {|
  3  query MyQuery {
  4    lists {
  5      ...MissingFragment
  6    }
  7  }
  8  |}
  
  [1;33mThe module or file MissingFragment can't be found.[0m
  - If it's a third-party dependency:
    - Did you list it in bsconfig.json?
    - Did you run \`bsb\` instead of \`bsb -make-world\`
      (latter builds third-parties)?
  - Did you include the file's directory in bsconfig.json?"
`;

exports[`Errors (Objects) fragmentSpreadMissingInFragment.re 1`] = `
"We've found a bug for you!
  operations/errors/fragmentSpreadMissingInFragment.re 5:5-22
  
  3    fragment ListFragment on Lists {
  4      nullableOfNullable
  5      ...MissingFragment
  6    }
  7  |}
  
  [1;33mThe module or file MissingFragment can't be found.[0m
  - If it's a third-party dependency:
    - Did you list it in bsconfig.json?
    - Did you run \`bsb\` instead of \`bsb -make-world\`
      (latter builds third-parties)?
  - Did you include the file's directory in bsconfig.json?"
`;

exports[`Errors (Objects) fragmentWithWrongName.re 1`] = `
"We've found a bug for you!
  operations/errors/fragmentWithWrongName.re 15:5-18:5
  
  13  {|
  14  query MyQuery {
  15    lists {
  16      ...WrongFragmentName
  17  
  18    }
  19  }
  20  |}
  
  This has type:
    [1;31m[> \`WrongFragmentName ][0m
  But somewhere wanted:
    [1;33m[ \`ListFragment ][0m
  The second variant type does not allow tag(s) \`WrongFragmentName"
`;

exports[`Errors (Objects) invalidArgVariableType1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType1.re 9:25-28
  
   7  query invalidArgValues {
   8    invalidArgValues(
   9        stringRequired: $arg
  10    )
  11  }
  
  Invalid argument. The variable \\"$arg\\" on argument \\"stringRequired\\" is missing."
`;

exports[`Errors (Objects) invalidArgVariableType2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType2.re 8:25-28
  
   6  query invalidArgValues($arg: String) {
   7    invalidArgValues(
   8        stringRequired: $arg
   9    )
  10  }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Objects) invalidArgVariableType3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType3.re 9:17-21
  
   7    invalidArgValues(
   8        stringRequired: $arg
   9        string: $arg2
  10    )
  11  }
  
  Invalid argument. Expected \\"String\\" but received \\"Int\\"."
`;

exports[`Errors (Objects) invalidArgVariableType4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType4.re 10:14-18
  
   8  invalidArgValues(
   9      custom: $arg
  10      obj: $arg2
  11      stringRequired: \\"\\"
  12  )
  
  Invalid argument. Expected \\"InputObject\\" but received \\"Int\\"."
`;

exports[`Errors (Objects) invalidArgVariableType5.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType5.re 9:25-28
  
   7    invalidArgValues(
   8        id: $arg
   9        stringRequired: $arg
  10    )
  11  }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Objects) invalidArgVariableType6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType6.re 8:15-18
  
   6  query invalidArgValues($arg: String) {
   7    invalidArgValues(
   8        list: $arg
   9        stringRequired: \\"\\"
  10    )
  
  Invalid argument. Expected \\"[String]\\" but received \\"String\\"."
`;

exports[`Errors (Objects) invalidDefaultValue1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue1.re 21:14-26
  
  19  query invalidDefaultValues {
  20    invalidDefaultValues(
  21        int: \\"Some string\\"
  22    )
  23  }
  
  Invalid argument. Expected \\"Int\\" but received \\"String!\\"."
`;

exports[`Errors (Objects) invalidDefaultValue2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue2.re 8:14-26
  
   6  query invalidDefaultValues {
   7    invalidDefaultValues(
   8        int: {test: \\"xxx\\"}
   9    )
  10  }
  
  Invalid argument. Expected \\"Int\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Objects) invalidDefaultValue3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue3.re 21:13
  
  19  query invalidDefaultValues {
  20    invalidDefaultValues(
  21        id: 5
  22    )
  23  }
  
  Invalid argument. Expected \\"ID\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) invalidDefaultValue4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue4.re 8:17-26
  
   6  query invalidDefaultValues {
   7    invalidDefaultValues(
   8        string: [\\"1\\", \\"2\\"]
   9    )
  10  }
  
  Invalid argument. Expected \\"String\\" but received \\"List\\"."
`;

exports[`Errors (Objects) invalidObjectValues1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues1.re 19:37
  
  17      otherField: \\"\\"
  18      inner: {
  19          otherField: 5
  20      }
  21  }
  
  Invalid argument. Expected \\"String\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) invalidObjectValues6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues6.re 20:27-37
  
  18  query {
  19      invalidObjectValuesLst(
  20          embeddedList: {field: \\"\\"}
  21      )
  22  }
  
  Invalid argument. Expected \\"[InputObject]!\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Objects) invalidObjectValues7.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues7.re 20:36
  
  18  query {
  19      invalidObjectValuesLst(
  20          embeddedList: [{field: 5}]
  21      )
  22  }
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Objects) missingField1.re 1`] = `
"File \\"operations/errors/missingField1.re\\", line 6, characters 6-27:
6 |       thisFieldDoesNotExist
          ^^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisFieldDoesNotExist' on type CustomScalarObject

  We've found a bug for you!
  operations/errors/missingField1.re"
`;

exports[`Errors (Objects) missingField2.re 1`] = `
"File \\"operations/errors/missingField2.re\\", line 13, characters 8-28:
13 |     l1: thisTypeDoesNotExist {
             ^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisTypeDoesNotExist' on type Query

  We've found a bug for you!
  operations/errors/missingField2.re"
`;

exports[`Errors (Objects) missingField3.re 1`] = `
"File \\"operations/errors/missingField3.re\\", line 15, characters 6-18:
15 |       doesNotExist
           ^^^^^^^^^^^^
Error: Unknown field 'doesNotExist' on type Lists

  We've found a bug for you!
  operations/errors/missingField3.re"
`;

exports[`Errors (Objects) missingFragment.re 1`] = `
"We've found a bug for you!
  operations/errors/missingFragment.re 3:28-42
  
  1  module Fragment = [%graphql
  2    {|
  3    fragment ListFragment on UnknownFragment {
  4      nullableOfNullable
  5      nullableOfNonNullable
  
  Unknown type \\"UnknownFragment\\""
`;

exports[`Errors (Objects) wrongArguments.re 1`] = `
"We've found a bug for you!
  (No file name)
  
  [1;33mThis call is missing an argument[0m of type (~arg1: [ \`String ])"
`;

exports[`Errors (Records) InvalidObjectValues2.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues2.re 8:13-18
  
   6  query {
   7      invalidObjectValues(
   8          nonRec: {
   9              nullableArray: [\\"\\"]
  10              field: \\"\\"
  
  Invalid argument. The field \\"nonNullableField\\" on argument \\"nonRec\\" is missing."
`;

exports[`Errors (Records) InvalidObjectValues3.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues3.re 9:35
  
   7  invalidObjectValues(
   8      nonRec: {
   9          nonNullableField: 5
  10          nullableArray: [\\"\\"]
  11          field: \\"\\"
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) InvalidObjectValues4.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues4.re 10:32-34
  
   8  nonRec: {
   9      nonNullableField: \\"!\\"
  10      nullableArray: [2]
  11      field: \\"\\"
  12      enum: FIRST
  
  Invalid argument. Expected \\"[String]\\" but received \\"[Int!]!\\"."
`;

exports[`Errors (Records) InvalidObjectValues5.re 1`] = `
"We've found a bug for you!
  operations/errors/InvalidObjectValues5.re 20:23-24
  
  18              otherField: \\"\\"
  19          }
  20          enum: []
  21      }
  22  )
  
  Invalid argument. Expected \\"Enum\\" but received \\"EmptyList!\\"."
`;

exports[`Errors (Records) deprecatedFields.re 1`] = `
"File \\"operations/errors/deprecatedFields.re\\", line 7, characters 6-21:
7 |       deprecatedField
          ^^^^^^^^^^^^^^^
Warning 22: Field \\"deprecatedField\\" has been deprecated. Reason: Use something else instead"
`;

exports[`Errors (Records) fragmentSpreadMissing.re 1`] = `
"We've found a bug for you!
  operations/errors/fragmentSpreadMissing.re 4:5-6:5
  
  2  {|
  3  query MyQuery {
  4    lists {
  5      ...MissingFragment
  6    }
  7  }
  8  |}
  
  [1;33mThe module or file MissingFragment can't be found.[0m
  - If it's a third-party dependency:
    - Did you list it in bsconfig.json?
    - Did you run \`bsb\` instead of \`bsb -make-world\`
      (latter builds third-parties)?
  - Did you include the file's directory in bsconfig.json?"
`;

exports[`Errors (Records) fragmentSpreadMissingInFragment.re 1`] = `
"We've found a bug for you!
  operations/errors/fragmentSpreadMissingInFragment.re 5:5-22
  
  3    fragment ListFragment on Lists {
  4      nullableOfNullable
  5      ...MissingFragment
  6    }
  7  |}
  
  [1;33mThe module or file MissingFragment can't be found.[0m
  - If it's a third-party dependency:
    - Did you list it in bsconfig.json?
    - Did you run \`bsb\` instead of \`bsb -make-world\`
      (latter builds third-parties)?
  - Did you include the file's directory in bsconfig.json?"
`;

exports[`Errors (Records) fragmentWithWrongName.re 1`] = `
"We've found a bug for you!
  operations/errors/fragmentWithWrongName.re 15:5-18:5
  
  13  {|
  14  query MyQuery {
  15    lists {
  16      ...WrongFragmentName
  17  
  18    }
  19  }
  20  |}
  
  This has type:
    [1;31m[> \`WrongFragmentName ][0m
  But somewhere wanted:
    [1;33m[ \`ListFragment ][0m
  The second variant type does not allow tag(s) \`WrongFragmentName"
`;

exports[`Errors (Records) invalidArgVariableType1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType1.re 9:25-28
  
   7  query invalidArgValues {
   8    invalidArgValues(
   9        stringRequired: $arg
  10    )
  11  }
  
  Invalid argument. The variable \\"$arg\\" on argument \\"stringRequired\\" is missing."
`;

exports[`Errors (Records) invalidArgVariableType2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType2.re 8:25-28
  
   6  query invalidArgValues($arg: String) {
   7    invalidArgValues(
   8        stringRequired: $arg
   9    )
  10  }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Records) invalidArgVariableType3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType3.re 9:17-21
  
   7    invalidArgValues(
   8        stringRequired: $arg
   9        string: $arg2
  10    )
  11  }
  
  Invalid argument. Expected \\"String\\" but received \\"Int\\"."
`;

exports[`Errors (Records) invalidArgVariableType4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType4.re 10:14-18
  
   8  invalidArgValues(
   9      custom: $arg
  10      obj: $arg2
  11      stringRequired: \\"\\"
  12  )
  
  Invalid argument. Expected \\"InputObject\\" but received \\"Int\\"."
`;

exports[`Errors (Records) invalidArgVariableType5.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType5.re 9:25-28
  
   7    invalidArgValues(
   8        id: $arg
   9        stringRequired: $arg
  10    )
  11  }
  
  Invalid argument. Trying to apply the nullable variable \\"$arg\\" to the required argument \\"stringRequired\\"."
`;

exports[`Errors (Records) invalidArgVariableType6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidArgVariableType6.re 8:15-18
  
   6  query invalidArgValues($arg: String) {
   7    invalidArgValues(
   8        list: $arg
   9        stringRequired: \\"\\"
  10    )
  
  Invalid argument. Expected \\"[String]\\" but received \\"String\\"."
`;

exports[`Errors (Records) invalidDefaultValue1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue1.re 21:14-26
  
  19  query invalidDefaultValues {
  20    invalidDefaultValues(
  21        int: \\"Some string\\"
  22    )
  23  }
  
  Invalid argument. Expected \\"Int\\" but received \\"String!\\"."
`;

exports[`Errors (Records) invalidDefaultValue2.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue2.re 8:14-26
  
   6  query invalidDefaultValues {
   7    invalidDefaultValues(
   8        int: {test: \\"xxx\\"}
   9    )
  10  }
  
  Invalid argument. Expected \\"Int\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Records) invalidDefaultValue3.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue3.re 21:13
  
  19  query invalidDefaultValues {
  20    invalidDefaultValues(
  21        id: 5
  22    )
  23  }
  
  Invalid argument. Expected \\"ID\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) invalidDefaultValue4.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidDefaultValue4.re 8:17-26
  
   6  query invalidDefaultValues {
   7    invalidDefaultValues(
   8        string: [\\"1\\", \\"2\\"]
   9    )
  10  }
  
  Invalid argument. Expected \\"String\\" but received \\"List\\"."
`;

exports[`Errors (Records) invalidObjectValues1.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues1.re 19:37
  
  17      otherField: \\"\\"
  18      inner: {
  19          otherField: 5
  20      }
  21  }
  
  Invalid argument. Expected \\"String\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) invalidObjectValues6.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues6.re 20:27-37
  
  18  query {
  19      invalidObjectValuesLst(
  20          embeddedList: {field: \\"\\"}
  21      )
  22  }
  
  Invalid argument. Expected \\"[InputObject]!\\" but received \\"InputObject!\\"."
`;

exports[`Errors (Records) invalidObjectValues7.re 1`] = `
"We've found a bug for you!
  operations/errors/invalidObjectValues7.re 20:36
  
  18  query {
  19      invalidObjectValuesLst(
  20          embeddedList: [{field: 5}]
  21      )
  22  }
  
  Invalid argument. Expected \\"String!\\" but received \\"Int!\\"."
`;

exports[`Errors (Records) missingField1.re 1`] = `
"File \\"operations/errors/missingField1.re\\", line 6, characters 6-27:
6 |       thisFieldDoesNotExist
          ^^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisFieldDoesNotExist' on type CustomScalarObject

  We've found a bug for you!
  operations/errors/missingField1.re"
`;

exports[`Errors (Records) missingField2.re 1`] = `
"File \\"operations/errors/missingField2.re\\", line 13, characters 8-28:
13 |     l1: thisTypeDoesNotExist {
             ^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisTypeDoesNotExist' on type Query

  We've found a bug for you!
  operations/errors/missingField2.re"
`;

exports[`Errors (Records) missingField3.re 1`] = `
"File \\"operations/errors/missingField3.re\\", line 15, characters 6-18:
15 |       doesNotExist
           ^^^^^^^^^^^^
Error: Unknown field 'doesNotExist' on type Lists

  We've found a bug for you!
  operations/errors/missingField3.re"
`;

exports[`Errors (Records) missingFragment.re 1`] = `
"We've found a bug for you!
  operations/errors/missingFragment.re 3:28-42
  
  1  module Fragment = [%graphql
  2    {|
  3    fragment ListFragment on UnknownFragment {
  4      nullableOfNullable
  5      nullableOfNonNullable
  
  Unknown type \\"UnknownFragment\\""
`;

exports[`Errors (Records) wrongArguments.re 1`] = `
"We've found a bug for you!
  operations/errors/wrongArguments.re 14:7-25
  
  12    lists {
  13      nonNullableOfNullable
  14      ...FragmentWithArgs
  15    }
  16  }
  
  [1;33mThis call is missing an argument[0m of type (~arg1: [ \`String ])"
`;

exports[`Legacy argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
    type t_variables = {. \\"query\\": int};
  };
  type t = {. \\"argNamedQuery\\": int};
  /**The GraphQL query string*/
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t_variables = {. \\"query\\": int};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let argNamedQuery = {
      let value = value##argNamedQuery;
      value;
    };
    {\\"argNamedQuery\\": argNamedQuery};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let argNamedQuery = {
      let value = value##argNamedQuery;
      value;
    };
    {\\"argNamedQuery\\": argNamedQuery};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"query\\": (a => a)(inp##query)};
  let make = (~query, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"query\\": query}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~query, ()) =>
    serializeVariables({\\"query\\": query}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MultipleQueryWithSameVarName = {
  module Query1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {. \\"argNamedQuery\\": int};
      type t_variables = {. \\"query\\": int};
    };
    type t = {. \\"argNamedQuery\\": int};
    /**The GraphQL query string*/
    let query = \\"query Query1($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {. \\"query\\": int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {\\"query\\": (a => a)(inp##query)};
    let make = (~query, ()) => {
      \\"query\\": query,
      \\"variables\\": serializeVariables({\\"query\\": query}: t_variables),
      \\"parse\\": parse,
    }
    and makeVariables = (~query, ()) =>
      serializeVariables({\\"query\\": query}: t_variables);
    let makeWithVariables = variables => {
      \\"query\\": query,
      \\"variables\\": serializeVariables(variables),
      \\"parse\\": parse,
    };
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Query2 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {. \\"argNamedQuery\\": int};
      type t_variables = {. \\"query\\": int};
    };
    type t = {. \\"argNamedQuery\\": int};
    /**The GraphQL query string*/
    let query = \\"query Query2($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {. \\"query\\": int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {\\"query\\": (a => a)(inp##query)};
    let make = (~query, ()) => {
      \\"query\\": query,
      \\"variables\\": serializeVariables({\\"query\\": query}: t_variables),
      \\"parse\\": parse,
    }
    and makeVariables = (~query, ()) =>
      serializeVariables({\\"query\\": query}: t_variables);
    let makeWithVariables = variables => {
      \\"query\\": query,
      \\"variables\\": serializeVariables(variables),
      \\"parse\\": parse,
    };
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Legacy comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  type t = {. \\"nonrecursiveInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let int = {
        let value = value##int;
        StringOfInt.parse(value);
      }
      and string = {
        let value = value##string;
        IntOfString.parse(value);
      };
      {\\"string\\": string, \\"int\\": int};
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let int = {
        let value = value##int;
        StringOfInt.serialize(value);
      }
      and string = {
        let value = value##string;
        IntOfString.serialize(value);
      };
      {\\"string\\": string, \\"int\\": int};
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
    type t = {. \\"customScalarField\\": t_customScalarField};
    type t_variables = {
      .
      \\"opt\\": Js.Nullable.t(Js.Json.t),
      \\"req\\": Js.Json.t,
    };
  };
  type t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t = {. \\"customScalarField\\": t_customScalarField};
  /**The GraphQL query string*/
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let customScalarField = {
      let value = value##customScalarField;
      let nonNullable = {
        let value = value##nonNullable;
        value;
      }
      and nullable = {
        let value = value##nullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
    };
    {\\"customScalarField\\": customScalarField};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let customScalarField = {
      let value = value##customScalarField;
      let nonNullable = {
        let value = value##nonNullable;
        value;
      }
      and nullable = {
        let value = value##nullable;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
    };
    {\\"customScalarField\\": customScalarField};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"opt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##opt,
        ),
      \\"req\\": (a => a)(inp##req),
    };
  let make = (~opt=?, ~req, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"opt\\": opt, \\"req\\": req}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({\\"opt\\": opt, \\"req\\": req}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customFields = {
      .
      \\"currentTime\\": Js.Json.t,
      \\"favoriteColor\\": Js.Json.t,
      \\"futureTime\\": Js.Nullable.t(Js.Json.t),
      \\"nullableColor\\": Js.Nullable.t(Js.Json.t),
    };
    type t = {. \\"customFields\\": t_customFields};
    type t_variables = unit;
  };
  type t_customFields = {
    .
    \\"currentTime\\": DateTime.t,
    \\"favoriteColor\\": Color.t,
    \\"futureTime\\": option(DateTime.t),
    \\"nullableColor\\": option(Color.t),
  };
  type t = {. \\"customFields\\": t_customFields};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let customFields = {
      let value = value##customFields;
      let nullableColor = {
        let value = value##nullableColor;
        switch (Js.toOption(value)) {
        | Some(value) => Some(Color.parse(value))
        | None => None
        };
      }
      and futureTime = {
        let value = value##futureTime;
        switch (Js.toOption(value)) {
        | Some(value) => Some(DateTime.parse(value))
        | None => None
        };
      }
      and favoriteColor = {
        let value = value##favoriteColor;
        Color.parse(value);
      }
      and currentTime = {
        let value = value##currentTime;
        DateTime.parse(value);
      };
      {
        \\"currentTime\\": currentTime,
        \\"favoriteColor\\": favoriteColor,
        \\"futureTime\\": futureTime,
        \\"nullableColor\\": nullableColor,
      };
    };
    {\\"customFields\\": customFields};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let customFields = {
      let value = value##customFields;
      let nullableColor = {
        let value = value##nullableColor;
        switch (value) {
        | Some(value) => Js.Nullable.return(Color.serialize(value))
        | None => Js.Nullable.null
        };
      }
      and futureTime = {
        let value = value##futureTime;
        switch (value) {
        | Some(value) => Js.Nullable.return(DateTime.serialize(value))
        | None => Js.Nullable.null
        };
      }
      and favoriteColor = {
        let value = value##favoriteColor;
        Color.serialize(value);
      }
      and currentTime = {
        let value = value##currentTime;
        DateTime.serialize(value);
      };
      {
        \\"currentTime\\": currentTime,
        \\"favoriteColor\\": favoriteColor,
        \\"futureTime\\": futureTime,
        \\"nullableColor\\": nullableColor,
      };
    };
    {\\"customFields\\": customFields};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"defaultObjectValueOnScalar\\": string};
    type t_variables = unit;
  };
  type t = {. \\"defaultObjectValueOnScalar\\": string};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let defaultObjectValueOnScalar = {
      let value = value##defaultObjectValueOnScalar;
      value;
    };
    {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let defaultObjectValueOnScalar = {
      let value = value##defaultObjectValueOnScalar;
      value;
    };
    {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"enumInput\\": string};
    type t_variables = {. \\"arg\\": string};
  };
  type t = {. \\"enumInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let enumInput = {
      let value = value##enumInput;
      value;
    };
    {\\"enumInput\\": enumInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let enumInput = {
      let value = value##enumInput;
      value;
    };
    {\\"enumInput\\": enumInput};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\":
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          inp##arg,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module Parent = {
  module ExtendQuery = (M: GraphQLQuery) => {
    let use = () => ();
  };
};
module Bla = {
  module Inner = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_lists = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
        \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
        \\"nonNullableOfNonNullable\\": array(string),
      };
      type t = {. \\"lists\\": t_lists};
      type t_variables = unit;
    };
    type t_lists = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
      \\"nonNullableOfNullable\\": array(option(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    /**The GraphQL query string*/
    let query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    let make = () => {
      \\"query\\": query,
      \\"variables\\": Js.Json.null,
      \\"parse\\": parse,
    };
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  include Inner;
  include Parent.ExtendQuery(Inner);
};
module Inner = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query Bla2  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
include Inner;
include Parent.ExtendQuery(Inner);
"
`;

exports[`Legacy fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (Js.toOption(value)) {
      | Some(value) => Some(value |> Js.Array.map(value => value))
      | None => None
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(value |> Js.Array.map(value => value))
      | None => Js.Nullable.null
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
    type nonrec t_Lists = t;
  };
  type t = {. \\"nullableOfNonNullable\\": option(array(string))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (Js.toOption(value)) {
      | Some(value) => Some(value |> Js.Array.map(value => value))
      | None => None
      };
    };
    {\\"nullableOfNonNullable\\": nullableOfNonNullable};
  };

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(value |> Js.Array.map(value => value))
      | None => Js.Nullable.null
      };
    };
    {\\"nullableOfNonNullable\\": nullableOfNonNullable};
  };
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module FragmentWithArgs = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"listWithArg\\": Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {. \\"listWithArg\\": option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment FragmentWithArgs on Lists   {\\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listWithArg = {
      let value = value##listWithArg;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {\\"listWithArg\\": listWithArg};
  };

  let verifyArgsAndParse =
      (
        ~arg1 as _arg1: [ | \`String],
        ~fragmentName as _FragmentWithArgs: [ | \`FragmentWithArgs],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let listWithArg = {
      let value = value##listWithArg;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {\\"listWithArg\\": listWithArg};
  };
  let verifyName =
    fun
    | \`FragmentWithArgs => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module InlineListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment InlineListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (Js.toOption(value)) {
      | Some(value) => Some(value |> Js.Array.map(value => value))
      | None => None
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };

  let verifyArgsAndParse =
      (
        ~fragmentName as _InlineListFragment: [ | \`InlineListFragment],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(value |> Js.Array.map(value => value))
      | None => Js.Nullable.null
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };
  let verifyName =
    fun
    | \`InlineListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      .
      \\"l1\\": ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
      \\"l5\\": FragmentWithArgs.Raw.t,
    };
    type t_variables = {. \\"arg1\\": Js.Nullable.t(string)};
  };
  type t_l2 = {
    .
    \\"frag1\\": ListFragment.t_Lists,
    \\"frag2\\": ListFragment.t_Lists,
  };
  type t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": ListFragment.t_Lists,
    \\"frag2\\": ListFragment.t_Lists,
  };
  type t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"inlineListFragment\\": InlineListFragment.t_Lists,
  };
  type t = {
    .
    \\"l1\\": ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
    \\"l5\\": FragmentWithArgs.t,
  };
  /**The GraphQL query string*/
  let query =
    (
      (
        \\"query MyQuery($arg1: String)  {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...InlineListFragment   \\\\n}\\\\n\\\\nl5: lists  {\\\\n...FragmentWithArgs   \\\\n}\\\\n\\\\n}\\\\n\\"
        ++ FragmentWithArgs.query
      )
      ++ InlineListFragment.query
    )
    ++ ListFragment.query;
  type t_variables = {. \\"arg1\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let l5 = {
      let value = value##l5;

      FragmentWithArgs.verifyArgsAndParse(
        ~arg1=\`String,
        ~fragmentName=\`FragmentWithArgs,
        value,
      );
    }
    and l4 = {
      let value = value##l4;
      let inlineListFragment = {
        let value: InlineListFragment.Raw.t = Obj.magic(value);

        InlineListFragment.verifyArgsAndParse(
          ~fragmentName=\`InlineListFragment,
          value,
        );
      }
      and nullableOfNullable = {
        let value =
          Obj.magic(
            Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
          );
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"inlineListFragment\\": inlineListFragment,
      };
    }
    and l3 = {
      let value = value##l3;
      let frag2 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      }
      and frag1 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      }
      and nullableOfNullable = {
        let value =
          Obj.magic(
            Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
          );
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"frag1\\": frag1,
        \\"frag2\\": frag2,
      };
    }
    and l2 = {
      let value = value##l2;
      let frag2 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      }
      and frag1 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      };
      {\\"frag1\\": frag1, \\"frag2\\": frag2};
    }
    and l1 = {
      let value = value##l1;

      ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
    };
    {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4, \\"l5\\": l5};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let l5 = {
      let value = value##l5;
      FragmentWithArgs.serialize(value);
    }
    and l4 = {
      let value = value##l4;
      (
        Obj.magic(
          Js.Array.reduce(
            GraphQL_PPX.deepMerge,
            Obj.magic(
              {
                let nullableOfNullable = {
                  let value = value##nullableOfNullable;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      value
                      |> Js.Array.map(value =>
                           switch (value) {
                           | Some(value) => Js.Nullable.return(value)
                           | None => Js.Nullable.null
                           }
                         ),
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"nullableOfNullable\\": nullableOfNullable};
              },
            ): Js.Json.t,
            [|
              (
                Obj.magic(
                  InlineListFragment.serialize(value##inlineListFragment),
                ): Js.Json.t
              ),
            |],
          ),
        ): Raw.t_l4
      );
    }
    and l3 = {
      let value = value##l3;
      (
        Obj.magic(
          Js.Array.reduce(
            GraphQL_PPX.deepMerge,
            Obj.magic(
              {
                let nullableOfNullable = {
                  let value = value##nullableOfNullable;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      value
                      |> Js.Array.map(value =>
                           switch (value) {
                           | Some(value) => Js.Nullable.return(value)
                           | None => Js.Nullable.null
                           }
                         ),
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"nullableOfNullable\\": nullableOfNullable};
              },
            ): Js.Json.t,
            [|
              (Obj.magic(ListFragment.serialize(value##frag1)): Js.Json.t),
              (Obj.magic(ListFragment.serialize(value##frag2)): Js.Json.t),
            |],
          ),
        ): Raw.t_l3
      );
    }
    and l2 = {
      let value = value##l2;
      (
        Obj.magic(
          Js.Array.reduce(
            GraphQL_PPX.deepMerge,
            Obj.magic(Js.Dict.empty): Js.Json.t,
            [|
              (Obj.magic(ListFragment.serialize(value##frag1)): Js.Json.t),
              (Obj.magic(ListFragment.serialize(value##frag2)): Js.Json.t),
            |],
          ),
        ): Raw.t_l2
      );
    }
    and l1 = {
      let value = value##l1;
      ListFragment.serialize(value);
    };
    {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4, \\"l5\\": l5};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg1\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##arg1,
        ),
    };
  let make = (~arg1=?, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg1\\": arg1}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg1=?, ()) =>
    serializeVariables({\\"arg1\\": arg1}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"lists\\": ListFragment.Raw.t};
    type t_variables = unit;
  };
  type t = {. \\"lists\\": ListFragment.t};
  /**The GraphQL query string*/
  let query =
    \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\n\\" ++ ListFragment.query;
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;

      ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      ListFragment.serialize(value);
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy fragmentInFragment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {. \\"nullableOfNullable\\": option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {\\"nullableOfNullable\\": nullableOfNullable};
  };

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {\\"nullableOfNullable\\": nullableOfNullable};
  };
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t;
    type nonrec t_Lists = t;
  };
  type t = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": ListFragment.t_Lists,
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query =
    \\"fragment Another on Lists   {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\n\\"
    ++ ListFragment.query;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listFragment = {
      let value: ListFragment.Raw.t = Obj.magic(value);

      ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
    }
    and nullableOfNullable = {
      let value =
        Obj.magic(
          Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
        );
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {\\"nullableOfNullable\\": nullableOfNullable, \\"listFragment\\": listFragment};
  };

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    Obj.magic(
      Js.Array.reduce(
        GraphQL_PPX.deepMerge,
        Obj.magic(
          {
            let nullableOfNullable = {
              let value = value##nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {\\"nullableOfNullable\\": nullableOfNullable};
          },
        ): Js.Json.t,
        [|
          (
            Obj.magic(ListFragment.serialize(value##listFragment)): Js.Json.t
          ),
        |],
      ),
    ): Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Legacy lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  type t = {. \\"listsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let make =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_ListsInput}
    and t_variables_ListsInput = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  type t = {. \\"listsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectListsInput(a))(inp##arg)}
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    \\"nullableOfNullable\\": nullableOfNullable,
    \\"nullableOfNonNullable\\": nullableOfNonNullable,
    \\"nonNullableOfNullable\\": nonNullableOfNullable,
    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_value = {. \\"stringField\\": string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    };
    type t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_value = {. \\"stringField\\": string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  };
  type t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let message = {
                   let value = value##message;
                   value;
                 }
                 and field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | other => \`FutureAddedValue(other)
                   };
                 };
                 {\\"field\\": field, \\"message\\": message};
               ),
          )
        | None => None
        };
      }
      and value = {
        let value = value##value;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let stringField = {
                let value = value##stringField;
                value;
              };
              {\\"stringField\\": stringField};
            },
          )
        | None => None
        };
      };
      {\\"value\\": value, \\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let message = {
                   let value = value##message;
                   value;
                 }
                 and field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   | \`FutureAddedValue(other) => other
                   };
                 };
                 {\\"field\\": field, \\"message\\": message};
               ),
          )
        | None => Js.Nullable.null
        };
      }
      and value = {
        let value = value##value;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let stringField = {
                let value = value##stringField;
                value;
              };
              {\\"stringField\\": stringField};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"value\\": value, \\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  type t = {. \\"optionalInputArgs\\": string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {. \\"required\\": string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let make = (~required, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"required\\": required}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  type t = {. \\"optionalInputArgs\\": string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {. \\"required\\": string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let make = (~required, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"required\\": required}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {. \\"field\\": string};
    type t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)};
    type t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      .
      \\"f1\\": string,
      \\"f2\\": string,
    };
    type t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)};
    type t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {. \\"field\\": string};
    type t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)};
    type t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)};
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    };
    type t_variables = unit;
  };
  type t_first_inner_inner = {. \\"field\\": string};
  type t_first_inner = {. \\"inner\\": option(t_first_inner_inner)};
  type t_first = {. \\"inner\\": option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {. \\"inner\\": option(t_second_inner_inner)};
  type t_second = {. \\"inner\\": option(t_second_inner)};
  type t_let_inner_inner = {. \\"field\\": string};
  type t_let_inner = {. \\"inner\\": option(t_let_inner_inner)};
  type t_let = {. \\"inner\\": option(t_let_inner)};
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  };
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let let_ = {
      let value = value##let_;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => None
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => None
        };
      };
      {\\"inner\\": inner};
    }
    and second = {
      let value = value##second;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let f2 = {
                        let value = value##f2;
                        value;
                      }
                      and f1 = {
                        let value = value##f1;
                        value;
                      };
                      {f1, f2};
                    }: t_second_inner_inner,
                  )
                | None => None
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => None
        };
      };
      {\\"inner\\": inner};
    }
    and first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => None
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => None
        };
      };
      {\\"inner\\": inner};
    };
    {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let let_ = {
      let value = value##let_;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => Js.Nullable.null
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"inner\\": inner};
    }
    and second = {
      let value = value##second;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let f2 = {
                        let value = (value: t_second_inner_inner).f2;
                        value;
                      }
                      and f1 = {
                        let value = (value: t_second_inner_inner).f1;
                        value;
                      };
                      {\\"f1\\": f1, \\"f2\\": f2};
                    },
                  )
                | None => Js.Nullable.null
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"inner\\": inner};
    }
    and first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => Js.Nullable.null
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"inner\\": inner};
    };
    {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  type t = {. \\"nonrecursiveInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"scalarsInput\\": string,
      \\"more\\": string,
    };
    type t_variables = {
      .
      \\"arg\\": t_variables_NonrecursiveInput,
      \\"arg2\\": t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  type t = {
    .
    \\"scalarsInput\\": string,
    \\"more\\": string,
  };
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"arg\\": t_variables_NonrecursiveInput,
    \\"arg2\\": t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let more = {
      let value = value##more;
      value;
    }
    and scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let more = {
      let value = value##more;
      value;
    }
    and scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
      \\"arg2\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg2),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ~arg2, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg, \\"arg2\\": arg2}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({\\"arg\\": arg, \\"arg2\\": arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | other => \`FutureAddedValue(other)
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => None
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   | \`FutureAddedValue(other) => other
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | _ => raise(Not_found)
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => None
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | _ => raise(Not_found)
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => None
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => raise(Not_found)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => raise(Not_found)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = unit;
  };
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let pokemon = {
      let value = value##pokemon;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          {
            let name = {
              let value = value##name;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => None
      };
    };
    {\\"pokemon\\": pokemon};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let pokemon = {
      let value = value##pokemon;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          {
            let name = {
              let value = value##name;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => Js.Nullable.null
      };
    };
    {\\"pokemon\\": pokemon};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = {
      .
      \\"id\\": Js.Nullable.t(string),
      \\"name\\": Js.Nullable.t(string),
    };
  };
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let pokemon = {
      let value = value##pokemon;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          {
            let name = {
              let value = value##name;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => None
      };
    };
    {\\"pokemon\\": pokemon};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let pokemon = {
      let value = value##pokemon;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          {
            let name = {
              let value = value##name;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => Js.Nullable.null
      };
    };
    {\\"pokemon\\": pokemon};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"id\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##id,
        ),
      \\"name\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##name,
        ),
    };
  let make = (~id=?, ~name=?, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"id\\": id, \\"name\\": name}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({\\"id\\": id, \\"name\\": name}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t = {. \\"variousScalars\\": scalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      (
        {
          let int = {
            let value = value##int;
            value;
          }
          and string = {
            let value = value##string;
            value;
          };
          {string, int};
        }: scalars
      );
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let int = {
        let value = (value: scalars).int;
        value;
      }
      and string = {
        let value = (value: scalars).string;
        value;
      };
      {\\"string\\": string, \\"int\\": int};
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {. \\"nullableString\\": Js.Nullable.t(string)};
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {nullableString: option(string)};
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      (
        {
          let nullableString = {
            let value = value##nullableString;
            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          };
          {nullableString: nullableString};
        }: t_variousScalars
      );
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let nullableString = {
        let value = (value: t_variousScalars).nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullableString\\": nullableString};
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        .
        \\"string\\": string,
        \\"int\\": int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    /**The GraphQL query string*/
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        let int = {
          let value = value##int;
          value;
        }
        and string = {
          let value = value##string;
          value;
        };
        {string, int};
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _Fragment: [ | \`Fragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let int = {
        let value = (value: t).int;
        value;
      }
      and string = {
        let value = (value: t).string;
        value;
      };
      {\\"string\\": string, \\"int\\": int};
    };
    let verifyName =
      fun
      | \`Fragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
      type t_variables = unit;
    };
    type t = {. \\"variousScalars\\": Fragment.t};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\n\\"
      ++ Fragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let variousScalars = {
        let value = value##variousScalars;

        Fragment.verifyArgsAndParse(~fragmentName=\`Fragment, value);
      };
      {\\"variousScalars\\": variousScalars};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let variousScalars = {
        let value = value##variousScalars;
        Fragment.serialize(value);
      };
      {\\"variousScalars\\": variousScalars};
    };
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    let make = () => {
      \\"query\\": query,
      \\"variables\\": Js.Json.null,
      \\"parse\\": parse,
    };
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              (
                {
                  let barkVolume = {
                    let value = value##barkVolume;
                    value;
                  }
                  and name = {
                    let value = value##name;
                    value;
                  };
                  {name, barkVolume};
                }: t_dogOrHuman_Dog
              );
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = (value: t_dogOrHuman_Dog).barkVolume;
                value;
              }
              and name = {
                let value = (value: t_dogOrHuman_Dog).name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        .
        \\"name\\": string,
        \\"barkVolume\\": float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    /**The GraphQL query string*/
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        let barkVolume = {
          let value = value##barkVolume;
          value;
        }
        and name = {
          let value = value##name;
          value;
        };
        {name, barkVolume};
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _DogFragment: [ | \`DogFragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let barkVolume = {
        let value = (value: t).barkVolume;
        value;
      }
      and name = {
        let value = (value: t).name;
        value;
      };
      {\\"name\\": name, \\"barkVolume\\": barkVolume};
    };
    let verifyName =
      fun
      | \`DogFragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_dogOrHuman;
      type t = {. \\"dogOrHuman\\": t_dogOrHuman};
      type t_variables = unit;
    };
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      ++ DogFragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: DogFragment.Raw.t = Obj.magic(value);

                DogFragment.verifyArgsAndParse(
                  ~fragmentName=\`DogFragment,
                  value,
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    let make = () => {
      \\"query\\": query,
      \\"variables\\": Js.Json.null,
      \\"parse\\": parse,
    };
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Legacy recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      .
      \\"otherField\\": Js.Nullable.t(string),
      \\"inner\\": Js.Nullable.t(t_variables_RecursiveInput),
      \\"enum\\": Js.Nullable.t(string),
    };
  };
  type t = {. \\"recursiveInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let recursiveInput = {
      let value = value##recursiveInput;
      value;
    };
    {\\"recursiveInput\\": recursiveInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let recursiveInput = {
      let value = value##recursiveInput;
      value;
    };
    {\\"recursiveInput\\": recursiveInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectRecursiveInput(a))(inp##arg)}
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      \\"otherField\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##otherField,
        ),
      \\"inner\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          inp##inner,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    \\"otherField\\": otherField,
    \\"inner\\": inner,
    \\"enum\\": enum,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  type t = {. \\"scalarsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let make =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {
          \\"nullableString\\": nullableString,
          \\"string\\": string,
          \\"nullableInt\\": nullableInt,
          \\"int\\": int,
          \\"nullableFloat\\": nullableFloat,
          \\"float\\": float,
          \\"nullableBoolean\\": nullableBoolean,
          \\"boolean\\": boolean,
          \\"nullableID\\": nullableID,
          \\"id\\": id,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  type t = {. \\"scalarsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectVariousScalarsInput(a))(inp##arg),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"arg\\": arg}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    \\"nullableString\\": nullableString,
    \\"string\\": string,
    \\"nullableInt\\": nullableInt,
    \\"int\\": int,
    \\"nullableFloat\\": nullableFloat,
    \\"float\\": float,
    \\"nullableBoolean\\": nullableBoolean,
    \\"boolean\\": boolean,
    \\"nullableID\\": nullableID,
    \\"id\\": id,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    };
    type t_variables = {. \\"var\\": bool};
  };
  type t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  };
  /**The GraphQL query string*/
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {. \\"var\\": bool};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let v2 = {
      let value = value##v2;
      let string = {
        let value = value##string;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    }
    and v1 = {
      let value = value##v1;
      let string = {
        let value = value##string;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    };
    {\\"v1\\": v1, \\"v2\\": v2};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let v2 = {
      let value = value##v2;
      let string = {
        let value = value##string;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    }
    and v1 = {
      let value = value##v1;
      let string = {
        let value = value##string;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    };
    {\\"v1\\": v1, \\"v2\\": v2};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"var\\": (a => a)(inp##var)};
  let make = (~var, ()) => {
    \\"query\\": query,
    \\"variables\\": serializeVariables({\\"var\\": var}: t_variables),
    \\"parse\\": parse,
  }
  and makeVariables = (~var, ()) =>
    serializeVariables({\\"var\\": var}: t_variables);
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_simpleSubscription_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription;
    type t = {. \\"simpleSubscription\\": t_simpleSubscription};
    type t_variables = unit;
  };
  type t_simpleSubscription_Dog = {. \\"name\\": string};
  type t_simpleSubscription_Human = {. \\"name\\": string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  /**The GraphQL query string*/
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let simpleSubscription = {
      let value = value##simpleSubscription;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_simpleSubscription
      );
    };
    {\\"simpleSubscription\\": simpleSubscription};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let simpleSubscription = {
      let value = value##simpleSubscription;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name};
            },
          ): Raw.t_simpleSubscription
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_simpleSubscription
        )
      | \`FutureAddedValue(value) => (
          Obj.magic(value): Raw.t_simpleSubscription
        )
      };
    };
    {\\"simpleSubscription\\": simpleSubscription};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module MyTypes = {
  type query;
};
module MyQuery1a = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: MyTypes.query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1a {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery1b = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1b {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
    type t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    };
    type t = {. \\"first\\": t_first};
    type t_variables = unit;
  };
  type t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  type t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  };
  type t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  };
  type t = {. \\"first\\": t_first};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      }
                      and __typename = {
                        let value = value##__typename;
                        value;
                      };
                      {\\"__typename\\": __typename, \\"field\\": field};
                    },
                  )
                | None => None
                };
              }
              and __typename = {
                let value = value##__typename;
                value;
              };
              {\\"__typename\\": __typename, \\"inner\\": inner};
            },
          )
        | None => None
        };
      }
      and __typename = {
        let value = value##__typename;
        value;
      };
      {\\"__typename\\": __typename, \\"inner\\": inner};
    };
    {\\"first\\": first};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      }
                      and __typename = {
                        let value = value##__typename;
                        value;
                      };
                      {\\"__typename\\": __typename, \\"field\\": field};
                    },
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = value##__typename;
                value;
              };
              {\\"__typename\\": __typename, \\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = value##__typename;
        value;
      };
      {\\"__typename\\": __typename, \\"inner\\": inner};
    };
    {\\"first\\": first};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

type named = {name: string};
module NamedQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(named)
    | \`Human(named)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              (
                {
                  let name = {
                    let value = value##name;
                    value;
                  };
                  {name: name};
                }: named
              );
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              (
                {
                  let name = {
                    let value = value##name;
                    value;
                  };
                  {name: name};
                }: named
              );
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let name = {
                let value = (value: named).name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = (value: named).name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module NamedQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Legacy variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationForVariant_dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {. \\"mutationForVariant\\": t_mutationForVariant};
    type t_variables = unit;
  };
  type t_mutationForVariant_dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationForVariant = {
      let value = value##mutationForVariant;
      switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
      | None =>
        Js.Exn.raiseError(
          \\"graphql-ppx: \\"
          ++ \\"Expected type \\"
          ++ \\"VariantTestResult\\"
          ++ \\" to be an object\\",
        )
      | Some(value) =>
        let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
        switch (Js.Json.decodeNull(temp)) {
        | None =>
          let value = temp;
          \`BaseType(value);
        | Some(_) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseTypeList(value |> Js.Array.map(value => value));
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`Dog(
                {
                  let barkVolume = {
                    let value = value##barkVolume;
                    value;
                  }
                  and name = {
                    let value = value##name;
                    value;
                  };
                  {\\"name\\": name, \\"barkVolume\\": barkVolume};
                },
              );
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Human(
                  {
                    let name = {
                      let value = value##name;
                      value;
                    };
                    {\\"name\\": name};
                  },
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`DogOrHuman(
                    {
                      let typename: string =
                        Obj.magic(
                          Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                        );
                      (
                        switch (typename) {
                        | \\"Dog\\" =>
                          \`Dog(
                            {
                              let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                Obj.magic(value);
                              let barkVolume = {
                                let value = value##barkVolume;
                                value;
                              }
                              and name = {
                                let value = value##name;
                                value;
                              };
                              {\\"name\\": name, \\"barkVolume\\": barkVolume};
                            },
                          )
                        | \\"Human\\" =>
                          \`Human(
                            {
                              let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                Obj.magic(value);
                              let name = {
                                let value = value##name;
                                value;
                              };
                              {\\"name\\": name};
                            },
                          )
                        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                        }: t_mutationForVariant_dogOrHuman
                      );
                    },
                  );
                | Some(_) =>
                  Js.Exn.raiseError(
                    \\"graphql-ppx: \\"
                    ++ \\"All fields on variant selection set on type \\"
                    ++ \\"VariantTestResult\\"
                    ++ \\" were null\\",
                  )
                };
              };
            };
          };
        };
      };
    };
    {\\"mutationForVariant\\": mutationForVariant};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationForVariant = {
      let value = value##mutationForVariant;
      Obj.magic(Js.Json.null);
    };
    {\\"mutationForVariant\\": mutationForVariant};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
    type t_variables = {. \\"query\\": int};
  };
  type t = {. \\"argNamedQuery\\": int};
  /**The GraphQL query string*/
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t_variables = {. \\"query\\": int};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let argNamedQuery = {
      let value = value##argNamedQuery;
      value;
    };
    {\\"argNamedQuery\\": argNamedQuery};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let argNamedQuery = {
      let value = value##argNamedQuery;
      value;
    };
    {\\"argNamedQuery\\": argNamedQuery};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"query\\": (a => a)(inp##query)};
  let makeVariables = (~query, ()) =>
    serializeVariables({\\"query\\": query}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MultipleQueryWithSameVarName = {
  module Query1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {. \\"argNamedQuery\\": int};
      type t_variables = {. \\"query\\": int};
    };
    type t = {. \\"argNamedQuery\\": int};
    /**The GraphQL query string*/
    let query = \\"query Query1($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {. \\"query\\": int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {\\"query\\": (a => a)(inp##query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({\\"query\\": query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Query2 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {. \\"argNamedQuery\\": int};
      type t_variables = {. \\"query\\": int};
    };
    type t = {. \\"argNamedQuery\\": int};
    /**The GraphQL query string*/
    let query = \\"query Query2($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {. \\"query\\": int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {\\"argNamedQuery\\": argNamedQuery};
    };
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {\\"query\\": (a => a)(inp##query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({\\"query\\": query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Objects comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  type t = {. \\"nonrecursiveInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let int = {
        let value = value##int;
        StringOfInt.parse(value);
      }
      and string = {
        let value = value##string;
        IntOfString.parse(value);
      };
      {\\"string\\": string, \\"int\\": int};
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let int = {
        let value = value##int;
        StringOfInt.serialize(value);
      }
      and string = {
        let value = value##string;
        IntOfString.serialize(value);
      };
      {\\"string\\": string, \\"int\\": int};
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
    type t = {. \\"customScalarField\\": t_customScalarField};
    type t_variables = {
      .
      \\"opt\\": Js.Nullable.t(Js.Json.t),
      \\"req\\": Js.Json.t,
    };
  };
  type t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t = {. \\"customScalarField\\": t_customScalarField};
  /**The GraphQL query string*/
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let customScalarField = {
      let value = value##customScalarField;
      let nonNullable = {
        let value = value##nonNullable;
        value;
      }
      and nullable = {
        let value = value##nullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
    };
    {\\"customScalarField\\": customScalarField};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let customScalarField = {
      let value = value##customScalarField;
      let nonNullable = {
        let value = value##nonNullable;
        value;
      }
      and nullable = {
        let value = value##nullable;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullable\\": nullable, \\"nonNullable\\": nonNullable};
    };
    {\\"customScalarField\\": customScalarField};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"opt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##opt,
        ),
      \\"req\\": (a => a)(inp##req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({\\"opt\\": opt, \\"req\\": req}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customFields = {
      .
      \\"currentTime\\": Js.Json.t,
      \\"favoriteColor\\": Js.Json.t,
      \\"futureTime\\": Js.Nullable.t(Js.Json.t),
      \\"nullableColor\\": Js.Nullable.t(Js.Json.t),
    };
    type t = {. \\"customFields\\": t_customFields};
    type t_variables = unit;
  };
  type t_customFields = {
    .
    \\"currentTime\\": DateTime.t,
    \\"favoriteColor\\": Color.t,
    \\"futureTime\\": option(DateTime.t),
    \\"nullableColor\\": option(Color.t),
  };
  type t = {. \\"customFields\\": t_customFields};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let customFields = {
      let value = value##customFields;
      let nullableColor = {
        let value = value##nullableColor;
        switch (Js.toOption(value)) {
        | Some(value) => Some(Color.parse(value))
        | None => None
        };
      }
      and futureTime = {
        let value = value##futureTime;
        switch (Js.toOption(value)) {
        | Some(value) => Some(DateTime.parse(value))
        | None => None
        };
      }
      and favoriteColor = {
        let value = value##favoriteColor;
        Color.parse(value);
      }
      and currentTime = {
        let value = value##currentTime;
        DateTime.parse(value);
      };
      {
        \\"currentTime\\": currentTime,
        \\"favoriteColor\\": favoriteColor,
        \\"futureTime\\": futureTime,
        \\"nullableColor\\": nullableColor,
      };
    };
    {\\"customFields\\": customFields};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let customFields = {
      let value = value##customFields;
      let nullableColor = {
        let value = value##nullableColor;
        switch (value) {
        | Some(value) => Js.Nullable.return(Color.serialize(value))
        | None => Js.Nullable.null
        };
      }
      and futureTime = {
        let value = value##futureTime;
        switch (value) {
        | Some(value) => Js.Nullable.return(DateTime.serialize(value))
        | None => Js.Nullable.null
        };
      }
      and favoriteColor = {
        let value = value##favoriteColor;
        Color.serialize(value);
      }
      and currentTime = {
        let value = value##currentTime;
        DateTime.serialize(value);
      };
      {
        \\"currentTime\\": currentTime,
        \\"favoriteColor\\": favoriteColor,
        \\"futureTime\\": futureTime,
        \\"nullableColor\\": nullableColor,
      };
    };
    {\\"customFields\\": customFields};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"defaultObjectValueOnScalar\\": string};
    type t_variables = unit;
  };
  type t = {. \\"defaultObjectValueOnScalar\\": string};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let defaultObjectValueOnScalar = {
      let value = value##defaultObjectValueOnScalar;
      value;
    };
    {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let defaultObjectValueOnScalar = {
      let value = value##defaultObjectValueOnScalar;
      value;
    };
    {\\"defaultObjectValueOnScalar\\": defaultObjectValueOnScalar};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"enumInput\\": string};
    type t_variables = {. \\"arg\\": string};
  };
  type t = {. \\"enumInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let enumInput = {
      let value = value##enumInput;
      value;
    };
    {\\"enumInput\\": enumInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let enumInput = {
      let value = value##enumInput;
      value;
    };
    {\\"enumInput\\": enumInput};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\":
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          inp##arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module Parent = {
  module ExtendQuery = (M: GraphQLQuery) => {
    let use = () => ();
  };
};
module Bla = {
  module Inner = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_lists = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
        \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
        \\"nonNullableOfNonNullable\\": array(string),
      };
      type t = {. \\"lists\\": t_lists};
      type t_variables = unit;
    };
    type t_lists = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
      \\"nonNullableOfNullable\\": array(option(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    /**The GraphQL query string*/
    let query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {
          \\"nullableOfNullable\\": nullableOfNullable,
          \\"nullableOfNonNullable\\": nullableOfNonNullable,
          \\"nonNullableOfNullable\\": nonNullableOfNullable,
          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {\\"lists\\": lists};
    };
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  include Inner;
  include Parent.ExtendQuery(Inner);
};
module Inner = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query Bla2  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
include Inner;
include Parent.ExtendQuery(Inner);
"
`;

exports[`Objects fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (Js.toOption(value)) {
      | Some(value) => Some(value |> Js.Array.map(value => value))
      | None => None
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(value |> Js.Array.map(value => value))
      | None => Js.Nullable.null
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
    type nonrec t_Lists = t;
  };
  type t = {. \\"nullableOfNonNullable\\": option(array(string))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (Js.toOption(value)) {
      | Some(value) => Some(value |> Js.Array.map(value => value))
      | None => None
      };
    };
    {\\"nullableOfNonNullable\\": nullableOfNonNullable};
  };

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(value |> Js.Array.map(value => value))
      | None => Js.Nullable.null
      };
    };
    {\\"nullableOfNonNullable\\": nullableOfNonNullable};
  };
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module FragmentWithArgs = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"listWithArg\\": Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {. \\"listWithArg\\": option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment FragmentWithArgs on Lists   {\\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listWithArg = {
      let value = value##listWithArg;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {\\"listWithArg\\": listWithArg};
  };

  let verifyArgsAndParse =
      (
        ~arg1 as _arg1: [ | \`String],
        ~fragmentName as _FragmentWithArgs: [ | \`FragmentWithArgs],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let listWithArg = {
      let value = value##listWithArg;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {\\"listWithArg\\": listWithArg};
  };
  let verifyName =
    fun
    | \`FragmentWithArgs => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module InlineListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment InlineListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (Js.toOption(value)) {
      | Some(value) => Some(value |> Js.Array.map(value => value))
      | None => None
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };

  let verifyArgsAndParse =
      (
        ~fragmentName as _InlineListFragment: [ | \`InlineListFragment],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNonNullable = {
      let value = value##nullableOfNonNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(value |> Js.Array.map(value => value))
      | None => Js.Nullable.null
      };
    }
    and nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {
      \\"nullableOfNullable\\": nullableOfNullable,
      \\"nullableOfNonNullable\\": nullableOfNonNullable,
    };
  };
  let verifyName =
    fun
    | \`InlineListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      .
      \\"l1\\": ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
      \\"l5\\": FragmentWithArgs.Raw.t,
    };
    type t_variables = {. \\"arg1\\": Js.Nullable.t(string)};
  };
  type t_l2 = {
    .
    \\"frag1\\": ListFragment.t_Lists,
    \\"frag2\\": ListFragment.t_Lists,
  };
  type t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": ListFragment.t_Lists,
    \\"frag2\\": ListFragment.t_Lists,
  };
  type t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"inlineListFragment\\": InlineListFragment.t_Lists,
  };
  type t = {
    .
    \\"l1\\": ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
    \\"l5\\": FragmentWithArgs.t,
  };
  /**The GraphQL query string*/
  let query =
    (
      (
        \\"query MyQuery($arg1: String)  {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...InlineListFragment   \\\\n}\\\\n\\\\nl5: lists  {\\\\n...FragmentWithArgs   \\\\n}\\\\n\\\\n}\\\\n\\"
        ++ FragmentWithArgs.query
      )
      ++ InlineListFragment.query
    )
    ++ ListFragment.query;
  type t_variables = {. \\"arg1\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let l5 = {
      let value = value##l5;

      FragmentWithArgs.verifyArgsAndParse(
        ~arg1=\`String,
        ~fragmentName=\`FragmentWithArgs,
        value,
      );
    }
    and l4 = {
      let value = value##l4;
      let inlineListFragment = {
        let value: InlineListFragment.Raw.t = Obj.magic(value);

        InlineListFragment.verifyArgsAndParse(
          ~fragmentName=\`InlineListFragment,
          value,
        );
      }
      and nullableOfNullable = {
        let value =
          Obj.magic(
            Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
          );
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"inlineListFragment\\": inlineListFragment,
      };
    }
    and l3 = {
      let value = value##l3;
      let frag2 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      }
      and frag1 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      }
      and nullableOfNullable = {
        let value =
          Obj.magic(
            Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
          );
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"frag1\\": frag1,
        \\"frag2\\": frag2,
      };
    }
    and l2 = {
      let value = value##l2;
      let frag2 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      }
      and frag1 = {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      };
      {\\"frag1\\": frag1, \\"frag2\\": frag2};
    }
    and l1 = {
      let value = value##l1;

      ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
    };
    {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4, \\"l5\\": l5};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let l5 = {
      let value = value##l5;
      FragmentWithArgs.serialize(value);
    }
    and l4 = {
      let value = value##l4;
      (
        Obj.magic(
          Js.Array.reduce(
            GraphQL_PPX.deepMerge,
            Obj.magic(
              {
                let nullableOfNullable = {
                  let value = value##nullableOfNullable;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      value
                      |> Js.Array.map(value =>
                           switch (value) {
                           | Some(value) => Js.Nullable.return(value)
                           | None => Js.Nullable.null
                           }
                         ),
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"nullableOfNullable\\": nullableOfNullable};
              },
            ): Js.Json.t,
            [|
              (
                Obj.magic(
                  InlineListFragment.serialize(value##inlineListFragment),
                ): Js.Json.t
              ),
            |],
          ),
        ): Raw.t_l4
      );
    }
    and l3 = {
      let value = value##l3;
      (
        Obj.magic(
          Js.Array.reduce(
            GraphQL_PPX.deepMerge,
            Obj.magic(
              {
                let nullableOfNullable = {
                  let value = value##nullableOfNullable;
                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      value
                      |> Js.Array.map(value =>
                           switch (value) {
                           | Some(value) => Js.Nullable.return(value)
                           | None => Js.Nullable.null
                           }
                         ),
                    )
                  | None => Js.Nullable.null
                  };
                };
                {\\"nullableOfNullable\\": nullableOfNullable};
              },
            ): Js.Json.t,
            [|
              (Obj.magic(ListFragment.serialize(value##frag1)): Js.Json.t),
              (Obj.magic(ListFragment.serialize(value##frag2)): Js.Json.t),
            |],
          ),
        ): Raw.t_l3
      );
    }
    and l2 = {
      let value = value##l2;
      (
        Obj.magic(
          Js.Array.reduce(
            GraphQL_PPX.deepMerge,
            Obj.magic(Js.Dict.empty): Js.Json.t,
            [|
              (Obj.magic(ListFragment.serialize(value##frag1)): Js.Json.t),
              (Obj.magic(ListFragment.serialize(value##frag2)): Js.Json.t),
            |],
          ),
        ): Raw.t_l2
      );
    }
    and l1 = {
      let value = value##l1;
      ListFragment.serialize(value);
    };
    {\\"l1\\": l1, \\"l2\\": l2, \\"l3\\": l3, \\"l4\\": l4, \\"l5\\": l5};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg1\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##arg1,
        ),
    };
  let makeVariables = (~arg1=?, ()) =>
    serializeVariables({\\"arg1\\": arg1}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"lists\\": ListFragment.Raw.t};
    type t_variables = unit;
  };
  type t = {. \\"lists\\": ListFragment.t};
  /**The GraphQL query string*/
  let query =
    \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\n\\" ++ ListFragment.query;
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;

      ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      ListFragment.serialize(value);
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects fragmentInFragment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {. \\"nullableOfNullable\\": option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {\\"nullableOfNullable\\": nullableOfNullable};
  };

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nullableOfNullable = {
      let value = value##nullableOfNullable;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             ),
        )
      | None => Js.Nullable.null
      };
    };
    {\\"nullableOfNullable\\": nullableOfNullable};
  };
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t;
    type nonrec t_Lists = t;
  };
  type t = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": ListFragment.t_Lists,
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query =
    \\"fragment Another on Lists   {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\n\\"
    ++ ListFragment.query;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listFragment = {
      let value: ListFragment.Raw.t = Obj.magic(value);

      ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
    }
    and nullableOfNullable = {
      let value =
        Obj.magic(
          Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
        );
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             ),
        )
      | None => None
      };
    };
    {\\"nullableOfNullable\\": nullableOfNullable, \\"listFragment\\": listFragment};
  };

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    Obj.magic(
      Js.Array.reduce(
        GraphQL_PPX.deepMerge,
        Obj.magic(
          {
            let nullableOfNullable = {
              let value = value##nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {\\"nullableOfNullable\\": nullableOfNullable};
          },
        ): Js.Json.t,
        [|
          (
            Obj.magic(ListFragment.serialize(value##listFragment)): Js.Json.t
          ),
        |],
      ),
    ): Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Objects lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  type t = {. \\"listsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_ListsInput}
    and t_variables_ListsInput = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  type t = {. \\"listsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let listsInput = {
      let value = value##listsInput;
      value;
    };
    {\\"listsInput\\": listsInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectListsInput(a))(inp##arg)}
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),
      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),
      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),
      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    \\"nullableOfNullable\\": nullableOfNullable,
    \\"nullableOfNonNullable\\": nullableOfNonNullable,
    \\"nonNullableOfNullable\\": nonNullableOfNullable,
    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_value = {. \\"stringField\\": string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    };
    type t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_value = {. \\"stringField\\": string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  };
  type t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let message = {
                   let value = value##message;
                   value;
                 }
                 and field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | other => \`FutureAddedValue(other)
                   };
                 };
                 {\\"field\\": field, \\"message\\": message};
               ),
          )
        | None => None
        };
      }
      and value = {
        let value = value##value;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let stringField = {
                let value = value##stringField;
                value;
              };
              {\\"stringField\\": stringField};
            },
          )
        | None => None
        };
      };
      {\\"value\\": value, \\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let message = {
                   let value = value##message;
                   value;
                 }
                 and field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   | \`FutureAddedValue(other) => other
                   };
                 };
                 {\\"field\\": field, \\"message\\": message};
               ),
          )
        | None => Js.Nullable.null
        };
      }
      and value = {
        let value = value##value;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let stringField = {
                let value = value##stringField;
                value;
              };
              {\\"stringField\\": stringField};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"value\\": value, \\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  type t = {. \\"optionalInputArgs\\": string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {. \\"required\\": string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  type t = {. \\"optionalInputArgs\\": string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {. \\"required\\": string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {. \\"field\\": string};
    type t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)};
    type t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      .
      \\"f1\\": string,
      \\"f2\\": string,
    };
    type t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)};
    type t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {. \\"field\\": string};
    type t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)};
    type t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)};
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    };
    type t_variables = unit;
  };
  type t_first_inner_inner = {. \\"field\\": string};
  type t_first_inner = {. \\"inner\\": option(t_first_inner_inner)};
  type t_first = {. \\"inner\\": option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {. \\"inner\\": option(t_second_inner_inner)};
  type t_second = {. \\"inner\\": option(t_second_inner)};
  type t_let_inner_inner = {. \\"field\\": string};
  type t_let_inner = {. \\"inner\\": option(t_let_inner_inner)};
  type t_let = {. \\"inner\\": option(t_let_inner)};
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  };
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let let_ = {
      let value = value##let_;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => None
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => None
        };
      };
      {\\"inner\\": inner};
    }
    and second = {
      let value = value##second;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let f2 = {
                        let value = value##f2;
                        value;
                      }
                      and f1 = {
                        let value = value##f1;
                        value;
                      };
                      {f1, f2};
                    }: t_second_inner_inner,
                  )
                | None => None
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => None
        };
      };
      {\\"inner\\": inner};
    }
    and first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => None
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => None
        };
      };
      {\\"inner\\": inner};
    };
    {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let let_ = {
      let value = value##let_;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => Js.Nullable.null
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"inner\\": inner};
    }
    and second = {
      let value = value##second;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let f2 = {
                        let value = (value: t_second_inner_inner).f2;
                        value;
                      }
                      and f1 = {
                        let value = (value: t_second_inner_inner).f1;
                        value;
                      };
                      {\\"f1\\": f1, \\"f2\\": f2};
                    },
                  )
                | None => Js.Nullable.null
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"inner\\": inner};
    }
    and first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      };
                      {\\"field\\": field};
                    },
                  )
                | None => Js.Nullable.null
                };
              };
              {\\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      };
      {\\"inner\\": inner};
    };
    {\\"first\\": first, \\"second\\": second, \\"let_\\": let_};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  type t = {. \\"nonrecursiveInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let nonrecursiveInput = {
      let value = value##nonrecursiveInput;
      value;
    };
    {\\"nonrecursiveInput\\": nonrecursiveInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      .
      \\"scalarsInput\\": string,
      \\"more\\": string,
    };
    type t_variables = {
      .
      \\"arg\\": t_variables_NonrecursiveInput,
      \\"arg2\\": t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      \\"custom\\": Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  type t = {
    .
    \\"scalarsInput\\": string,
    \\"more\\": string,
  };
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"arg\\": t_variables_NonrecursiveInput,
    \\"arg2\\": t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
    \\"custom\\": option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let more = {
      let value = value##more;
      value;
    }
    and scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let more = {
      let value = value##more;
      value;
    }
    and scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput, \\"more\\": more};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
      \\"arg2\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg2),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      \\"nonNullableField\\": (a => a)(inp##nonNullableField),
      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
      \\"custom\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({\\"arg\\": arg, \\"arg2\\": arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    \\"nonNullableField\\": nonNullableField,
    \\"nullableArray\\": nullableArray,
    \\"field\\": field,
    \\"enum\\": enum,
    \\"embeddedInput\\": embeddedInput,
    \\"custom\\": custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    \\"field\\": field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | other => \`FutureAddedValue(other)
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => None
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   | \`FutureAddedValue(other) => other
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | _ => raise(Not_found)
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => None
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"message\\": string,
      \\"field\\": t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      .
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    .
    \\"message\\": string,
    \\"field\\": t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    .
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (Obj.magic(value: string)) {
                   | \\"FIRST\\" => \`FIRST
                   | \\"SECOND\\" => \`SECOND
                   | \\"THIRD\\" => \`THIRD
                   | _ => raise(Not_found)
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => None
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationWithError = {
      let value = value##mutationWithError;
      let errors = {
        let value = value##errors;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 let field = {
                   let value = value##field;
                   switch (value) {
                   | \`FIRST => \\"FIRST\\"
                   | \`SECOND => \\"SECOND\\"
                   | \`THIRD => \\"THIRD\\"
                   };
                 }
                 and message = {
                   let value = value##message;
                   value;
                 };
                 {\\"message\\": message, \\"field\\": field};
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {\\"errors\\": errors};
    };
    {\\"mutationWithError\\": mutationWithError};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => raise(Not_found)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => raise(Not_found)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = unit;
  };
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let pokemon = {
      let value = value##pokemon;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          {
            let name = {
              let value = value##name;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => None
      };
    };
    {\\"pokemon\\": pokemon};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let pokemon = {
      let value = value##pokemon;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          {
            let name = {
              let value = value##name;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => Js.Nullable.null
      };
    };
    {\\"pokemon\\": pokemon};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = {
      .
      \\"id\\": Js.Nullable.t(string),
      \\"name\\": Js.Nullable.t(string),
    };
  };
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let pokemon = {
      let value = value##pokemon;
      switch (Js.toOption(value)) {
      | Some(value) =>
        Some(
          {
            let name = {
              let value = value##name;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => None
      };
    };
    {\\"pokemon\\": pokemon};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let pokemon = {
      let value = value##pokemon;
      switch (value) {
      | Some(value) =>
        Js.Nullable.return(
          {
            let name = {
              let value = value##name;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and id = {
              let value = value##id;
              value;
            };
            {\\"id\\": id, \\"name\\": name};
          },
        )
      | None => Js.Nullable.null
      };
    };
    {\\"pokemon\\": pokemon};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"id\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##id,
        ),
      \\"name\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({\\"id\\": id, \\"name\\": name}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t = {. \\"variousScalars\\": scalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      (
        {
          let int = {
            let value = value##int;
            value;
          }
          and string = {
            let value = value##string;
            value;
          };
          {string, int};
        }: scalars
      );
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let int = {
        let value = (value: scalars).int;
        value;
      }
      and string = {
        let value = (value: scalars).string;
        value;
      };
      {\\"string\\": string, \\"int\\": int};
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {. \\"nullableString\\": Js.Nullable.t(string)};
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {nullableString: option(string)};
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      (
        {
          let nullableString = {
            let value = value##nullableString;
            switch (Js.toOption(value)) {
            | Some(value) => Some(value)
            | None => None
            };
          };
          {nullableString: nullableString};
        }: t_variousScalars
      );
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let nullableString = {
        let value = (value: t_variousScalars).nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullableString\\": nullableString};
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        .
        \\"string\\": string,
        \\"int\\": int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    /**The GraphQL query string*/
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        let int = {
          let value = value##int;
          value;
        }
        and string = {
          let value = value##string;
          value;
        };
        {string, int};
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _Fragment: [ | \`Fragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let int = {
        let value = (value: t).int;
        value;
      }
      and string = {
        let value = (value: t).string;
        value;
      };
      {\\"string\\": string, \\"int\\": int};
    };
    let verifyName =
      fun
      | \`Fragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
      type t_variables = unit;
    };
    type t = {. \\"variousScalars\\": Fragment.t};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\n\\"
      ++ Fragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let variousScalars = {
        let value = value##variousScalars;

        Fragment.verifyArgsAndParse(~fragmentName=\`Fragment, value);
      };
      {\\"variousScalars\\": variousScalars};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let variousScalars = {
        let value = value##variousScalars;
        Fragment.serialize(value);
      };
      {\\"variousScalars\\": variousScalars};
    };
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              (
                {
                  let barkVolume = {
                    let value = value##barkVolume;
                    value;
                  }
                  and name = {
                    let value = value##name;
                    value;
                  };
                  {name, barkVolume};
                }: t_dogOrHuman_Dog
              );
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = (value: t_dogOrHuman_Dog).barkVolume;
                value;
              }
              and name = {
                let value = (value: t_dogOrHuman_Dog).name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        .
        \\"name\\": string,
        \\"barkVolume\\": float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    /**The GraphQL query string*/
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        let barkVolume = {
          let value = value##barkVolume;
          value;
        }
        and name = {
          let value = value##name;
          value;
        };
        {name, barkVolume};
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _DogFragment: [ | \`DogFragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let barkVolume = {
        let value = (value: t).barkVolume;
        value;
      }
      and name = {
        let value = (value: t).name;
        value;
      };
      {\\"name\\": name, \\"barkVolume\\": barkVolume};
    };
    let verifyName =
      fun
      | \`DogFragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_dogOrHuman;
      type t = {. \\"dogOrHuman\\": t_dogOrHuman};
      type t_variables = unit;
    };
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      ++ DogFragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: DogFragment.Raw.t = Obj.magic(value);

                DogFragment.verifyArgsAndParse(
                  ~fragmentName=\`DogFragment,
                  value,
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {\\"dogOrHuman\\": dogOrHuman};
    };
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Objects recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      .
      \\"otherField\\": Js.Nullable.t(string),
      \\"inner\\": Js.Nullable.t(t_variables_RecursiveInput),
      \\"enum\\": Js.Nullable.t(string),
    };
  };
  type t = {. \\"recursiveInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let recursiveInput = {
      let value = value##recursiveInput;
      value;
    };
    {\\"recursiveInput\\": recursiveInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let recursiveInput = {
      let value = value##recursiveInput;
      value;
    };
    {\\"recursiveInput\\": recursiveInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"arg\\": (a => serializeInputObjectRecursiveInput(a))(inp##arg)}
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      \\"otherField\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##otherField,
        ),
      \\"inner\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          inp##inner,
        ),
      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    \\"otherField\\": otherField,
    \\"inner\\": inner,
    \\"enum\\": enum,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  type t = {. \\"scalarsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  type t = {. \\"scalarsInput\\": string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let scalarsInput = {
      let value = value##scalarsInput;
      value;
    };
    {\\"scalarsInput\\": scalarsInput};
  };
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      \\"arg\\": (a => serializeInputObjectVariousScalarsInput(a))(inp##arg),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),
      \\"string\\": (a => a)(inp##string),
      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),
      \\"int\\": (a => a)(inp##int),
      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),
      \\"float\\": (a => a)(inp##float),
      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),
      \\"boolean\\": (a => a)(inp##boolean),
      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),
      \\"id\\": (a => a)(inp##id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({\\"arg\\": arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    \\"nullableString\\": nullableString,
    \\"string\\": string,
    \\"nullableInt\\": nullableInt,
    \\"int\\": int,
    \\"nullableFloat\\": nullableFloat,
    \\"float\\": float,
    \\"nullableBoolean\\": nullableBoolean,
    \\"boolean\\": boolean,
    \\"nullableID\\": nullableID,
    \\"id\\": id,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    };
    type t_variables = {. \\"var\\": bool};
  };
  type t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  };
  /**The GraphQL query string*/
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {. \\"var\\": bool};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let v2 = {
      let value = value##v2;
      let string = {
        let value = value##string;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    }
    and v1 = {
      let value = value##v1;
      let string = {
        let value = value##string;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    };
    {\\"v1\\": v1, \\"v2\\": v2};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let v2 = {
      let value = value##v2;
      let string = {
        let value = value##string;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    }
    and v1 = {
      let value = value##v1;
      let string = {
        let value = value##string;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {\\"nullableString\\": nullableString, \\"string\\": string};
    };
    {\\"v1\\": v1, \\"v2\\": v2};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"var\\": (a => a)(inp##var)};
  let makeVariables = (~var, ()) =>
    serializeVariables({\\"var\\": var}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_simpleSubscription_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription;
    type t = {. \\"simpleSubscription\\": t_simpleSubscription};
    type t_variables = unit;
  };
  type t_simpleSubscription_Dog = {. \\"name\\": string};
  type t_simpleSubscription_Human = {. \\"name\\": string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  /**The GraphQL query string*/
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let simpleSubscription = {
      let value = value##simpleSubscription;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_simpleSubscription
      );
    };
    {\\"simpleSubscription\\": simpleSubscription};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let simpleSubscription = {
      let value = value##simpleSubscription;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name};
            },
          ): Raw.t_simpleSubscription
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_simpleSubscription
        )
      | \`FutureAddedValue(value) => (
          Obj.magic(value): Raw.t_simpleSubscription
        )
      };
    };
    {\\"simpleSubscription\\": simpleSubscription};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module MyTypes = {
  type query;
};
module MyQuery1a = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: MyTypes.query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1a {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery1b = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1b {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value)
        | None => None
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let variousScalars = {
      let value = value##variousScalars;
      let id = {
        let value = value##id;
        value;
      }
      and nullableID = {
        let value = value##nullableID;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and boolean = {
        let value = value##boolean;
        value;
      }
      and nullableBoolean = {
        let value = value##nullableBoolean;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and float = {
        let value = value##float;
        value;
      }
      and nullableFloat = {
        let value = value##nullableFloat;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and int = {
        let value = value##int;
        value;
      }
      and nullableInt = {
        let value = value##nullableInt;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      }
      and string = {
        let value = value##string;
        value;
      }
      and nullableString = {
        let value = value##nullableString;
        switch (value) {
        | Some(value) => Js.Nullable.return(value)
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableString\\": nullableString,
        \\"string\\": string,
        \\"nullableInt\\": nullableInt,
        \\"int\\": int,
        \\"nullableFloat\\": nullableFloat,
        \\"float\\": float,
        \\"nullableBoolean\\": nullableBoolean,
        \\"boolean\\": boolean,
        \\"nullableID\\": nullableID,
        \\"id\\": id,
      };
    };
    {\\"variousScalars\\": variousScalars};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
    type t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    };
    type t = {. \\"first\\": t_first};
    type t_variables = unit;
  };
  type t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  type t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  };
  type t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  };
  type t = {. \\"first\\": t_first};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let inner = {
                let value = value##inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      }
                      and __typename = {
                        let value = value##__typename;
                        value;
                      };
                      {\\"__typename\\": __typename, \\"field\\": field};
                    },
                  )
                | None => None
                };
              }
              and __typename = {
                let value = value##__typename;
                value;
              };
              {\\"__typename\\": __typename, \\"inner\\": inner};
            },
          )
        | None => None
        };
      }
      and __typename = {
        let value = value##__typename;
        value;
      };
      {\\"__typename\\": __typename, \\"inner\\": inner};
    };
    {\\"first\\": first};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let first = {
      let value = value##first;
      let inner = {
        let value = value##inner;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let inner = {
                let value = value##inner;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let field = {
                        let value = value##field;
                        value;
                      }
                      and __typename = {
                        let value = value##__typename;
                        value;
                      };
                      {\\"__typename\\": __typename, \\"field\\": field};
                    },
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = value##__typename;
                value;
              };
              {\\"__typename\\": __typename, \\"inner\\": inner};
            },
          )
        | None => Js.Nullable.null
        };
      }
      and __typename = {
        let value = value##__typename;
        value;
      };
      {\\"__typename\\": __typename, \\"inner\\": inner};
    };
    {\\"first\\": first};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              let name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

type named = {name: string};
module NamedQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(named)
    | \`Human(named)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              (
                {
                  let name = {
                    let value = value##name;
                    value;
                  };
                  {name: name};
                }: named
              );
            },
          )
        | \\"Human\\" =>
          \`Human(
            {
              let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
              (
                {
                  let name = {
                    let value = value##name;
                    value;
                  };
                  {name: name};
                }: named
              );
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let name = {
                let value = (value: named).name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`Human(value) => (
          Obj.magic(
            {
              let name = {
                let value = (value: named).name;
                value;
              };
              {\\"__typename\\": \\"Human\\", \\"name\\": name};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module NamedQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      let typename: string =
        Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
      (
        switch (typename) {
        | \\"Dog\\" =>
          \`Dog(
            {
              let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          )
        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
        }: t_dogOrHuman
      );
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let dogOrHuman = {
      let value = value##dogOrHuman;
      switch (value) {
      | \`Dog(value) => (
          Obj.magic(
            {
              let barkVolume = {
                let value = value##barkVolume;
                value;
              }
              and name = {
                let value = value##name;
                value;
              };
              {\\"__typename\\": \\"Dog\\", \\"name\\": name, \\"barkVolume\\": barkVolume};
            },
          ): Raw.t_dogOrHuman
        )
      | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
      };
    };
    {\\"dogOrHuman\\": dogOrHuman};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Objects variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationForVariant_dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {. \\"mutationForVariant\\": t_mutationForVariant};
    type t_variables = unit;
  };
  type t_mutationForVariant_dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let mutationForVariant = {
      let value = value##mutationForVariant;
      switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
      | None =>
        Js.Exn.raiseError(
          \\"graphql-ppx: \\"
          ++ \\"Expected type \\"
          ++ \\"VariantTestResult\\"
          ++ \\" to be an object\\",
        )
      | Some(value) =>
        let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
        switch (Js.Json.decodeNull(temp)) {
        | None =>
          let value = temp;
          \`BaseType(value);
        | Some(_) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseTypeList(value |> Js.Array.map(value => value));
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`Dog(
                {
                  let barkVolume = {
                    let value = value##barkVolume;
                    value;
                  }
                  and name = {
                    let value = value##name;
                    value;
                  };
                  {\\"name\\": name, \\"barkVolume\\": barkVolume};
                },
              );
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Human(
                  {
                    let name = {
                      let value = value##name;
                      value;
                    };
                    {\\"name\\": name};
                  },
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`DogOrHuman(
                    {
                      let typename: string =
                        Obj.magic(
                          Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                        );
                      (
                        switch (typename) {
                        | \\"Dog\\" =>
                          \`Dog(
                            {
                              let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                Obj.magic(value);
                              let barkVolume = {
                                let value = value##barkVolume;
                                value;
                              }
                              and name = {
                                let value = value##name;
                                value;
                              };
                              {\\"name\\": name, \\"barkVolume\\": barkVolume};
                            },
                          )
                        | \\"Human\\" =>
                          \`Human(
                            {
                              let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                Obj.magic(value);
                              let name = {
                                let value = value##name;
                                value;
                              };
                              {\\"name\\": name};
                            },
                          )
                        | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                        }: t_mutationForVariant_dogOrHuman
                      );
                    },
                  );
                | Some(_) =>
                  Js.Exn.raiseError(
                    \\"graphql-ppx: \\"
                    ++ \\"All fields on variant selection set on type \\"
                    ++ \\"VariantTestResult\\"
                    ++ \\" were null\\",
                  )
                };
              };
            };
          };
        };
      };
    };
    {\\"mutationForVariant\\": mutationForVariant};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let mutationForVariant = {
      let value = value##mutationForVariant;
      Obj.magic(Js.Json.null);
    };
    {\\"mutationForVariant\\": mutationForVariant};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {argNamedQuery: int};
    type t_variables = {query: int};
  };
  type t = {argNamedQuery: int};
  /**The GraphQL query string*/
  let query = \\"query ($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t_variables = {query: int};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      argNamedQuery: {
        let value = (value: Raw.t).argNamedQuery;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let argNamedQuery = {
        let value = (value: t).argNamedQuery;
        value;
      };
      {argNamedQuery: argNamedQuery};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {query: (a => a)((inp: t_variables).query)};
  let makeVariables = (~query, ()) =>
    serializeVariables({query: query}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_query_82;
    /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_82: _graphql_query_82 = Obj.magic(0);
    type nonrec _graphql_query_75;
    /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_75: _graphql_query_75 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MultipleQueryWithSameVarName = {
  module Query1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {argNamedQuery: int};
      type t_variables = {query: int};
    };
    type t = {argNamedQuery: int};
    /**The GraphQL query string*/
    let query = \\"query Query1($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {query: int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {query: (a => a)((inp: t_variables).query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({query: query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type nonrec _graphql_Query1_query_210;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query1_query_210: _graphql_Query1_query_210 = Obj.magic(0);
      type nonrec _graphql_Query2_query_210;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query2_query_210: _graphql_Query2_query_210 = Obj.magic(0);
      type nonrec _graphql_query_203;
      /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_query_203: _graphql_query_203 = Obj.magic(0);
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Query2 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {argNamedQuery: int};
      type t_variables = {query: int};
    };
    type t = {argNamedQuery: int};
    /**The GraphQL query string*/
    let query = \\"query Query2($query: Int!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
    type t_variables = {query: int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {query: (a => a)((inp: t_variables).query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({query: query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type nonrec _graphql_Query1_query_278;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query1_query_278: _graphql_Query1_query_278 = Obj.magic(0);
      type nonrec _graphql_Query2_query_278;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query2_query_278: _graphql_Query2_query_278 = Obj.magic(0);
      type nonrec _graphql_query_271;
      /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_query_271: _graphql_query_271 = Obj.magic(0);
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Records comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {nonrecursiveInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nonrecursiveInput: {
        let value = (value: Raw.t).nonrecursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nonrecursiveInput = {
        let value = (value: t).nonrecursiveInput;
        value;
      };
      {nonrecursiveInput: nonrecursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            string: {
              let value = (value: Raw.t_variousScalars).string;
              IntOfString.parse(value);
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              StringOfInt.parse(value);
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let int = {
              let value = (value: t_variousScalars).int;
              StringOfInt.serialize(value);
            }
            and string = {
              let value = (value: t_variousScalars).string;
              IntOfString.serialize(value);
            };
            {string, int};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customScalarField = {
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
    type t = {customScalarField: t_customScalarField};
    type t_variables = {
      opt: Js.Nullable.t(Js.Json.t),
      req: Js.Json.t,
    };
  };
  type t_customScalarField = {
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t = {customScalarField: t_customScalarField};
  /**The GraphQL query string*/
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      customScalarField: {
        let value = (value: Raw.t).customScalarField;
        (
          {
            nullable: {
              let value = (value: Raw.t_customScalarField).nullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            nonNullable: {
              let value = (value: Raw.t_customScalarField).nonNullable;
              value;
            },
          }: t_customScalarField
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let customScalarField = {
        let value = (value: t).customScalarField;
        (
          {
            let nonNullable = {
              let value = (value: t_customScalarField).nonNullable;
              value;
            }
            and nullable = {
              let value = (value: t_customScalarField).nullable;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullable, nonNullable};
          }: Raw.t_customScalarField
        );
      };
      {customScalarField: customScalarField};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      opt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).opt,
        ),
      req: (a => a)((inp: t_variables).req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({opt, req}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_opt_119;
    /**Variable **$opt** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_opt_119: _graphql_opt_119 = Obj.magic(0);
    type nonrec _graphql_argOptional_106;
    /**Argument **argOptional** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_argOptional_106: _graphql_argOptional_106 = Obj.magic(0);
    type nonrec _graphql_req_138;
    /**Variable **$req** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_req_138: _graphql_req_138 = Obj.magic(0);
    type nonrec _graphql_argRequired_125;
    /**Argument **argRequired** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_argRequired_125: _graphql_argRequired_125 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customFields = {
      currentTime: Js.Json.t,
      favoriteColor: Js.Json.t,
      futureTime: Js.Nullable.t(Js.Json.t),
      nullableColor: Js.Nullable.t(Js.Json.t),
    };
    type t = {customFields: t_customFields};
    type t_variables = unit;
  };
  type t_customFields = {
    currentTime: DateTime.t,
    favoriteColor: Color.t,
    futureTime: option(DateTime.t),
    nullableColor: option(Color.t),
  };
  type t = {customFields: t_customFields};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      customFields: {
        let value = (value: Raw.t).customFields;
        (
          {
            currentTime: {
              let value = (value: Raw.t_customFields).currentTime;
              DateTime.parse(value);
            },
            favoriteColor: {
              let value = (value: Raw.t_customFields).favoriteColor;
              Color.parse(value);
            },
            futureTime: {
              let value = (value: Raw.t_customFields).futureTime;
              switch (Js.toOption(value)) {
              | Some(value) => Some(DateTime.parse(value))
              | None => None
              };
            },
            nullableColor: {
              let value = (value: Raw.t_customFields).nullableColor;
              switch (Js.toOption(value)) {
              | Some(value) => Some(Color.parse(value))
              | None => None
              };
            },
          }: t_customFields
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let customFields = {
        let value = (value: t).customFields;
        (
          {
            let nullableColor = {
              let value = (value: t_customFields).nullableColor;
              switch (value) {
              | Some(value) => Js.Nullable.return(Color.serialize(value))
              | None => Js.Nullable.null
              };
            }
            and futureTime = {
              let value = (value: t_customFields).futureTime;
              switch (value) {
              | Some(value) => Js.Nullable.return(DateTime.serialize(value))
              | None => Js.Nullable.null
              };
            }
            and favoriteColor = {
              let value = (value: t_customFields).favoriteColor;
              Color.serialize(value);
            }
            and currentTime = {
              let value = (value: t_customFields).currentTime;
              DateTime.serialize(value);
            };
            {currentTime, favoriteColor, futureTime, nullableColor};
          }: Raw.t_customFields
        );
      };
      {customFields: customFields};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {defaultObjectValueOnScalar: string};
    type t_variables = unit;
  };
  type t = {defaultObjectValueOnScalar: string};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndefaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})  \\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      defaultObjectValueOnScalar: {
        let value = (value: Raw.t).defaultObjectValueOnScalar;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let defaultObjectValueOnScalar = {
        let value = (value: t).defaultObjectValueOnScalar;
        value;
      };
      {defaultObjectValueOnScalar: defaultObjectValueOnScalar};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_filter_92;
    /**Argument **filter** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
JsonScalar!
\`\`\`*/
    let _graphql_filter_92: _graphql_filter_92 = Obj.magic(0);
    type nonrec _graphql_arg_140;
    /**Argument **arg** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
EmbeddedInput {
  field: String
}!
\`\`\`*/
    let _graphql_arg_140: _graphql_arg_140 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {enumInput: string};
    type t_variables = {arg: string};
  };
  type t = {enumInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      enumInput: {
        let value = (value: Raw.t).enumInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let enumInput = {
        let value = (value: t).enumInput;
        value;
      };
      {enumInput: enumInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          (inp: t_variables).arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **enumInput** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module Parent = {
  module ExtendQuery = (M: GraphQLQuery) => {
    let use = () => ();
  };
};
module Bla = {
  module Inner = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_lists = {
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
        nonNullableOfNullable: array(Js.Nullable.t(string)),
        nonNullableOfNonNullable: array(string),
      };
      type t = {lists: t_lists};
      type t_variables = unit;
    };
    type t_lists = {
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
      nonNullableOfNullable: array(option(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    /**The GraphQL query string*/
    let query = \\"query Bla  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  include Inner;
  include Parent.ExtendQuery(Inner);
};
module Inner = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query Bla2  {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
include Inner;
include Parent.ExtendQuery(Inner);
"
`;

exports[`Records fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {nullableOfNullable, nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nullableOfNonNullable: Js.Nullable.t(array(string))};
    type nonrec t_Lists = t;
  };
  type t = {nullableOfNonNullable: option(array(string))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      };
      {nullableOfNonNullable: nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module FragmentWithArgs = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listWithArg: Js.Nullable.t(array(Js.Nullable.t(string)))};
    type nonrec t_Lists = t;
  };
  type t = {listWithArg: option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment FragmentWithArgs on Lists   {\\\\nlistWithArg(arg1: $arg1)  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listWithArg: {
        let value = (value: Raw.t).listWithArg;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (
        ~arg1 as _arg1: [ | \`String],
        ~fragmentName as _FragmentWithArgs: [ | \`FragmentWithArgs],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listWithArg = {
        let value = (value: t).listWithArg;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {listWithArg: listWithArg};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`FragmentWithArgs => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module InlineListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment InlineListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (
        ~fragmentName as _InlineListFragment: [ | \`InlineListFragment],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {nullableOfNullable, nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`InlineListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      l1: ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
      l5: FragmentWithArgs.Raw.t,
    };
    type t_variables = {arg1: Js.Nullable.t(string)};
  };
  type t_l2 = {
    frag1: ListFragment.t_Lists,
    frag2: ListFragment.t_Lists,
  };
  type t_l3 = {
    nullableOfNullable: option(array(option(string))),
    frag1: ListFragment.t_Lists,
    frag2: ListFragment.t_Lists,
  };
  type t_l4 = {
    nullableOfNullable: option(array(option(string))),
    inlineListFragment: InlineListFragment.t_Lists,
  };
  type t = {
    l1: ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
    l5: FragmentWithArgs.t,
  };
  /**The GraphQL query string*/
  let query =
    (
      (
        \\"query MyQuery($arg1: String)  {\\\\nl1: lists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n...ListFragment   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...InlineListFragment   \\\\n}\\\\n\\\\nl5: lists  {\\\\n...FragmentWithArgs   \\\\n}\\\\n\\\\n}\\\\n\\"
        ++ FragmentWithArgs.query
      )
      ++ InlineListFragment.query
    )
    ++ ListFragment.query;
  type t_variables = {arg1: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      l1: {
        let value = (value: Raw.t).l1;

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
      l2: {
        let value = (value: Raw.t).l2;
        (
          {
            frag1: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
            frag2: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
          }: t_l2
        );
      },
      l3: {
        let value = (value: Raw.t).l3;
        (
          {
            nullableOfNullable: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
                );
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            frag1: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
            frag2: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
          }: t_l3
        );
      },
      l4: {
        let value = (value: Raw.t).l4;
        (
          {
            nullableOfNullable: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
                );
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            inlineListFragment: {
              let value: InlineListFragment.Raw.t = Obj.magic(value);

              InlineListFragment.verifyArgsAndParse(
                ~fragmentName=\`InlineListFragment,
                value,
              );
            },
          }: t_l4
        );
      },
      l5: {
        let value = (value: Raw.t).l5;

        FragmentWithArgs.verifyArgsAndParse(
          ~arg1=\`String,
          ~fragmentName=\`FragmentWithArgs,
          value,
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let l5 = {
        let value = (value: t).l5;
        FragmentWithArgs.serialize(value);
      }
      and l4 = {
        let value = (value: t).l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l4).nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(
                    InlineListFragment.serialize(
                      (value: t_l4).inlineListFragment,
                    ),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      }
      and l3 = {
        let value = (value: t).l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l3).nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(ListFragment.serialize((value: t_l3).frag1)): Js.Json.t
                ),
                (
                  Obj.magic(ListFragment.serialize((value: t_l3).frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      }
      and l2 = {
        let value = (value: t).l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(ListFragment.serialize((value: t_l2).frag1)): Js.Json.t
                ),
                (
                  Obj.magic(ListFragment.serialize((value: t_l2).frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      }
      and l1 = {
        let value = (value: t).l1;
        ListFragment.serialize(value);
      };
      {l1, l2, l3, l4, l5};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg1:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).arg1,
        ),
    };
  let makeVariables = (~arg1=?, ()) =>
    serializeVariables({arg1: arg1}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {lists: ListFragment.Raw.t};
    type t_variables = unit;
  };
  type t = {lists: ListFragment.t};
  /**The GraphQL query string*/
  let query =
    \\"query   {\\\\nlists  {\\\\n...ListFragment   \\\\n}\\\\n\\\\n}\\\\n\\" ++ ListFragment.query;
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        ListFragment.serialize(value);
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records fragmentInFragment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {nullableOfNullable: option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\n}\\\\n\\";
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {nullableOfNullable: nullableOfNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t;
    type nonrec t_Lists = t;
  };
  type t = {
    nullableOfNullable: option(array(option(string))),
    listFragment: ListFragment.t_Lists,
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query =
    \\"fragment Another on Lists   {\\\\nnullableOfNullable  \\\\n...ListFragment   \\\\n}\\\\n\\"
    ++ ListFragment.query;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value =
          Obj.magic(
            Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
          );
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      listFragment: {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    Obj.magic(
      Js.Array.reduce(
        GraphQL_PPX.deepMerge,
        Obj.magic(
          {
            let nullableOfNullable = {
              let value = (value: t).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {\\"nullableOfNullable\\": nullableOfNullable};
          },
        ): Js.Json.t,
        [|
          (
            Obj.magic(ListFragment.serialize((value: t).listFragment)): Js.Json.t
          ),
        |],
      ),
    ): Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Records lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  type t = {listsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listsInput: {
        let value = (value: Raw.t).listsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listsInput = {
        let value = (value: t).listsInput;
        value;
      };
      {listsInput: listsInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables).nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        nullableOfNullable,
        nullableOfNonNullable,
        nonNullableOfNullable,
        nonNullableOfNonNullable,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_219;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_219: _graphql_arg_219 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {arg: t_variables_ListsInput}
    and t_variables_ListsInput = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  type t = {listsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listsInput: {
        let value = (value: Raw.t).listsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listsInput = {
        let value = (value: t).listsInput;
        value;
      };
      {listsInput: listsInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg: (a => serializeInputObjectListsInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables_ListsInput).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables_ListsInput).nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    nullableOfNullable,
    nullableOfNonNullable,
    nonNullableOfNullable,
    nonNullableOfNonNullable,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_value = {stringField: string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      field: t_mutationWithError_errors_field,
      message: string,
    };
    type t_mutationWithError = {
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_value = {stringField: string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    field: t_mutationWithError_errors_field,
    message: string,
  };
  type t_mutationWithError = {
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            value: {
              let value = (value: Raw.t_mutationWithError).value;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    stringField: {
                      let value =
                        (value: Raw.t_mutationWithError_value).stringField;
                      value;
                    },
                  }: t_mutationWithError_value,
                )
              | None => None
              };
            },
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | other => \`FutureAddedValue(other)
                             };
                           },
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           }
                           and field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             | \`FutureAddedValue(other) => other
                             };
                           };
                           {field, message};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and value = {
              let value = (value: t_mutationWithError).value;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let stringField = {
                      let value =
                        (value: t_mutationWithError_value).stringField;
                      value;
                    };
                    {stringField: stringField};
                  }: Raw.t_mutationWithError_value,
                )
              | None => Js.Nullable.null
              };
            };
            {value, errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {optionalInputArgs: string};
    type t_variables = {required: string};
  };
  type t = {optionalInputArgs: string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {required: string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      optionalInputArgs: {
        let value = (value: Raw.t).optionalInputArgs;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let optionalInputArgs = {
        let value = (value: t).optionalInputArgs;
        value;
      };
      {optionalInputArgs: optionalInputArgs};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {required: (a => a)((inp: t_variables).required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({required: required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  type t = {. \\"optionalInputArgs\\": string};
  /**The GraphQL query string*/
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t_variables = {. \\"required\\": string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {field: string};
    type t_first_inner = {inner: Js.Nullable.t(t_first_inner_inner)};
    type t_first = {inner: Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      f1: string,
      f2: string,
    };
    type t_second_inner = {inner: Js.Nullable.t(t_second_inner_inner)};
    type t_second = {inner: Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {field: string};
    type t_let_inner = {inner: Js.Nullable.t(t_let_inner_inner)};
    type t_let = {inner: Js.Nullable.t(t_let_inner)};
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    };
    type t_variables = unit;
  };
  type t_first_inner_inner = {field: string};
  type t_first_inner = {inner: option(t_first_inner_inner)};
  type t_first = {inner: option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {inner: option(t_second_inner_inner)};
  type t_second = {inner: option(t_second_inner)};
  type t_let_inner_inner = {field: string};
  type t_let_inner = {inner: option(t_let_inner_inner)};
  type t_let = {inner: option(t_let_inner)};
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  };
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      first: {
        let value = (value: Raw.t).first;
        (
          {
            inner: {
              let value = (value: Raw.t_first).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    inner: {
                      let value = (value: Raw.t_first_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            field: {
                              let value =
                                (value: Raw.t_first_inner_inner).field;
                              value;
                            },
                          }: t_first_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_first_inner,
                )
              | None => None
              };
            },
          }: t_first
        );
      },
      second: {
        let value = (value: Raw.t).second;
        (
          {
            inner: {
              let value = (value: Raw.t_second).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    inner: {
                      let value = (value: Raw.t_second_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            f1: {
                              let value = (value: Raw.t_second_inner_inner).f1;
                              value;
                            },
                            f2: {
                              let value = (value: Raw.t_second_inner_inner).f2;
                              value;
                            },
                          }: t_second_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_second_inner,
                )
              | None => None
              };
            },
          }: t_second
        );
      },
      let_: {
        let value = (value: Raw.t).let_;
        (
          {
            inner: {
              let value = (value: Raw.t_let).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    inner: {
                      let value = (value: Raw.t_let_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            field: {
                              let value = (value: Raw.t_let_inner_inner).field;
                              value;
                            },
                          }: t_let_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_let_inner,
                )
              | None => None
              };
            },
          }: t_let
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let let_ = {
        let value = (value: t).let_;
        (
          {
            let inner = {
              let value = (value: t_let).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_let_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_let_inner_inner).field;
                              value;
                            };
                            {field: field};
                          }: Raw.t_let_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {inner: inner};
                  }: Raw.t_let_inner,
                )
              | None => Js.Nullable.null
              };
            };
            {inner: inner};
          }: Raw.t_let
        );
      }
      and second = {
        let value = (value: t).second;
        (
          {
            let inner = {
              let value = (value: t_second).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_second_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let f2 = {
                              let value = (value: t_second_inner_inner).f2;
                              value;
                            }
                            and f1 = {
                              let value = (value: t_second_inner_inner).f1;
                              value;
                            };
                            {f1, f2};
                          }: Raw.t_second_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {inner: inner};
                  }: Raw.t_second_inner,
                )
              | None => Js.Nullable.null
              };
            };
            {inner: inner};
          }: Raw.t_second
        );
      }
      and first = {
        let value = (value: t).first;
        (
          {
            let inner = {
              let value = (value: t_first).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_first_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_first_inner_inner).field;
                              value;
                            };
                            {field: field};
                          }: Raw.t_first_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {inner: inner};
                  }: Raw.t_first_inner,
                )
              | None => Js.Nullable.null
              };
            };
            {inner: inner};
          }: Raw.t_first
        );
      };
      {first, second, let_};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {nonrecursiveInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nonrecursiveInput: {
        let value = (value: Raw.t).nonrecursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nonrecursiveInput = {
        let value = (value: t).nonrecursiveInput;
        value;
      };
      {nonrecursiveInput: nonrecursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      scalarsInput: string,
      more: string,
    };
    type t_variables = {
      arg: t_variables_NonrecursiveInput,
      arg2: t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {
    scalarsInput: string,
    more: string,
  };
  /**The GraphQL query string*/
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t_variables = {
    arg: t_variables_NonrecursiveInput,
    arg2: t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
      more: {
        let value = (value: Raw.t).more;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let more = {
        let value = (value: t).more;
        value;
      }
      and scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput, more};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
      arg2:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg2,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({arg, arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_240;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_240: _graphql_arg_240 = Obj.magic(0);
    type nonrec _graphql_arg_235;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_235: _graphql_arg_235 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | other => \`FutureAddedValue(other)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             | \`FutureAddedValue(other) => other
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           };
                           {message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {errors: errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | _ => raise(Not_found)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           };
                           {message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {errors: errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nerrors  {\\\\nmessage  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | _ => raise(Not_found)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           };
                           {message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {errors: errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = unit;
  };
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      pokemon: {
        let value = (value: Raw.t).pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              id: {
                let value = (value: Raw.t_pokemon).id;
                value;
              },
              name: {
                let value = (value: Raw.t_pokemon).name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_pokemon,
          )
        | None => None
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let pokemon = {
        let value = (value: t).pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = (value: t_pokemon).name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = (value: t_pokemon).id;
                value;
              };
              {id, name};
            }: Raw.t_pokemon,
          )
        | None => Js.Nullable.null
        };
      };
      {pokemon: pokemon};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_name_52;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_52: _graphql_name_52 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = {
      id: Js.Nullable.t(string),
      name: Js.Nullable.t(string),
    };
  };
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  /**The GraphQL query string*/
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      pokemon: {
        let value = (value: Raw.t).pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              id: {
                let value = (value: Raw.t_pokemon).id;
                value;
              },
              name: {
                let value = (value: Raw.t_pokemon).name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_pokemon,
          )
        | None => None
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let pokemon = {
        let value = (value: t).pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = (value: t_pokemon).name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = (value: t_pokemon).id;
                value;
              };
              {id, name};
            }: Raw.t_pokemon,
          )
        | None => Js.Nullable.null
        };
      };
      {pokemon: pokemon};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      id:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).id,
        ),
      name:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({id, name}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_pokemon_name_100;
    /**Variable **$name** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_pokemon_name_100: _graphql_pokemon_name_100 = Obj.magic(0);
    type nonrec _graphql_name_94;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_94: _graphql_name_94 = Obj.magic(0);
    type nonrec _graphql_pokemon_id_111;
    /**Variable **$id** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_pokemon_id_111: _graphql_pokemon_id_111 = Obj.magic(0);
    type nonrec _graphql_id_107;
    /**Argument **id** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_id_107: _graphql_id_107 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t = {variousScalars: scalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
          }: scalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let int = {
              let value = (value: scalars).int;
              value;
            }
            and string = {
              let value = (value: scalars).string;
              value;
            };
            {string, int};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {nullableString: Js.Nullable.t(string)};
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {nullableString: option(string)};
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullableString: nullableString};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        string,
        int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    /**The GraphQL query string*/
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        string: {
          let value = (value: Raw.t).string;
          value;
        },
        int: {
          let value = (value: Raw.t).int;
          value;
        },
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _Fragment: [ | \`Fragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let int = {
          let value = (value: t).int;
          value;
        }
        and string = {
          let value = (value: t).string;
          value;
        };
        {string, int};
      }: Raw.t
    );
    let verifyName =
      fun
      | \`Fragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
      type t_variables = unit;
    };
    type t = {variousScalars: Fragment.t};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\nvariousScalars  {\\\\n...Fragment   \\\\n}\\\\n\\\\n}\\\\n\\"
      ++ Fragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;

          Fragment.verifyArgsAndParse(~fragmentName=\`Fragment, value);
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          Fragment.serialize(value);
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    /**The GraphQL query string*/
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        name: {
          let value = (value: Raw.t).name;
          value;
        },
        barkVolume: {
          let value = (value: Raw.t).barkVolume;
          value;
        },
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _DogFragment: [ | \`DogFragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let barkVolume = {
          let value = (value: t).barkVolume;
          value;
        }
        and name = {
          let value = (value: t).name;
          value;
        };
        {name, barkVolume};
      }: Raw.t
    );
    let verifyName =
      fun
      | \`DogFragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_dogOrHuman;
      type t = {dogOrHuman: t_dogOrHuman};
      type t_variables = unit;
    };
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {dogOrHuman: t_dogOrHuman};
    /**The GraphQL query string*/
    let query =
      \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...DogFragment   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      ++ DogFragment.query;
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: DogFragment.Raw.t = Obj.magic(value);

                  DogFragment.verifyArgsAndParse(
                    ~fragmentName=\`DogFragment,
                    value,
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Records recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {recursiveInput: string};
    type t_variables = {arg: t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      otherField: Js.Nullable.t(string),
      inner: Js.Nullable.t(t_variables_RecursiveInput),
      enum: Js.Nullable.t(string),
    };
  };
  type t = {recursiveInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      recursiveInput: {
        let value = (value: Raw.t).recursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let recursiveInput = {
        let value = (value: t).recursiveInput;
        value;
      };
      {recursiveInput: recursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectRecursiveInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      otherField:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_RecursiveInput).otherField,
        ),
      inner:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).inner,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    otherField,
    inner,
    enum,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_90;
    /**Variable **$arg** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_90: _graphql_arg_90 = Obj.magic(0);
    type nonrec _graphql_arg_85;
    /**Argument **arg** on field **recursiveInput** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_85: _graphql_arg_85 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  type t = {scalarsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput: scalarsInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableString,
        ),
      string: (a => a)((inp: t_variables).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableInt,
        ),
      int: (a => a)((inp: t_variables).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableFloat,
        ),
      float: (a => a)((inp: t_variables).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableID,
        ),
      id: (a => a)((inp: t_variables).id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        nullableString,
        string,
        nullableInt,
        int,
        nullableFloat,
        float,
        nullableBoolean,
        boolean,
        nullableID,
        id,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_292;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_292: _graphql_arg_292 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  type t = {scalarsInput: string};
  /**The GraphQL query string*/
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput: scalarsInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectVariousScalarsInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableString,
        ),
      string: (a => a)((inp: t_variables_VariousScalarsInput).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableInt,
        ),
      int: (a => a)((inp: t_variables_VariousScalarsInput).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableFloat,
        ),
      float: (a => a)((inp: t_variables_VariousScalarsInput).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableID,
        ),
      id: (a => a)((inp: t_variables_VariousScalarsInput).id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    nullableString,
    string,
    nullableInt,
    int,
    nullableFloat,
    float,
    nullableBoolean,
    boolean,
    nullableID,
    id,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_93;
    /**Variable **$arg** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_93: _graphql_arg_93 = Obj.magic(0);
    type nonrec _graphql_arg_88;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_88: _graphql_arg_88 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_v1 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t_v2 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t = {
      v1: t_v1,
      v2: t_v2,
    };
    type t_variables = {var: bool};
  };
  type t_v1 = {
    nullableString: option(string),
    string: option(string),
  };
  type t_v2 = {
    nullableString: option(string),
    string: option(string),
  };
  type t = {
    v1: t_v1,
    v2: t_v2,
  };
  /**The GraphQL query string*/
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = {var: bool};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      v1: {
        let value = (value: Raw.t).v1;
        (
          {
            nullableString: {
              let value = (value: Raw.t_v1).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_v1).string;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_v1
        );
      },
      v2: {
        let value = (value: Raw.t).v2;
        (
          {
            nullableString: {
              let value = (value: Raw.t_v2).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_v2).string;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_v2
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let v2 = {
        let value = (value: t).v2;
        (
          {
            let string = {
              let value = (value: t_v2).string;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and nullableString = {
              let value = (value: t_v2).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullableString, string};
          }: Raw.t_v2
        );
      }
      and v1 = {
        let value = (value: t).v1;
        (
          {
            let string = {
              let value = (value: t_v1).string;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and nullableString = {
              let value = (value: t_v1).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullableString, string};
          }: Raw.t_v1
        );
      };
      {v1, v2};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {var: (a => a)((inp: t_variables).var)};
  let makeVariables = (~var, ()) =>
    serializeVariables({var: var}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_simpleSubscription_Dog = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription_Human = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription;
    type t = {simpleSubscription: t_simpleSubscription};
    type t_variables = unit;
  };
  type t_simpleSubscription_Dog = {name: string};
  type t_simpleSubscription_Human = {name: string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {simpleSubscription: t_simpleSubscription};
  /**The GraphQL query string*/
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      simpleSubscription: {
        let value = (value: Raw.t).simpleSubscription;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_simpleSubscription_Dog).name;
                      value;
                    },
                  }: t_simpleSubscription_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_simpleSubscription_Human).name;
                      value;
                    },
                  }: t_simpleSubscription_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let simpleSubscription = {
        let value = (value: t).simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_simpleSubscription_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name};
              }: Raw.t_simpleSubscription_Dog,
            ): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_simpleSubscription_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_simpleSubscription_Human,
            ): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      };
      {simpleSubscription: simpleSubscription};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module MyTypes = {
  type query;
};
module MyQuery1a = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: MyTypes.query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1a {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery1b = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1b {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t = {first: t_first};
    type t_variables = unit;
  };
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t = {first: t_first};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      first: {
        let value = (value: Raw.t).first;
        (
          {
            __typename: {
              let value = (value: Raw.t_first).__typename;
              value;
            },
            inner: {
              let value = (value: Raw.t_first).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    __typename: {
                      let value = (value: Raw.t_first_inner).__typename;
                      value;
                    },
                    inner: {
                      let value = (value: Raw.t_first_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            __typename: {
                              let value =
                                (value: Raw.t_first_inner_inner).__typename;
                              value;
                            },
                            field: {
                              let value =
                                (value: Raw.t_first_inner_inner).field;
                              value;
                            },
                          }: t_first_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_first_inner,
                )
              | None => None
              };
            },
          }: t_first
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let first = {
        let value = (value: t).first;
        (
          {
            let inner = {
              let value = (value: t_first).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_first_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_first_inner_inner).field;
                              value;
                            }
                            and __typename = {
                              let value =
                                (value: t_first_inner_inner).__typename;
                              value;
                            };
                            {__typename, field};
                          }: Raw.t_first_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_first_inner).__typename;
                      value;
                    };
                    {__typename, inner};
                  }: Raw.t_first_inner,
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_first).__typename;
              value;
            };
            {__typename, inner};
          }: Raw.t_first
        );
      };
      {first: first};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

type named = {name: string};
module NamedQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(named)
    | \`Human(named)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                  }: named
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: named
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: named).name;
                  value;
                };
                {__typename: \\"Dog\\", name};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: named).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module NamedQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Records variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationForVariant_dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {mutationForVariant: t_mutationForVariant};
    type t_variables = unit;
  };
  type t_mutationForVariant_dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_human = {name: string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {name: string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {mutationForVariant: t_mutationForVariant};
  /**The GraphQL query string*/
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationForVariant: {
        let value = (value: Raw.t).mutationForVariant;
        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
        | None =>
          Js.Exn.raiseError(
            \\"graphql-ppx: \\"
            ++ \\"Expected type \\"
            ++ \\"VariantTestResult\\"
            ++ \\" to be an object\\",
          )
        | Some(value) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseType(value);
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseTypeList(value |> Js.Array.map(value => value));
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Dog(
                  {
                    name: {
                      let value = (value: Raw.t_mutationForVariant_dog).name;
                      value;
                    },
                    barkVolume: {
                      let value =
                        (value: Raw.t_mutationForVariant_dog).barkVolume;
                      value;
                    },
                  }: t_mutationForVariant_dog,
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Human(
                    {
                      name: {
                        let value =
                          (value: Raw.t_mutationForVariant_human).name;
                        value;
                      },
                    }: t_mutationForVariant_human,
                  );
                | Some(_) =>
                  let temp =
                    Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`DogOrHuman(
                      {
                        let typename: string =
                          Obj.magic(
                            Js.Dict.unsafeGet(
                              Obj.magic(value),
                              \\"__typename\\",
                            ),
                          );
                        (
                          switch (typename) {
                          | \\"Dog\\" =>
                            \`Dog(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                  Obj.magic(value);
                                (
                                  {
                                    name: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                        ).
                                          name;
                                      value;
                                    },
                                    barkVolume: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                        ).
                                          barkVolume;
                                      value;
                                    },
                                  }: t_mutationForVariant_dogOrHuman_Dog
                                );
                              },
                            )
                          | \\"Human\\" =>
                            \`Human(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                  Obj.magic(value);
                                (
                                  {
                                    name: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Human
                                        ).
                                          name;
                                      value;
                                    },
                                  }: t_mutationForVariant_dogOrHuman_Human
                                );
                              },
                            )
                          | _ =>
                            \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                          }: t_mutationForVariant_dogOrHuman
                        );
                      },
                    );
                  | Some(_) =>
                    Js.Exn.raiseError(
                      \\"graphql-ppx: \\"
                      ++ \\"All fields on variant selection set on type \\"
                      ++ \\"VariantTestResult\\"
                      ++ \\" were null\\",
                    )
                  };
                };
              };
            };
          };
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationForVariant = {
        let value = (value: t).mutationForVariant;
        Obj.magic(Js.Json.null);
      };
      {mutationForVariant: mutationForVariant};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {argNamedQuery: int};
    type t_variables = {query: int};
  };
  type t = {argNamedQuery: int};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($query: Int!)  {\\\\n    argNamedQuery(query: $query)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {query: int};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      argNamedQuery: {
        let value = (value: Raw.t).argNamedQuery;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let argNamedQuery = {
        let value = (value: t).argNamedQuery;
        value;
      };
      {argNamedQuery: argNamedQuery};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {query: (a => a)((inp: t_variables).query)};
  let makeVariables = (~query, ()) =>
    serializeVariables({query: query}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_query_82;
    /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_82: _graphql_query_82 = Obj.magic(0);
    type nonrec _graphql_query_75;
    /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
    let _graphql_query_75: _graphql_query_75 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MultipleQueryWithSameVarName = {
  module Query1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {argNamedQuery: int};
      type t_variables = {query: int};
    };
    type t = {argNamedQuery: int};
    /**The GraphQL query string*/
    let query: string = [%raw
      \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query Query1($query: Int!)  {\\\\n    argNamedQuery(query: $query)\\\\n  }\\\\n\`\\"
    ];
    type t_variables = {query: int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {query: (a => a)((inp: t_variables).query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({query: query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type nonrec _graphql_Query1_query_210;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query1_query_210: _graphql_Query1_query_210 = Obj.magic(0);
      type nonrec _graphql_Query2_query_210;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query2_query_210: _graphql_Query2_query_210 = Obj.magic(0);
      type nonrec _graphql_query_203;
      /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_query_203: _graphql_query_203 = Obj.magic(0);
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Query2 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {argNamedQuery: int};
      type t_variables = {query: int};
    };
    type t = {argNamedQuery: int};
    /**The GraphQL query string*/
    let query: string = [%raw
      \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query Query2($query: Int!)  {\\\\n    argNamedQuery(query: $query)\\\\n  }\\\\n\`\\"
    ];
    type t_variables = {query: int};
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        argNamedQuery: {
          let value = (value: Raw.t).argNamedQuery;
          value;
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;
          value;
        };
        {argNamedQuery: argNamedQuery};
      }: Raw.t
    );
    let serializeVariables: t_variables => Raw.t_variables =
      inp => {query: (a => a)((inp: t_variables).query)};
    let makeVariables = (~query, ()) =>
      serializeVariables({query: query}: t_variables);
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type nonrec _graphql_Query1_query_278;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query1_query_278: _graphql_Query1_query_278 = Obj.magic(0);
      type nonrec _graphql_Query2_query_278;
      /**Variable **$query** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_Query2_query_278: _graphql_Query2_query_278 = Obj.magic(0);
      type nonrec _graphql_query_271;
      /**Argument **query** on field **argNamedQuery** has the following graphql type:

\`\`\`
Int!
\`\`\`*/
      let _graphql_query_271: _graphql_query_271 = Obj.magic(0);
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MultipleQueryWithSameVarName {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Template comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {nonrecursiveInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($arg: NonrecursiveInput!)  {\\\\n    nonrecursiveInput(arg: $arg)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nonrecursiveInput: {
        let value = (value: Raw.t).nonrecursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nonrecursiveInput = {
        let value = (value: t).nonrecursiveInput;
        value;
      };
      {nonrecursiveInput: nonrecursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  let serialize = int_of_string;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  let serialize = string_of_int;
  type t = int;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      string\\\\n      int\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            string: {
              let value = (value: Raw.t_variousScalars).string;
              IntOfString.parse(value);
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              StringOfInt.parse(value);
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let int = {
              let value = (value: t_variousScalars).int;
              StringOfInt.serialize(value);
            }
            and string = {
              let value = (value: t_variousScalars).string;
              IntOfString.serialize(value);
            };
            {string, int};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customScalarField = {
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
    type t = {customScalarField: t_customScalarField};
    type t_variables = {
      opt: Js.Nullable.t(Js.Json.t),
      req: Js.Json.t,
    };
  };
  type t_customScalarField = {
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t = {customScalarField: t_customScalarField};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\n    customScalarField(argOptional: $opt, argRequired: $req)  {\\\\n      nullable\\\\n      nonNullable\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      customScalarField: {
        let value = (value: Raw.t).customScalarField;
        (
          {
            nullable: {
              let value = (value: Raw.t_customScalarField).nullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            nonNullable: {
              let value = (value: Raw.t_customScalarField).nonNullable;
              value;
            },
          }: t_customScalarField
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let customScalarField = {
        let value = (value: t).customScalarField;
        (
          {
            let nonNullable = {
              let value = (value: t_customScalarField).nonNullable;
              value;
            }
            and nullable = {
              let value = (value: t_customScalarField).nullable;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullable, nonNullable};
          }: Raw.t_customScalarField
        );
      };
      {customScalarField: customScalarField};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      opt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).opt,
        ),
      req: (a => a)((inp: t_variables).req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables({opt, req}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_opt_119;
    /**Variable **$opt** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_opt_119: _graphql_opt_119 = Obj.magic(0);
    type nonrec _graphql_argOptional_106;
    /**Argument **argOptional** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar
\`\`\`*/
    let _graphql_argOptional_106: _graphql_argOptional_106 = Obj.magic(0);
    type nonrec _graphql_req_138;
    /**Variable **$req** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_req_138: _graphql_req_138 = Obj.magic(0);
    type nonrec _graphql_argRequired_125;
    /**Argument **argRequired** on field **customScalarField** has the following graphql type:

\`\`\`
CustomScalar!
\`\`\`*/
    let _graphql_argRequired_125: _graphql_argRequired_125 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Color = {
  type t =
    | Red
    | Green
    | Blue;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(\\"green\\") => Green
    | Some(\\"blue\\") => Blue
    | Some(\\"red\\")
    | Some(_)
    | None => Red
    };
  let serialize = color =>
    (
      switch (color) {
      | Red => \\"red\\"
      | Green => \\"green\\"
      | Blue => \\"blue\\"
      }
    )
    |> Js.Json.string;
};
module DateTime = {
  type t = Js.Date.t;
  let parse = json =>
    switch (json |> Js.Json.decodeString) {
    | Some(str) => str |> Js.Date.fromString
    | None => Js.Date.make()
    };
  let serialize = date => date |> Js.Date.toISOString |> Js.Json.string;
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_customFields = {
      currentTime: Js.Json.t,
      favoriteColor: Js.Json.t,
      futureTime: Js.Nullable.t(Js.Json.t),
      nullableColor: Js.Nullable.t(Js.Json.t),
    };
    type t = {customFields: t_customFields};
    type t_variables = unit;
  };
  type t_customFields = {
    currentTime: DateTime.t,
    favoriteColor: Color.t,
    futureTime: option(DateTime.t),
    nullableColor: option(Color.t),
  };
  type t = {customFields: t_customFields};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    customFields  {\\\\n      currentTime\\\\n      favoriteColor\\\\n      futureTime\\\\n      nullableColor\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      customFields: {
        let value = (value: Raw.t).customFields;
        (
          {
            currentTime: {
              let value = (value: Raw.t_customFields).currentTime;
              DateTime.parse(value);
            },
            favoriteColor: {
              let value = (value: Raw.t_customFields).favoriteColor;
              Color.parse(value);
            },
            futureTime: {
              let value = (value: Raw.t_customFields).futureTime;
              switch (Js.toOption(value)) {
              | Some(value) => Some(DateTime.parse(value))
              | None => None
              };
            },
            nullableColor: {
              let value = (value: Raw.t_customFields).nullableColor;
              switch (Js.toOption(value)) {
              | Some(value) => Some(Color.parse(value))
              | None => None
              };
            },
          }: t_customFields
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let customFields = {
        let value = (value: t).customFields;
        (
          {
            let nullableColor = {
              let value = (value: t_customFields).nullableColor;
              switch (value) {
              | Some(value) => Js.Nullable.return(Color.serialize(value))
              | None => Js.Nullable.null
              };
            }
            and futureTime = {
              let value = (value: t_customFields).futureTime;
              switch (value) {
              | Some(value) => Js.Nullable.return(DateTime.serialize(value))
              | None => Js.Nullable.null
              };
            }
            and favoriteColor = {
              let value = (value: t_customFields).favoriteColor;
              Color.serialize(value);
            }
            and currentTime = {
              let value = (value: t_customFields).currentTime;
              DateTime.serialize(value);
            };
            {currentTime, favoriteColor, futureTime, nullableColor};
          }: Raw.t_customFields
        );
      };
      {customFields: customFields};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template defaultObjectValueOnScalar.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {defaultObjectValueOnScalar: string};
    type t_variables = unit;
  };
  type t = {defaultObjectValueOnScalar: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n  defaultObjectValueOnScalar(filter: {some: {json: \\\\\\"value\\\\\\"}}, arg: {field: \\\\\\"otherValue\\\\\\"})\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      defaultObjectValueOnScalar: {
        let value = (value: Raw.t).defaultObjectValueOnScalar;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let defaultObjectValueOnScalar = {
        let value = (value: t).defaultObjectValueOnScalar;
        value;
      };
      {defaultObjectValueOnScalar: defaultObjectValueOnScalar};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_filter_92;
    /**Argument **filter** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
JsonScalar!
\`\`\`*/
    let _graphql_filter_92: _graphql_filter_92 = Obj.magic(0);
    type nonrec _graphql_arg_140;
    /**Argument **arg** on field **defaultObjectValueOnScalar** has the following graphql type:

\`\`\`
EmbeddedInput {
  field: String
}!
\`\`\`*/
    let _graphql_arg_140: _graphql_arg_140 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {enumInput: string};
    type t_variables = {arg: string};
  };
  type t = {enumInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($arg: SampleField!)  {\\\\n    enumInput(arg: $arg)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      enumInput: {
        let value = (value: Raw.t).enumInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let enumInput = {
        let value = (value: t).enumInput;
        value;
      };
      {enumInput: enumInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          (inp: t_variables).arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **enumInput** has the following graphql type:

\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_SampleField_47;
    /**\`\`\`
SampleField {
  FIRST
  SECOND
  THIRD
}
\`\`\`*/
    let _graphql_SampleField_47: _graphql_SampleField_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    lists  {\\\\n      nullableOfNullable\\\\n      nullableOfNonNullable\\\\n      nonNullableOfNullable\\\\n      nonNullableOfNonNullable\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module RecordsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ObjectsQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    lists  {\\\\n      nullableOfNullable\\\\n      nullableOfNonNullable\\\\n      nonNullableOfNullable\\\\n      nonNullableOfNonNullable\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (Js.toOption(value)) {
             | Some(value) => Some(value)
             | None => None
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let lists = {
      let value = value##lists;
      let nonNullableOfNonNullable = {
        let value = value##nonNullableOfNonNullable;
        value |> Js.Array.map(value => value);
      }
      and nonNullableOfNullable = {
        let value = value##nonNullableOfNullable;
        value
        |> Js.Array.map(value =>
             switch (value) {
             | Some(value) => Js.Nullable.return(value)
             | None => Js.Nullable.null
             }
           );
      }
      and nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {
        \\"nullableOfNullable\\": nullableOfNullable,
        \\"nullableOfNonNullable\\": nullableOfNonNullable,
        \\"nonNullableOfNullable\\": nonNullableOfNullable,
        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      };
    };
    {\\"lists\\": lists};
  };
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ObjectsQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template extensions.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module type GraphQLQuery = {
  module Raw: {
    type t;
    type t_variables;
  };
  type t;
  type t_variables;

  let query: string;
  let parse: Raw.t => t;
  let serialize: t => Raw.t;
};

module Parent = {
  module ExtendQuery = (M: GraphQLQuery) => {
    let use = () => ();
  };
};
module Bla = {
  module Inner = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_lists = {
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
        nonNullableOfNullable: array(Js.Nullable.t(string)),
        nonNullableOfNonNullable: array(string),
      };
      type t = {lists: t_lists};
      type t_variables = unit;
    };
    type t_lists = {
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
      nonNullableOfNullable: array(option(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    /**The GraphQL query string*/
    let query: string = [%raw
      \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query Bla  {\\\\n    lists  {\\\\n      nullableOfNullable\\\\n      nullableOfNonNullable\\\\n      nonNullableOfNullable\\\\n      nonNullableOfNonNullable\\\\n    }\\\\n  }\\\\n\`\\"
    ];
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        lists: {
          let value = (value: Raw.t).lists;
          (
            {
              nullableOfNullable: {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              },
              nullableOfNonNullable: {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              },
              nonNullableOfNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              },
              nonNullableOfNonNullable: {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              },
            }: t_lists
          );
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;
                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {
                nullableOfNullable,
                nullableOfNonNullable,
                nonNullableOfNullable,
                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {lists: lists};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  include Inner;
  include Parent.ExtendQuery(Inner);
};
module Inner = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query Bla2  {\\\\n    lists  {\\\\n      nullableOfNullable\\\\n      nullableOfNonNullable\\\\n      nonNullableOfNullable\\\\n      nonNullableOfNonNullable\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
include Inner;
include Parent.ExtendQuery(Inner);
"
`;

exports[`Template fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  fragment ListFragment on Lists   {\\\\n    nullableOfNullable\\\\n    nullableOfNonNullable\\\\n  }\\\\n\`\\"
  ];
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {nullableOfNullable, nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nullableOfNonNullable: Js.Nullable.t(array(string))};
    type nonrec t_Lists = t;
  };
  type t = {nullableOfNonNullable: option(array(string))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  fragment Another on Lists   {\\\\n    nullableOfNonNullable\\\\n  }\\\\n\`\\"
  ];
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      };
      {nullableOfNonNullable: nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module FragmentWithArgs = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listWithArg: Js.Nullable.t(array(Js.Nullable.t(string)))};
    type nonrec t_Lists = t;
  };
  type t = {listWithArg: option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  fragment FragmentWithArgs on Lists   {\\\\n    listWithArg(arg1: $arg1)\\\\n  }\\\\n\`\\"
  ];
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listWithArg: {
        let value = (value: Raw.t).listWithArg;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (
        ~arg1 as _arg1: [ | \`String],
        ~fragmentName as _FragmentWithArgs: [ | \`FragmentWithArgs],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listWithArg = {
        let value = (value: t).listWithArg;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {listWithArg: listWithArg};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`FragmentWithArgs => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module InlineListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
    };
    type nonrec t_Lists = t;
  };
  type t = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  fragment InlineListFragment on Lists   {\\\\n    nullableOfNullable\\\\n    nullableOfNonNullable\\\\n  }\\\\n\`\\"
  ];
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      nullableOfNonNullable: {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (
        ~fragmentName as _InlineListFragment: [ | \`InlineListFragment],
        value: Raw.t,
      ) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNonNullable = {
        let value = (value: t).nullableOfNonNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(value |> Js.Array.map(value => value))
        | None => Js.Nullable.null
        };
      }
      and nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {nullableOfNullable, nullableOfNonNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`InlineListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      l1: ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
      l5: FragmentWithArgs.Raw.t,
    };
    type t_variables = {arg1: Js.Nullable.t(string)};
  };
  type t_l2 = {
    frag1: ListFragment.t_Lists,
    frag2: ListFragment.t_Lists,
  };
  type t_l3 = {
    nullableOfNullable: option(array(option(string))),
    frag1: ListFragment.t_Lists,
    frag2: ListFragment.t_Lists,
  };
  type t_l4 = {
    nullableOfNullable: option(array(option(string))),
    inlineListFragment: InlineListFragment.t_Lists,
  };
  type t = {
    l1: ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
    l5: FragmentWithArgs.t,
  };
  /**The GraphQL query string*/
  let query: string =
    [%raw
      \\"(frag_0, frag_1, frag_2) => require(\\\\\\"gql\\\\\\")\`\\\\n  query MyQuery($arg1: String)  {\\\\n    l1: lists  {\\\\n      ...ListFragment\\\\n    }\\\\n    l2: lists  {\\\\n      ...ListFragment\\\\n      ...ListFragment\\\\n    }\\\\n    l3: lists  {\\\\n      nullableOfNullable\\\\n      ...ListFragment\\\\n      ...ListFragment\\\\n    }\\\\n    l4: lists  {\\\\n      nullableOfNullable\\\\n      ...InlineListFragment\\\\n    }\\\\n    l5: lists  {\\\\n      ...FragmentWithArgs\\\\n    }\\\\n  }\\\\n\${frag_0}\\\\n\${frag_1}\\\\n\${frag_2}\\\\n\`\\"
    ](
      FragmentWithArgs.query,
      InlineListFragment.query,
      ListFragment.query,
    );
  type t_variables = {arg1: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      l1: {
        let value = (value: Raw.t).l1;

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
      l2: {
        let value = (value: Raw.t).l2;
        (
          {
            frag1: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
            frag2: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
          }: t_l2
        );
      },
      l3: {
        let value = (value: Raw.t).l3;
        (
          {
            nullableOfNullable: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
                );
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            frag1: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
            frag2: {
              let value: ListFragment.Raw.t = Obj.magic(value);

              ListFragment.verifyArgsAndParse(
                ~fragmentName=\`ListFragment,
                value,
              );
            },
          }: t_l3
        );
      },
      l4: {
        let value = (value: Raw.t).l4;
        (
          {
            nullableOfNullable: {
              let value =
                Obj.magic(
                  Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
                );
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            inlineListFragment: {
              let value: InlineListFragment.Raw.t = Obj.magic(value);

              InlineListFragment.verifyArgsAndParse(
                ~fragmentName=\`InlineListFragment,
                value,
              );
            },
          }: t_l4
        );
      },
      l5: {
        let value = (value: Raw.t).l5;

        FragmentWithArgs.verifyArgsAndParse(
          ~arg1=\`String,
          ~fragmentName=\`FragmentWithArgs,
          value,
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let l5 = {
        let value = (value: t).l5;
        FragmentWithArgs.serialize(value);
      }
      and l4 = {
        let value = (value: t).l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l4).nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(
                    InlineListFragment.serialize(
                      (value: t_l4).inlineListFragment,
                    ),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      }
      and l3 = {
        let value = (value: t).l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l3).nullableOfNullable;
                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {\\"nullableOfNullable\\": nullableOfNullable};
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(ListFragment.serialize((value: t_l3).frag1)): Js.Json.t
                ),
                (
                  Obj.magic(ListFragment.serialize((value: t_l3).frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      }
      and l2 = {
        let value = (value: t).l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(ListFragment.serialize((value: t_l2).frag1)): Js.Json.t
                ),
                (
                  Obj.magic(ListFragment.serialize((value: t_l2).frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      }
      and l1 = {
        let value = (value: t).l1;
        ListFragment.serialize(value);
      };
      {l1, l2, l3, l4, l5};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg1:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).arg1,
        ),
    };
  let makeVariables = (~arg1=?, ()) =>
    serializeVariables({arg1: arg1}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {lists: ListFragment.Raw.t};
    type t_variables = unit;
  };
  type t = {lists: ListFragment.t};
  /**The GraphQL query string*/
  let query: string =
    [%raw
      \\"(frag_0) => require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    lists  {\\\\n      ...ListFragment\\\\n    }\\\\n  }\\\\n\${frag_0}\\\\n\`\\"
    ](
      ListFragment.query,
    );
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        ListFragment.serialize(value);
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template fragmentInFragment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module GraphQL_PPX = {
  let deepMerge = (json1, _) => json1;
};
module ListFragment = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
    };
    type nonrec t_Lists = t;
  };
  type t = {nullableOfNullable: option(array(option(string)))};
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  fragment ListFragment on Lists   {\\\\n    nullableOfNullable\\\\n  }\\\\n\`\\"
  ];
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _ListFragment: [ | \`ListFragment], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nullableOfNullable = {
        let value = (value: t).nullableOfNullable;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            value
            |> Js.Array.map(value =>
                 switch (value) {
                 | Some(value) => Js.Nullable.return(value)
                 | None => Js.Nullable.null
                 }
               ),
          )
        | None => Js.Nullable.null
        };
      };
      {nullableOfNullable: nullableOfNullable};
    }: Raw.t
  );
  let verifyName =
    fun
    | \`ListFragment => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module Another = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t;
    type nonrec t_Lists = t;
  };
  type t = {
    nullableOfNullable: option(array(option(string))),
    listFragment: ListFragment.t_Lists,
  };
  type nonrec t_Lists = t;
  /**The GraphQL query string*/
  let query: string =
    [%raw
      \\"(frag_0) => require(\\\\\\"gql\\\\\\")\`\\\\n  fragment Another on Lists   {\\\\n    nullableOfNullable\\\\n    ...ListFragment\\\\n  }\\\\n\${frag_0}\\\\n\`\\"
    ](
      ListFragment.query,
    );
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nullableOfNullable: {
        let value =
          Obj.magic(
            Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
          );
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      },
      listFragment: {
        let value: ListFragment.Raw.t = Obj.magic(value);

        ListFragment.verifyArgsAndParse(~fragmentName=\`ListFragment, value);
      },
    }: t
  );

  let verifyArgsAndParse =
      (~fragmentName as _Another: [ | \`Another], value: Raw.t) =>
    parse(value);
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    Obj.magic(
      Js.Array.reduce(
        GraphQL_PPX.deepMerge,
        Obj.magic(
          {
            let nullableOfNullable = {
              let value = (value: t).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {\\"nullableOfNullable\\": nullableOfNullable};
          },
        ): Js.Json.t,
        [|
          (
            Obj.magic(ListFragment.serialize((value: t).listFragment)): Js.Json.t
          ),
        |],
      ),
    ): Raw.t
  );
  let verifyName =
    fun
    | \`Another => ();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql;
    /**\`\`\`
Lists {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
  listWithArg: [String]
}
\`\`\`*/
    let graphql: graphql = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module GraphQL {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Template lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
    type t_variables = unit;
  };
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    lists  {\\\\n      nullableOfNullable\\\\n      nullableOfNonNullable\\\\n      nonNullableOfNullable\\\\n      nonNullableOfNonNullable\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      lists: {
        let value = (value: Raw.t).lists;
        (
          {
            nullableOfNullable: {
              let value = (value: Raw.t_lists).nullableOfNullable;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map(value =>
                       switch (Js.toOption(value)) {
                       | Some(value) => Some(value)
                       | None => None
                       }
                     ),
                )
              | None => None
              };
            },
            nullableOfNonNullable: {
              let value = (value: Raw.t_lists).nullableOfNonNullable;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value |> Js.Array.map(value => value))
              | None => None
              };
            },
            nonNullableOfNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 );
            },
            nonNullableOfNonNullable: {
              let value = (value: Raw.t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            },
          }: t_lists
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let lists = {
        let value = (value: t).lists;
        (
          {
            let nonNullableOfNonNullable = {
              let value = (value: t_lists).nonNullableOfNonNullable;
              value |> Js.Array.map(value => value);
            }
            and nonNullableOfNullable = {
              let value = (value: t_lists).nonNullableOfNullable;
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 );
            }
            and nullableOfNonNullable = {
              let value = (value: t_lists).nullableOfNonNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(value |> Js.Array.map(value => value))
              | None => Js.Nullable.null
              };
            }
            and nullableOfNullable = {
              let value = (value: t_lists).nullableOfNullable;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map(value =>
                       switch (value) {
                       | Some(value) => Js.Nullable.return(value)
                       | None => Js.Nullable.null
                       }
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {
              nullableOfNullable,
              nullableOfNonNullable,
              nonNullableOfNullable,
              nonNullableOfNonNullable,
            };
          }: Raw.t_lists
        );
      };
      {lists: lists};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  type t = {listsInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\n  listsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listsInput: {
        let value = (value: Raw.t).listsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listsInput = {
        let value = (value: t).listsInput;
        value;
      };
      {listsInput: listsInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables).nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {
        nullableOfNullable,
        nullableOfNonNullable,
        nonNullableOfNullable,
        nonNullableOfNonNullable,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_219;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_219: _graphql_arg_219 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {arg: t_variables_ListsInput}
    and t_variables_ListsInput = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  type t = {listsInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($arg: ListsInput!)  {\\\\n    listsInput(arg: $arg)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      listsInput: {
        let value = (value: Raw.t).listsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let listsInput = {
        let value = (value: t).listsInput;
        value;
      };
      {listsInput: listsInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg: (a => serializeInputObjectListsInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {
      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNullable,
        ),
      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNonNullable,
        ),
      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables_ListsInput).nonNullableOfNullable,
        ),
      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables_ListsInput).nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {
    nullableOfNullable,
    nullableOfNonNullable,
    nonNullableOfNullable,
    nonNullableOfNonNullable,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_82;
    /**Variable **$arg** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_82: _graphql_arg_82 = Obj.magic(0);
    type nonrec _graphql_arg_77;
    /**Argument **arg** on field **listsInput** has the following graphql type:

\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}!
\`\`\`*/
    let _graphql_arg_77: _graphql_arg_77 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_ListsInput_47;
    /**\`\`\`
ListsInput {
  nullableOfNullable: [String]
  nullableOfNonNullable: [String!]
  nonNullableOfNullable: [String]!
  nonNullableOfNonNullable: [String!]!
}
\`\`\`*/
    let _graphql_ListsInput_47: _graphql_ListsInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_value = {stringField: string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      field: t_mutationWithError_errors_field,
      message: string,
    };
    type t_mutationWithError = {
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_value = {stringField: string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    field: t_mutationWithError_errors_field,
    message: string,
  };
  type t_mutationWithError = {
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  mutation   {\\\\n    mutationWithError  {\\\\n      value  {\\\\n        stringField\\\\n      }\\\\n      errors  {\\\\n        field\\\\n        message\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            value: {
              let value = (value: Raw.t_mutationWithError).value;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    stringField: {
                      let value =
                        (value: Raw.t_mutationWithError_value).stringField;
                      value;
                    },
                  }: t_mutationWithError_value,
                )
              | None => None
              };
            },
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | other => \`FutureAddedValue(other)
                             };
                           },
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           }
                           and field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             | \`FutureAddedValue(other) => other
                             };
                           };
                           {field, message};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            }
            and value = {
              let value = (value: t_mutationWithError).value;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let stringField = {
                      let value =
                        (value: t_mutationWithError_value).stringField;
                      value;
                    };
                    {stringField: stringField};
                  }: Raw.t_mutationWithError_value,
                )
              | None => Js.Nullable.null
              };
            };
            {value, errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {optionalInputArgs: string};
    type t_variables = {required: string};
  };
  type t = {optionalInputArgs: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  mutation MyMutation($required: String!)  {\\\\n    optionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {required: string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      optionalInputArgs: {
        let value = (value: Raw.t).optionalInputArgs;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let optionalInputArgs = {
        let value = (value: t).optionalInputArgs;
        value;
      };
      {optionalInputArgs: optionalInputArgs};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {required: (a => a)((inp: t_variables).required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({required: required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  type t = {. \\"optionalInputArgs\\": string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  mutation MyMutation($required: String!)  {\\\\n    optionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {. \\"required\\": string};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => {
    let optionalInputArgs = {
      let value = value##optionalInputArgs;
      value;
    };
    {\\"optionalInputArgs\\": optionalInputArgs};
  };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {\\"required\\": (a => a)(inp##required)};
  let makeVariables = (~required, ()) =>
    serializeVariables({\\"required\\": required}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {field: string};
    type t_first_inner = {inner: Js.Nullable.t(t_first_inner_inner)};
    type t_first = {inner: Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      f1: string,
      f2: string,
    };
    type t_second_inner = {inner: Js.Nullable.t(t_second_inner_inner)};
    type t_second = {inner: Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {field: string};
    type t_let_inner = {inner: Js.Nullable.t(t_let_inner_inner)};
    type t_let = {inner: Js.Nullable.t(t_let_inner)};
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    };
    type t_variables = unit;
  };
  type t_first_inner_inner = {field: string};
  type t_first_inner = {inner: option(t_first_inner_inner)};
  type t_first = {inner: option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {inner: option(t_second_inner_inner)};
  type t_second = {inner: option(t_second_inner)};
  type t_let_inner_inner = {field: string};
  type t_let_inner = {inner: option(t_let_inner_inner)};
  type t_let = {inner: option(t_let_inner)};
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  };
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    first: nestedObject  {\\\\n      inner  {\\\\n        inner  {\\\\n          field\\\\n        }\\\\n      }\\\\n    }\\\\n    second: nestedObject  {\\\\n      inner  {\\\\n        inner  {\\\\n          f1: field\\\\n          f2: field\\\\n        }\\\\n      }\\\\n    }\\\\n    let: nestedObject  {\\\\n      inner  {\\\\n        inner  {\\\\n          field\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      first: {
        let value = (value: Raw.t).first;
        (
          {
            inner: {
              let value = (value: Raw.t_first).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    inner: {
                      let value = (value: Raw.t_first_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            field: {
                              let value =
                                (value: Raw.t_first_inner_inner).field;
                              value;
                            },
                          }: t_first_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_first_inner,
                )
              | None => None
              };
            },
          }: t_first
        );
      },
      second: {
        let value = (value: Raw.t).second;
        (
          {
            inner: {
              let value = (value: Raw.t_second).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    inner: {
                      let value = (value: Raw.t_second_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            f1: {
                              let value = (value: Raw.t_second_inner_inner).f1;
                              value;
                            },
                            f2: {
                              let value = (value: Raw.t_second_inner_inner).f2;
                              value;
                            },
                          }: t_second_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_second_inner,
                )
              | None => None
              };
            },
          }: t_second
        );
      },
      let_: {
        let value = (value: Raw.t).let_;
        (
          {
            inner: {
              let value = (value: Raw.t_let).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    inner: {
                      let value = (value: Raw.t_let_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            field: {
                              let value = (value: Raw.t_let_inner_inner).field;
                              value;
                            },
                          }: t_let_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_let_inner,
                )
              | None => None
              };
            },
          }: t_let
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let let_ = {
        let value = (value: t).let_;
        (
          {
            let inner = {
              let value = (value: t_let).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_let_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_let_inner_inner).field;
                              value;
                            };
                            {field: field};
                          }: Raw.t_let_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {inner: inner};
                  }: Raw.t_let_inner,
                )
              | None => Js.Nullable.null
              };
            };
            {inner: inner};
          }: Raw.t_let
        );
      }
      and second = {
        let value = (value: t).second;
        (
          {
            let inner = {
              let value = (value: t_second).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_second_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let f2 = {
                              let value = (value: t_second_inner_inner).f2;
                              value;
                            }
                            and f1 = {
                              let value = (value: t_second_inner_inner).f1;
                              value;
                            };
                            {f1, f2};
                          }: Raw.t_second_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {inner: inner};
                  }: Raw.t_second_inner,
                )
              | None => Js.Nullable.null
              };
            };
            {inner: inner};
          }: Raw.t_second
        );
      }
      and first = {
        let value = (value: t).first;
        (
          {
            let inner = {
              let value = (value: t_first).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_first_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_first_inner_inner).field;
                              value;
                            };
                            {field: field};
                          }: Raw.t_first_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {inner: inner};
                  }: Raw.t_first_inner,
                )
              | None => Js.Nullable.null
              };
            };
            {inner: inner};
          }: Raw.t_first
        );
      };
      {first, second, let_};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {nonrecursiveInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($arg: NonrecursiveInput!)  {\\\\n    nonrecursiveInput(arg: $arg)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      nonrecursiveInput: {
        let value = (value: Raw.t).nonrecursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let nonrecursiveInput = {
        let value = (value: t).nonrecursiveInput;
        value;
      };
      {nonrecursiveInput: nonrecursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_100;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_100: _graphql_arg_100 = Obj.magic(0);
    type nonrec _graphql_arg_95;
    /**Argument **arg** on field **nonrecursiveInput** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_95: _graphql_arg_95 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_49;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_49: _graphql_NonrecursiveInput_49 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {
      scalarsInput: string,
      more: string,
    };
    type t_variables = {
      arg: t_variables_NonrecursiveInput,
      arg2: t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
      custom: Js.Nullable.t(Js.Json.t),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  type t = {
    scalarsInput: string,
    more: string,
  };
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\n    scalarsInput(arg: $arg)\\\\n    more: scalarsInput(arg: $arg2)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {
    arg: t_variables_NonrecursiveInput,
    arg2: t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
    custom: option(Js.Json.t),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
      more: {
        let value = (value: Raw.t).more;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let more = {
        let value = (value: t).more;
        value;
      }
      and scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput, more};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
      arg2:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg2,
        ),
    }
  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {
      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),
      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),
      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
      custom:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).custom,
        ),
    }
  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {
      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables({arg, arg2}: t_variables)
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        ~custom=?,
        (),
      )
      : t_variables_NonrecursiveInput => {
    nonNullableField,
    nullableArray,
    field,
    enum,
    embeddedInput,
    custom,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {
    field: field,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_240;
    /**Variable **$arg** has the following graphql type:

\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}!
\`\`\`*/
    let _graphql_arg_240: _graphql_arg_240 = Obj.magic(0);
    type nonrec _graphql_arg_235;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_235: _graphql_arg_235 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_NonrecursiveInput_169;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_169: _graphql_NonrecursiveInput_169 =
      Obj.magic(0);
    type nonrec _graphql_NonrecursiveInput_196;
    /**\`\`\`
NonrecursiveInput {
  nonNullableField: String!
  nullableArray: [String]
  field: String
  enum: SampleField
  embeddedInput: [EmbeddedInput]
  custom: CustomScalar
}
\`\`\`*/
    let _graphql_NonrecursiveInput_196: _graphql_NonrecursiveInput_196 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template omitFutureValueEnum.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  mutation   {\\\\n    mutationWithError  {\\\\n      errors  {\\\\n        message\\\\n        field\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | other => \`FutureAddedValue(other)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             | \`FutureAddedValue(other) => other
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           };
                           {message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {errors: errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  mutation   {\\\\n    mutationWithError  {\\\\n      errors  {\\\\n        message\\\\n        field\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | _ => raise(Not_found)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           };
                           {message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {errors: errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      message: string,
      field: t_mutationWithError_errors_field,
    };
    type t_mutationWithError = {
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
    type t_variables = unit;
  };
  type t_mutationWithError_errors_field = [ | \`FIRST | \`SECOND | \`THIRD];
  type t_mutationWithError_errors = {
    message: string,
    field: t_mutationWithError_errors_field,
  };
  type t_mutationWithError = {
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  mutation   {\\\\n    mutationWithError  {\\\\n      errors  {\\\\n        message\\\\n        field\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationWithError: {
        let value = (value: Raw.t).mutationWithError;
        (
          {
            errors: {
              let value = (value: Raw.t_mutationWithError).errors;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           message: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).message;
                             value;
                           },
                           field: {
                             let value =
                               (value: Raw.t_mutationWithError_errors).field;
                             switch (Obj.magic(value: string)) {
                             | \\"FIRST\\" => \`FIRST
                             | \\"SECOND\\" => \`SECOND
                             | \\"THIRD\\" => \`THIRD
                             | _ => raise(Not_found)
                             };
                           },
                         }: t_mutationWithError_errors
                       )
                     ),
                )
              | None => None
              };
            },
          }: t_mutationWithError
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationWithError = {
        let value = (value: t).mutationWithError;
        (
          {
            let errors = {
              let value = (value: t_mutationWithError).errors;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  value
                  |> Js.Array.map((value) =>
                       (
                         {
                           let field = {
                             let value =
                               (value: t_mutationWithError_errors).field;
                             switch (value) {
                             | \`FIRST => \\"FIRST\\"
                             | \`SECOND => \\"SECOND\\"
                             | \`THIRD => \\"THIRD\\"
                             };
                           }
                           and message = {
                             let value =
                               (value: t_mutationWithError_errors).message;
                             value;
                           };
                           {message, field};
                         }: Raw.t_mutationWithError_errors
                       )
                     ),
                )
              | None => Js.Nullable.null
              };
            };
            {errors: errors};
          }: Raw.t_mutationWithError
        );
      };
      {mutationWithError: mutationWithError};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template omitFutureValueUnion.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module Normal = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n      ...on Human   {\\\\n        name\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module Normal {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByConfig = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n      ...on Human   {\\\\n        name\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByConfig {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ByDirective = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n      ...on Human   {\\\\n        name\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => raise(Not_found)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ByDirective {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = unit;
  };
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    pokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\n      id\\\\n      name\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      pokemon: {
        let value = (value: Raw.t).pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              id: {
                let value = (value: Raw.t_pokemon).id;
                value;
              },
              name: {
                let value = (value: Raw.t_pokemon).name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_pokemon,
          )
        | None => None
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let pokemon = {
        let value = (value: t).pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = (value: t_pokemon).name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = (value: t_pokemon).id;
                value;
              };
              {id, name};
            }: Raw.t_pokemon,
          )
        | None => Js.Nullable.null
        };
      };
      {pokemon: pokemon};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_name_52;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_52: _graphql_name_52 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = {
      id: Js.Nullable.t(string),
      name: Js.Nullable.t(string),
    };
  };
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query pokemon($id: String, $name: String)  {\\\\n    pokemon(name: $name, id: $id)  {\\\\n      id\\\\n      name\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      pokemon: {
        let value = (value: Raw.t).pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              id: {
                let value = (value: Raw.t_pokemon).id;
                value;
              },
              name: {
                let value = (value: Raw.t_pokemon).name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              },
            }: t_pokemon,
          )
        | None => None
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let pokemon = {
        let value = (value: t).pokemon;
        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = (value: t_pokemon).name;
                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = (value: t_pokemon).id;
                value;
              };
              {id, name};
            }: Raw.t_pokemon,
          )
        | None => Js.Nullable.null
        };
      };
      {pokemon: pokemon};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      id:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).id,
        ),
      name:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables({id, name}: t_variables);
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_pokemon_name_100;
    /**Variable **$name** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_pokemon_name_100: _graphql_pokemon_name_100 = Obj.magic(0);
    type nonrec _graphql_name_94;
    /**Argument **name** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_name_94: _graphql_name_94 = Obj.magic(0);
    type nonrec _graphql_pokemon_id_111;
    /**Variable **$id** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_pokemon_id_111: _graphql_pokemon_id_111 = Obj.magic(0);
    type nonrec _graphql_id_107;
    /**Argument **id** on field **pokemon** has the following graphql type:

\`\`\`
String
\`\`\`*/
    let _graphql_id_107: _graphql_id_107 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t = {variousScalars: scalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      string\\\\n      int\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
          }: scalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let int = {
              let value = (value: scalars).int;
              value;
            }
            and string = {
              let value = (value: scalars).string;
              value;
            };
            {string, int};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module OneFieldQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {nullableString: Js.Nullable.t(string)};
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {nullableString: option(string)};
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullableString: nullableString};
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module OneFieldQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module ExternalFragmentQuery = {
  module Fragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        string,
        int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;
    /**The GraphQL query string*/
    let query: string = [%raw
      \\"require(\\\\\\"gql\\\\\\")\`\\\\n  fragment Fragment on VariousScalars   {\\\\n    string\\\\n    int\\\\n  }\\\\n\`\\"
    ];
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        string: {
          let value = (value: Raw.t).string;
          value;
        },
        int: {
          let value = (value: Raw.t).int;
          value;
        },
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _Fragment: [ | \`Fragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let int = {
          let value = (value: t).int;
          value;
        }
        and string = {
          let value = (value: t).string;
          value;
        };
        {string, int};
      }: Raw.t
    );
    let verifyName =
      fun
      | \`Fragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
VariousScalars {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
      type t_variables = unit;
    };
    type t = {variousScalars: Fragment.t};
    /**The GraphQL query string*/
    let query: string =
      [%raw
        \\"(frag_0) => require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      ...Fragment\\\\n    }\\\\n  }\\\\n\${frag_0}\\\\n\`\\"
      ](
        Fragment.query,
      );
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        variousScalars: {
          let value = (value: Raw.t).variousScalars;

          Fragment.verifyArgsAndParse(~fragmentName=\`Fragment, value);
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          Fragment.serialize(value);
        };
        {variousScalars: variousScalars};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module ExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
module InlineFragmentQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module InlineFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module UnionExternalFragmentQuery = {
  module DogFragment = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;
    /**The GraphQL query string*/
    let query: string = [%raw
      \\"require(\\\\\\"gql\\\\\\")\`\\\\n  fragment DogFragment on Dog   {\\\\n    name\\\\n    barkVolume\\\\n  }\\\\n\`\\"
    ];
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        name: {
          let value = (value: Raw.t).name;
          value;
        },
        barkVolume: {
          let value = (value: Raw.t).barkVolume;
          value;
        },
      }: t
    );

    let verifyArgsAndParse =
        (~fragmentName as _DogFragment: [ | \`DogFragment], value: Raw.t) =>
      parse(value);
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let barkVolume = {
          let value = (value: t).barkVolume;
          value;
        }
        and name = {
          let value = (value: t).name;
          value;
        };
        {name, barkVolume};
      }: Raw.t
    );
    let verifyName =
      fun
      | \`DogFragment => ();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql;
      /**\`\`\`
Dog {
  name: String!
  barkVolume: Float!
}
\`\`\`*/
      let graphql: graphql = Obj.magic(0);
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
  module Untitled1 = {
    [@ocaml.warning \\"-32\\"];
    module Raw = {
      type t_dogOrHuman;
      type t = {dogOrHuman: t_dogOrHuman};
      type t_variables = unit;
    };
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {dogOrHuman: t_dogOrHuman};
    /**The GraphQL query string*/
    let query: string =
      [%raw
        \\"(frag_0) => require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        ...DogFragment\\\\n      }\\\\n    }\\\\n  }\\\\n\${frag_0}\\\\n\`\\"
      ](
        DogFragment.query,
      );
    type t_variables = unit;
    /**Parse the JSON GraphQL data to ReasonML data types*/
    let parse = (value: Raw.t): t => (
      {
        dogOrHuman: {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: DogFragment.Raw.t = Obj.magic(value);

                  DogFragment.verifyArgsAndParse(
                    ~fragmentName=\`DogFragment,
                    value,
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        },
      }: t
    );
    /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
    let serialize = (value: t): Raw.t => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {dogOrHuman: dogOrHuman};
      }: Raw.t
    );
    let serializeVariables = () => ();
    let makeVariables = () => ();
    let makeDefaultVariables = () => makeVariables();
    external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
    external toJson: Raw.t => Js.Json.t = \\"%identity\\";
    external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
    module Z__INTERNAL = {
      type root = t;
      type nonrec graphql_module;
      /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module UnionExternalFragmentQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
      let graphql_module: graphql_module = Obj.magic(0);
    };
  };
};
"
`;

exports[`Template recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {recursiveInput: string};
    type t_variables = {arg: t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      otherField: Js.Nullable.t(string),
      inner: Js.Nullable.t(t_variables_RecursiveInput),
      enum: Js.Nullable.t(string),
    };
  };
  type t = {recursiveInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($arg: RecursiveInput!)  {\\\\n    recursiveInput(arg: $arg)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      recursiveInput: {
        let value = (value: Raw.t).recursiveInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let recursiveInput = {
        let value = (value: t).recursiveInput;
        value;
      };
      {recursiveInput: recursiveInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectRecursiveInput(a))((inp: t_variables).arg),
    }
  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {
      otherField:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_RecursiveInput).otherField,
        ),
      inner:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).inner,
        ),
      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {
    otherField,
    inner,
    enum,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_90;
    /**Variable **$arg** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_90: _graphql_arg_90 = Obj.magic(0);
    type nonrec _graphql_arg_85;
    /**Argument **arg** on field **recursiveInput** has the following graphql type:

\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}!
\`\`\`*/
    let _graphql_arg_85: _graphql_arg_85 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_RecursiveInput_47;
    /**\`\`\`
RecursiveInput {
  otherField: String
  inner: RecursiveInput
  enum: SampleField
}
\`\`\`*/
    let _graphql_RecursiveInput_47: _graphql_RecursiveInput_47 = Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  type t = {scalarsInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\n  scalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput: scalarsInput};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableString,
        ),
      string: (a => a)((inp: t_variables).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableInt,
        ),
      int: (a => a)((inp: t_variables).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableFloat,
        ),
      float: (a => a)((inp: t_variables).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableID,
        ),
      id: (a => a)((inp: t_variables).id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {
        nullableString,
        string,
        nullableInt,
        int,
        nullableFloat,
        float,
        nullableBoolean,
        boolean,
        nullableID,
        id,
      }: t_variables,
    );
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_292;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_292: _graphql_arg_292 = Obj.magic(0);
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  type t = {scalarsInput: string};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($arg: VariousScalarsInput!)  {\\\\n    scalarsInput(arg: $arg)\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      scalarsInput: {
        let value = (value: Raw.t).scalarsInput;
        value;
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let scalarsInput = {
        let value = (value: t).scalarsInput;
        value;
      };
      {scalarsInput: scalarsInput};
    }: Raw.t
  );
  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {
      arg:
        (a => serializeInputObjectVariousScalarsInput(a))(
          (inp: t_variables).arg,
        ),
    }
  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {
      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableString,
        ),
      string: (a => a)((inp: t_variables_VariousScalarsInput).string),
      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableInt,
        ),
      int: (a => a)((inp: t_variables_VariousScalarsInput).int),
      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableFloat,
        ),
      float: (a => a)((inp: t_variables_VariousScalarsInput).float),
      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableBoolean,
        ),
      boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),
      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableID,
        ),
      id: (a => a)((inp: t_variables_VariousScalarsInput).id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables({arg: arg}: t_variables)
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {
    nullableString,
    string,
    nullableInt,
    int,
    nullableFloat,
    float,
    nullableBoolean,
    boolean,
    nullableID,
    id,
  };
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type nonrec _graphql_arg_93;
    /**Variable **$arg** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_93: _graphql_arg_93 = Obj.magic(0);
    type nonrec _graphql_arg_88;
    /**Argument **arg** on field **scalarsInput** has the following graphql type:

\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}!
\`\`\`*/
    let _graphql_arg_88: _graphql_arg_88 = Obj.magic(0);
    type root = t;
    type nonrec _graphql_VariousScalarsInput_47;
    /**\`\`\`
VariousScalarsInput {
  nullableString: String
  string: String!
  nullableInt: Int
  int: Int!
  nullableFloat: Float
  float: Float!
  nullableBoolean: Boolean
  boolean: Boolean!
  nullableID: ID
  id: ID!
}
\`\`\`*/
    let _graphql_VariousScalarsInput_47: _graphql_VariousScalarsInput_47 =
      Obj.magic(0);
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_v1 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t_v2 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t = {
      v1: t_v1,
      v2: t_v2,
    };
    type t_variables = {var: bool};
  };
  type t_v1 = {
    nullableString: option(string),
    string: option(string),
  };
  type t_v2 = {
    nullableString: option(string),
    string: option(string),
  };
  type t = {
    v1: t_v1,
    v2: t_v2,
  };
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query ($var: Boolean!)  {\\\\n    v1: variousScalars  {\\\\n      nullableString @skip(if: $var)\\\\n      string @skip(if: $var)\\\\n    }\\\\n    v2: variousScalars  {\\\\n      nullableString @include(if: $var)\\\\n      string @include(if: $var)\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = {var: bool};
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      v1: {
        let value = (value: Raw.t).v1;
        (
          {
            nullableString: {
              let value = (value: Raw.t_v1).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_v1).string;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_v1
        );
      },
      v2: {
        let value = (value: Raw.t).v2;
        (
          {
            nullableString: {
              let value = (value: Raw.t_v2).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_v2).string;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
          }: t_v2
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let v2 = {
        let value = (value: t).v2;
        (
          {
            let string = {
              let value = (value: t_v2).string;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and nullableString = {
              let value = (value: t_v2).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullableString, string};
          }: Raw.t_v2
        );
      }
      and v1 = {
        let value = (value: t).v1;
        (
          {
            let string = {
              let value = (value: t_v1).string;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and nullableString = {
              let value = (value: t_v1).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {nullableString, string};
          }: Raw.t_v1
        );
      };
      {v1, v2};
    }: Raw.t
  );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {var: (a => a)((inp: t_variables).var)};
  let makeVariables = (~var, ()) =>
    serializeVariables({var: var}: t_variables);
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_simpleSubscription_Dog = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription_Human = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription;
    type t = {simpleSubscription: t_simpleSubscription};
    type t_variables = unit;
  };
  type t_simpleSubscription_Dog = {name: string};
  type t_simpleSubscription_Human = {name: string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {simpleSubscription: t_simpleSubscription};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  subscription   {\\\\n    simpleSubscription  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n      }\\\\n      ...on Human   {\\\\n        name\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      simpleSubscription: {
        let value = (value: Raw.t).simpleSubscription;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_simpleSubscription_Dog).name;
                      value;
                    },
                  }: t_simpleSubscription_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_simpleSubscription_Human).name;
                      value;
                    },
                  }: t_simpleSubscription_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let simpleSubscription = {
        let value = (value: t).simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_simpleSubscription_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name};
              }: Raw.t_simpleSubscription_Dog,
            ): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_simpleSubscription_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_simpleSubscription_Human,
            ): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      };
      {simpleSubscription: simpleSubscription};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

module MyTypes = {
  type query;
};
module MyQuery1a = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: MyTypes.query = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1a {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery1b = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery1b {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery2 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery2 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery3 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\").graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery3 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQuery4 = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
    type t_variables = unit;
  };
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gatsby\\\\\\")\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      variousScalars: {
        let value = (value: Raw.t).variousScalars;
        (
          {
            nullableString: {
              let value = (value: Raw.t_variousScalars).nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            string: {
              let value = (value: Raw.t_variousScalars).string;
              value;
            },
            nullableInt: {
              let value = (value: Raw.t_variousScalars).nullableInt;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            int: {
              let value = (value: Raw.t_variousScalars).int;
              value;
            },
            nullableFloat: {
              let value = (value: Raw.t_variousScalars).nullableFloat;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            float: {
              let value = (value: Raw.t_variousScalars).float;
              value;
            },
            nullableBoolean: {
              let value = (value: Raw.t_variousScalars).nullableBoolean;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            boolean: {
              let value = (value: Raw.t_variousScalars).boolean;
              value;
            },
            nullableID: {
              let value = (value: Raw.t_variousScalars).nullableID;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            },
            id: {
              let value = (value: Raw.t_variousScalars).id;
              value;
            },
          }: t_variousScalars
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let variousScalars = {
        let value = (value: t).variousScalars;
        (
          {
            let id = {
              let value = (value: t_variousScalars).id;
              value;
            }
            and nullableID = {
              let value = (value: t_variousScalars).nullableID;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and boolean = {
              let value = (value: t_variousScalars).boolean;
              value;
            }
            and nullableBoolean = {
              let value = (value: t_variousScalars).nullableBoolean;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and float = {
              let value = (value: t_variousScalars).float;
              value;
            }
            and nullableFloat = {
              let value = (value: t_variousScalars).nullableFloat;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and int = {
              let value = (value: t_variousScalars).int;
              value;
            }
            and nullableInt = {
              let value = (value: t_variousScalars).nullableInt;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            }
            and string = {
              let value = (value: t_variousScalars).string;
              value;
            }
            and nullableString = {
              let value = (value: t_variousScalars).nullableString;
              switch (value) {
              | Some(value) => Js.Nullable.return(value)
              | None => Js.Nullable.null
              };
            };
            {
              nullableString,
              string,
              nullableInt,
              int,
              nullableFloat,
              float,
              nullableBoolean,
              boolean,
              nullableID,
              id,
            };
          }: Raw.t_variousScalars
        );
      };
      {variousScalars: variousScalars};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery4 {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t = {first: t_first};
    type t_variables = unit;
  };
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t = {first: t_first};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    first: nestedObject  {\\\\n      __typename\\\\n      inner  {\\\\n        __typename\\\\n        inner  {\\\\n          __typename\\\\n          field\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      first: {
        let value = (value: Raw.t).first;
        (
          {
            __typename: {
              let value = (value: Raw.t_first).__typename;
              value;
            },
            inner: {
              let value = (value: Raw.t_first).inner;
              switch (Js.toOption(value)) {
              | Some(value) =>
                Some(
                  {
                    __typename: {
                      let value = (value: Raw.t_first_inner).__typename;
                      value;
                    },
                    inner: {
                      let value = (value: Raw.t_first_inner).inner;
                      switch (Js.toOption(value)) {
                      | Some(value) =>
                        Some(
                          {
                            __typename: {
                              let value =
                                (value: Raw.t_first_inner_inner).__typename;
                              value;
                            },
                            field: {
                              let value =
                                (value: Raw.t_first_inner_inner).field;
                              value;
                            },
                          }: t_first_inner_inner,
                        )
                      | None => None
                      };
                    },
                  }: t_first_inner,
                )
              | None => None
              };
            },
          }: t_first
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let first = {
        let value = (value: t).first;
        (
          {
            let inner = {
              let value = (value: t_first).inner;
              switch (value) {
              | Some(value) =>
                Js.Nullable.return(
                  {
                    let inner = {
                      let value = (value: t_first_inner).inner;
                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          {
                            let field = {
                              let value = (value: t_first_inner_inner).field;
                              value;
                            }
                            and __typename = {
                              let value =
                                (value: t_first_inner_inner).__typename;
                              value;
                            };
                            {__typename, field};
                          }: Raw.t_first_inner_inner,
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_first_inner).__typename;
                      value;
                    };
                    {__typename, inner};
                  }: Raw.t_first_inner,
                )
              | None => Js.Nullable.null
              };
            }
            and __typename = {
              let value = (value: t_first).__typename;
              value;
            };
            {__typename, inner};
          }: Raw.t_first
        );
      };
      {first: first};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n      ...on Human   {\\\\n        name\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
module MyQueryNoError = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n      ...on Human   {\\\\n        name\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: t_dogOrHuman_Human
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: t_dogOrHuman_Human).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQueryNoError {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};

type named = {name: string};
module NamedQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(named)
    | \`Human(named)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n      }\\\\n      ...on Human   {\\\\n        name\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                  }: named
                );
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Human).name;
                      value;
                    },
                  }: named
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: named).name;
                  value;
                };
                {__typename: \\"Dog\\", name};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = (value: named).name;
                  value;
                };
                {__typename: \\"Human\\", name};
              }: Raw.t_dogOrHuman_Human,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module NamedQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
    type t_variables = unit;
  };
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  query   {\\\\n    dogOrHuman  {\\\\n      __typename\\\\n      ...on Dog   {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      dogOrHuman: {
        let value = (value: Raw.t).dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    name: {
                      let value = (value: Raw.t_dogOrHuman_Dog).name;
                      value;
                    },
                    barkVolume: {
                      let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                      value;
                    },
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let dogOrHuman = {
        let value = (value: t).dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;
                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;
                  value;
                };
                {__typename: \\"Dog\\", name, barkVolume};
              }: Raw.t_dogOrHuman_Dog,
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {dogOrHuman: dogOrHuman};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;

exports[`Template variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  [@ocaml.warning \\"-32\\"];
  module Raw = {
    type t_mutationForVariant_dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {mutationForVariant: t_mutationForVariant};
    type t_variables = unit;
  };
  type t_mutationForVariant_dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_human = {name: string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {name: string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {mutationForVariant: t_mutationForVariant};
  /**The GraphQL query string*/
  let query: string = [%raw
    \\"require(\\\\\\"gql\\\\\\")\`\\\\n  mutation   {\\\\n    mutationForVariant  {\\\\n      baseType\\\\n      baseTypeList\\\\n      dog  {\\\\n        name\\\\n        barkVolume\\\\n      }\\\\n      human  {\\\\n        name\\\\n      }\\\\n      dogOrHuman  {\\\\n        __typename\\\\n        ...on Dog   {\\\\n          name\\\\n          barkVolume\\\\n        }\\\\n        ...on Human   {\\\\n          name\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variables = unit;
  /**Parse the JSON GraphQL data to ReasonML data types*/
  let parse = (value: Raw.t): t => (
    {
      mutationForVariant: {
        let value = (value: Raw.t).mutationForVariant;
        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {
        | None =>
          Js.Exn.raiseError(
            \\"graphql-ppx: \\"
            ++ \\"Expected type \\"
            ++ \\"VariantTestResult\\"
            ++ \\" to be an object\\",
          )
        | Some(value) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseType(value);
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseTypeList(value |> Js.Array.map(value => value));
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Dog(
                  {
                    name: {
                      let value = (value: Raw.t_mutationForVariant_dog).name;
                      value;
                    },
                    barkVolume: {
                      let value =
                        (value: Raw.t_mutationForVariant_dog).barkVolume;
                      value;
                    },
                  }: t_mutationForVariant_dog,
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Human(
                    {
                      name: {
                        let value =
                          (value: Raw.t_mutationForVariant_human).name;
                        value;
                      },
                    }: t_mutationForVariant_human,
                  );
                | Some(_) =>
                  let temp =
                    Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`DogOrHuman(
                      {
                        let typename: string =
                          Obj.magic(
                            Js.Dict.unsafeGet(
                              Obj.magic(value),
                              \\"__typename\\",
                            ),
                          );
                        (
                          switch (typename) {
                          | \\"Dog\\" =>
                            \`Dog(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                  Obj.magic(value);
                                (
                                  {
                                    name: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                        ).
                                          name;
                                      value;
                                    },
                                    barkVolume: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                        ).
                                          barkVolume;
                                      value;
                                    },
                                  }: t_mutationForVariant_dogOrHuman_Dog
                                );
                              },
                            )
                          | \\"Human\\" =>
                            \`Human(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                  Obj.magic(value);
                                (
                                  {
                                    name: {
                                      let value =
                                        (
                                          value: Raw.t_mutationForVariant_dogOrHuman_Human
                                        ).
                                          name;
                                      value;
                                    },
                                  }: t_mutationForVariant_dogOrHuman_Human
                                );
                              },
                            )
                          | _ =>
                            \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                          }: t_mutationForVariant_dogOrHuman
                        );
                      },
                    );
                  | Some(_) =>
                    Js.Exn.raiseError(
                      \\"graphql-ppx: \\"
                      ++ \\"All fields on variant selection set on type \\"
                      ++ \\"VariantTestResult\\"
                      ++ \\" were null\\",
                    )
                  };
                };
              };
            };
          };
        };
      },
    }: t
  );
  /**Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data */
  let serialize = (value: t): Raw.t => (
    {
      let mutationForVariant = {
        let value = (value: t).mutationForVariant;
        Obj.magic(Js.Json.null);
      };
      {mutationForVariant: mutationForVariant};
    }: Raw.t
  );
  let serializeVariables = () => ();
  let makeVariables = () => ();
  let makeDefaultVariables = () => makeVariables();
  external unsafe_fromJson: Js.Json.t => Raw.t = \\"%identity\\";
  external toJson: Raw.t => Js.Json.t = \\"%identity\\";
  external variablesToJson: Raw.t_variables => Js.Json.t = \\"%identity\\";
  module Z__INTERNAL = {
    type root = t;
    type nonrec graphql_module;
    /****--- graphql-ppx module ---**

The contents of this module are automatically generated by \`graphql-ppx\`.
The following is simply an overview of the most important variables and types that you can access from this module.

\`\`\`
module MyQuery {
  /**
  The GraphQL query string
  */
  let query: string;

  /**
  This is the main type of the result you will get back.
  You can hover above the identifier key (e.g. query or mutation) to see the fully generated type for your module.
  */
  type t;

  /**
  Parse the JSON GraphQL data to ReasonML data types
  */
  let parse: Raw.t => t;

  /**
  Serialize the ReasonML GraphQL data that was parsed using the parse function back to the original JSON compatible data
  */
  let serialize: t => Raw.t;

  /**
  This is the JSON compatible type of the GraphQL data.
  It should not be necessary to access the types inside for normal use cases.
  */
  module Raw: { type t; };
}
\`\`\`*/
    let graphql_module: graphql_module = Obj.magic(0);
  };
};
"
`;
